// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Anela.Heblo.Xcc")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+6cd183ef4ac33ad09cbb7ecd6a8b9c35891c45cb")]
[assembly: System.Reflection.AssemblyProductAttribute("Anela.Heblo.Xcc")]
[assembly: System.Reflection.AssemblyTitleAttribute("Anela.Heblo.Xcc")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

namespace Anela.Heblo.Xcc;

/// <summary>
/// Extension methods for TimeProvider to handle time display and localization
/// </summary>
public static class TimeProviderExtensions
{
    /// <summary>
    /// Gets the current local time for display purposes
    /// </summary>
    public static DateTime GetLocalTime(this TimeProvider timeProvider)
    {
        return timeProvider.GetLocalNow().DateTime;
    }

    /// <summary>
    /// Converts UTC DateTime to local time for display
    /// </summary>
    public static DateTime ToLocalTime(this TimeProvider timeProvider, DateTime utcDateTime)
    {
        if (utcDateTime.Kind == DateTimeKind.Utc)
        {
            return timeProvider.GetLocalNow().DateTime.AddTicks(utcDateTime.Ticks - timeProvider.GetUtcNow().Ticks);
        }

        // Assume UTC if kind is unspecified
        return timeProvider.GetLocalNow().DateTime.AddTicks(utcDateTime.Ticks - timeProvider.GetUtcNow().Ticks);
    }

    /// <summary>
    /// Formats UTC DateTime for display in local timezone
    /// </summary>
    public static string FormatForDisplay(this TimeProvider timeProvider, DateTime utcDateTime, string format = "yyyy-MM-dd HH:mm:ss")
    {
        return timeProvider.ToLocalTime(utcDateTime).ToString(format);
    }

    /// <summary>
    /// Gets display-friendly filename timestamp in local time
    /// </summary>
    public static string GetFilenameTimestamp(this TimeProvider timeProvider)
    {
        return timeProvider.GetLocalTime().ToString("yyyy-MM-ddTHHmmss");
    }
}
namespace Anela.Heblo.Xcc;

public static class StringExtensions
{
    /// <summary>
    /// Gets a substring of a string from beginning of the string.
    /// </summary>
    /// <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="str" /> is null</exception>
    /// <exception cref="T:System.ArgumentException">Thrown if <paramref name="len" /> is bigger that string's length</exception>
    public static string Left(this string str, int len)
    {
        Check.NotNull<string>(str, nameof(str));
        if (str.Length < len)
            throw new ArgumentException("len argument can not be bigger than given string's length!");
        return str.Substring(0, len);
    }


    /// <summary>Gets a substring of a string from end of the string.</summary>
    /// <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="str" /> is null</exception>
    /// <exception cref="T:System.ArgumentException">Thrown if <paramref name="len" /> is bigger that string's length</exception>
    public static string Right(this string str, int len)
    {
        Check.NotNull<string>(str, nameof(str));
        if (str.Length < len)
            throw new ArgumentException("len argument can not be bigger than given string's length!");
        return str.Substring(str.Length - len, len);
    }
}
using System.Linq.Expressions;

namespace Anela.Heblo.Xcc;

public static class ExpressionExtensions
{
    public static Expression<Func<T, bool>> And<T>(
        this Expression<Func<T, bool>> left,
        Expression<Func<T, bool>> right)
    {
        var parameter = left.Parameters[0];
        var body = Expression.AndAlso(left.Body, Expression.Invoke(right, parameter));
        return Expression.Lambda<Func<T, bool>>(body, parameter);
    }

    public static Expression<Func<T, bool>> Or<T>(
        this Expression<Func<T, bool>> left,
        Expression<Func<T, bool>> right)
    {
        var parameter = left.Parameters[0];
        var body = Expression.OrElse(left.Body, Expression.Invoke(right, parameter));
        return Expression.Lambda<Func<T, bool>>(body, parameter);
    }
}
namespace Anela.Heblo.Xcc;

public static class Check
{
    public static T NotNull<T>([System.Diagnostics.CodeAnalysis.NotNull] T? value, string parameterName)
    {
        return (object)value != null ? value : throw new ArgumentNullException(parameterName);
    }

    public static T NotNull<T>([System.Diagnostics.CodeAnalysis.NotNull] T? value, string parameterName, string message)
    {
        return (object)value != null ? value : throw new ArgumentNullException(parameterName, message);
    }
}
using System.Collections.Concurrent;

namespace Anela.Heblo.Xcc.Audit;

public class InMemoryDataLoadAuditService : IDataLoadAuditService
{
    private readonly ConcurrentDictionary<string, DataLoadAuditEntry> _auditLogs = new();
    private readonly int _maxEntries = 10000; // Limit memory usage

    public Task LogDataLoadAsync(string dataType, string source, int recordCount, bool success, Dictionary<string, object>? parameters = null, string? errorMessage = null, TimeSpan? duration = null)
    {
        var entry = new DataLoadAuditEntry
        {
            DataType = dataType,
            Source = source,
            RecordCount = recordCount,
            Success = success,
            ErrorMessage = errorMessage,
            Parameters = parameters ?? new Dictionary<string, object>(),
            Duration = duration ?? TimeSpan.Zero
        };

        AddEntry(entry);
        return Task.CompletedTask;
    }

    public Task<DataLoadAuditEntry> StartDataLoadAuditAsync(string dataType, string source, Dictionary<string, object>? parameters = null)
    {
        var entry = new DataLoadAuditEntry
        {
            DataType = dataType,
            Source = source,
            Parameters = parameters ?? new Dictionary<string, object>(),
            Success = false // Will be updated on completion
        };

        AddEntry(entry);
        return Task.FromResult(entry);
    }

    public Task CompleteDataLoadAuditAsync(string auditId, int recordCount, bool success, string? errorMessage = null)
    {
        if (_auditLogs.TryGetValue(auditId, out var entry))
        {
            var completionTime = DateTime.UtcNow;
            entry.RecordCount = recordCount;
            entry.Success = success;
            entry.ErrorMessage = errorMessage;
            entry.Duration = completionTime - entry.Timestamp;
        }

        return Task.CompletedTask;
    }

    public Task<IReadOnlyList<DataLoadAuditEntry>> GetAuditLogsAsync(int? limit = null, DateTime? fromDate = null, DateTime? toDate = null)
    {
        var query = _auditLogs.Values.AsEnumerable();

        if (fromDate.HasValue)
        {
            query = query.Where(x => x.Timestamp >= fromDate.Value);
        }

        if (toDate.HasValue)
        {
            query = query.Where(x => x.Timestamp <= toDate.Value);
        }

        var results = query
            .OrderByDescending(x => x.Timestamp)
            .Take(limit ?? 1000)
            .ToList();

        return Task.FromResult<IReadOnlyList<DataLoadAuditEntry>>(results);
    }

    private void AddEntry(DataLoadAuditEntry entry)
    {
        _auditLogs[entry.Id] = entry;

        // Cleanup old entries if we exceed the limit
        if (_auditLogs.Count > _maxEntries)
        {
            var oldestEntries = _auditLogs.Values
                .OrderBy(x => x.Timestamp)
                .Take(_auditLogs.Count - _maxEntries + 100) // Remove extra to avoid frequent cleanups
                .ToList();

            foreach (var oldEntry in oldestEntries)
            {
                _auditLogs.TryRemove(oldEntry.Id, out _);
            }
        }
    }
}
namespace Anela.Heblo.Xcc.Audit;

public interface IDataLoadAuditService
{
    Task LogDataLoadAsync(string dataType, string source, int recordCount, bool success, Dictionary<string, object>? parameters = null, string? errorMessage = null, TimeSpan? duration = null);
    Task<IReadOnlyList<DataLoadAuditEntry>> GetAuditLogsAsync(int? limit = null, DateTime? fromDate = null, DateTime? toDate = null);
    Task<DataLoadAuditEntry> StartDataLoadAuditAsync(string dataType, string source, Dictionary<string, object>? parameters = null);
    Task CompleteDataLoadAuditAsync(string auditId, int recordCount, bool success, string? errorMessage = null);
}
namespace Anela.Heblo.Xcc.Audit;

public class DataLoadAuditEntry
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
    public string DataType { get; set; } = string.Empty;
    public string Source { get; set; } = string.Empty;
    public int RecordCount { get; set; }
    public bool Success { get; set; }
    public string? ErrorMessage { get; set; }
    public Dictionary<string, object> Parameters { get; set; } = new();
    public TimeSpan Duration { get; set; }
}
using System.Linq.Expressions;
using Anela.Heblo.Xcc.Domain;

namespace Anela.Heblo.Xcc.Persistance;

public interface IReadOnlyRepository<TEntity, TKey>
    where TEntity : class, IEntity<TKey>
{
    // Query operations
    Task<TEntity?> GetByIdAsync(TKey id, CancellationToken cancellationToken = default);
    Task<IEnumerable<TEntity>> GetAllAsync(CancellationToken cancellationToken = default);
    Task<IEnumerable<TEntity>> FindAsync(Expression<Func<TEntity, bool>> predicate, CancellationToken cancellationToken = default);
    Task<TEntity?> SingleOrDefaultAsync(Expression<Func<TEntity, bool>> predicate, CancellationToken cancellationToken = default);
    Task<bool> AnyAsync(Expression<Func<TEntity, bool>> predicate, CancellationToken cancellationToken = default);
    Task<int> CountAsync(Expression<Func<TEntity, bool>>? predicate = null, CancellationToken cancellationToken = default);
}
using System.Linq.Expressions;
using Anela.Heblo.Xcc.Domain;

namespace Anela.Heblo.Xcc.Persistance;

/// <summary>
/// Empty repository implementation that returns empty values for all operations.
/// Useful for testing or when a repository is not yet implemented.
/// </summary>
public class EmptyRepository<TEntity, TKey> : IRepository<TEntity, TKey>
    where TEntity : class, IEntity<TKey>
{
    // Query operations
    public Task<TEntity?> GetByIdAsync(TKey id, CancellationToken cancellationToken = default)
    {
        return Task.FromResult<TEntity?>(null);
    }

    public Task<IEnumerable<TEntity>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        return Task.FromResult<IEnumerable<TEntity>>(Enumerable.Empty<TEntity>());
    }

    public Task<IEnumerable<TEntity>> FindAsync(Expression<Func<TEntity, bool>> predicate, CancellationToken cancellationToken = default)
    {
        return Task.FromResult<IEnumerable<TEntity>>(Enumerable.Empty<TEntity>());
    }

    public Task<TEntity?> SingleOrDefaultAsync(Expression<Func<TEntity, bool>> predicate, CancellationToken cancellationToken = default)
    {
        return Task.FromResult<TEntity?>(null);
    }

    public Task<bool> AnyAsync(Expression<Func<TEntity, bool>> predicate, CancellationToken cancellationToken = default)
    {
        return Task.FromResult(false);
    }

    public Task<int> CountAsync(Expression<Func<TEntity, bool>>? predicate = null, CancellationToken cancellationToken = default)
    {
        return Task.FromResult(0);
    }

    // Command operations
    public Task<TEntity> AddAsync(TEntity entity, CancellationToken cancellationToken = default)
    {
        // Return the same entity as if it was added
        return Task.FromResult(entity);
    }

    public Task<IEnumerable<TEntity>> AddRangeAsync(IEnumerable<TEntity> entities, CancellationToken cancellationToken = default)
    {
        // Return the same entities as if they were added
        return Task.FromResult(entities);
    }

    public Task UpdateAsync(TEntity entity, CancellationToken cancellationToken = default)
    {
        // No-op for empty repository
        return Task.CompletedTask;
    }

    public Task DeleteAsync(TEntity entity, CancellationToken cancellationToken = default)
    {
        // No-op for empty repository
        return Task.CompletedTask;
    }

    public Task DeleteAsync(TKey id, CancellationToken cancellationToken = default)
    {
        // No-op for empty repository
        return Task.CompletedTask;
    }

    public Task DeleteRangeAsync(IEnumerable<TEntity> entities, CancellationToken cancellationToken = default)
    {
        // No-op for empty repository
        return Task.CompletedTask;
    }

    // Unit of Work operations
    public Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        // Return 0 as no changes are saved
        return Task.FromResult(0);
    }
}
using Anela.Heblo.Xcc.Domain;

namespace Anela.Heblo.Xcc.Persistance;

/// <summary>
/// Generic repository interface for common database operations
/// </summary>
/// <typeparam name="TEntity">The entity type</typeparam>
/// <typeparam name="TKey">Unique entity key</typeparam>
public interface IRepository<TEntity, TKey> : IReadOnlyRepository<TEntity, TKey>
    where TEntity : class, IEntity<TKey>
{
    // Command operations
    Task<TEntity> AddAsync(TEntity entity, CancellationToken cancellationToken = default);
    Task<IEnumerable<TEntity>> AddRangeAsync(IEnumerable<TEntity> entities, CancellationToken cancellationToken = default);
    Task UpdateAsync(TEntity entity, CancellationToken cancellationToken = default);
    Task DeleteAsync(TEntity entity, CancellationToken cancellationToken = default);
    Task DeleteAsync(TKey id, CancellationToken cancellationToken = default);
    Task DeleteRangeAsync(IEnumerable<TEntity> entities, CancellationToken cancellationToken = default);

    // Unit of Work operations
    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);
}
namespace Anela.Heblo.Xcc.Telemetry;

/// <summary>
/// Service for tracking business events and metrics for observability
/// </summary>
public interface ITelemetryService
{
    // Core telemetry operations
    void TrackBusinessEvent(string eventName, Dictionary<string, string>? properties = null, Dictionary<string, double>? metrics = null);
    void TrackException(Exception exception, Dictionary<string, string>? properties = null);
    void TrackMetric(string metricName, double value, Dictionary<string, string>? properties = null);
    void TrackDependency(string dependencyName, string commandName, DateTimeOffset startTime, TimeSpan duration, bool success);

    // Business-specific operations
    void TrackInvoiceImport(string invoiceId, bool success, string? error = null);
    void TrackPaymentImport(string paymentId, bool success, string? error = null);
    void TrackCatalogSync(int itemsProcessed, TimeSpan duration, bool success, string? error = null);
    void TrackOrderProcessing(string orderId, string status, Dictionary<string, string>? additionalProperties = null);
    void TrackInventoryUpdate(string productId, int oldQuantity, int newQuantity, string updateReason);
}
using Microsoft.ApplicationInsights;
using Microsoft.ApplicationInsights.DataContracts;
using Microsoft.Extensions.Logging;

namespace Anela.Heblo.Xcc.Telemetry;

public class TelemetryService : ITelemetryService
{
    private readonly TelemetryClient _telemetryClient;
    private readonly ILogger<TelemetryService> _logger;

    public TelemetryService(TelemetryClient telemetryClient, ILogger<TelemetryService> logger)
    {
        _telemetryClient = telemetryClient;
        _logger = logger;
    }

    public void TrackBusinessEvent(string eventName, Dictionary<string, string>? properties = null, Dictionary<string, double>? metrics = null)
    {
        var telemetryEvent = new EventTelemetry(eventName);

        if (properties != null)
        {
            foreach (var prop in properties)
            {
                telemetryEvent.Properties[prop.Key] = prop.Value;
            }
        }

        if (metrics != null)
        {
            foreach (var metric in metrics)
            {
                telemetryEvent.Metrics[metric.Key] = metric.Value;
            }
        }

        _telemetryClient.TrackEvent(telemetryEvent);
        _logger.LogInformation("Business event tracked: {EventName}", eventName);
    }

    public void TrackException(Exception exception, Dictionary<string, string>? properties = null)
    {
        var telemetryException = new ExceptionTelemetry(exception);

        if (properties != null)
        {
            foreach (var prop in properties)
            {
                telemetryException.Properties[prop.Key] = prop.Value;
            }
        }

        _telemetryClient.TrackException(telemetryException);
        _logger.LogError(exception, "Exception tracked");
    }

    public void TrackMetric(string metricName, double value, Dictionary<string, string>? properties = null)
    {
        var telemetryMetric = new MetricTelemetry(metricName, value);

        if (properties != null)
        {
            foreach (var prop in properties)
            {
                telemetryMetric.Properties[prop.Key] = prop.Value;
            }
        }

        _telemetryClient.TrackMetric(telemetryMetric);
        _logger.LogDebug("Metric tracked: {MetricName} = {Value}", metricName, value);
    }

    public void TrackDependency(string dependencyName, string commandName, DateTimeOffset startTime, TimeSpan duration, bool success)
    {
        var dependency = new DependencyTelemetry(dependencyName, commandName, startTime, duration, success);
        _telemetryClient.TrackDependency(dependency);
        _logger.LogInformation("Dependency tracked: {DependencyName} - {CommandName} - Success: {Success}",
            dependencyName, commandName, success);
    }

    // Business-specific implementations
    public void TrackInvoiceImport(string invoiceId, bool success, string? error = null)
    {
        var properties = new Dictionary<string, string>
        {
            ["InvoiceId"] = invoiceId,
            ["Success"] = success.ToString(),
            ["ImportType"] = "Invoice"
        };

        if (!string.IsNullOrEmpty(error))
        {
            properties["Error"] = error;
        }

        TrackBusinessEvent("InvoiceImport", properties, new Dictionary<string, double>
        {
            ["ImportDuration"] = 0 // Will be set by actual import process
        });

        if (!success)
        {
            _logger.LogError("Invoice import failed for {InvoiceId}: {Error}", invoiceId, error);
        }
    }

    public void TrackPaymentImport(string paymentId, bool success, string? error = null)
    {
        var properties = new Dictionary<string, string>
        {
            ["PaymentId"] = paymentId,
            ["Success"] = success.ToString(),
            ["ImportType"] = "Payment"
        };

        if (!string.IsNullOrEmpty(error))
        {
            properties["Error"] = error;
        }

        TrackBusinessEvent("PaymentImport", properties);

        if (!success)
        {
            _logger.LogError("Payment import failed for {PaymentId}: {Error}", paymentId, error);
        }
    }

    public void TrackCatalogSync(int itemsProcessed, TimeSpan duration, bool success, string? error = null)
    {
        var properties = new Dictionary<string, string>
        {
            ["Success"] = success.ToString(),
            ["SyncType"] = "Catalog"
        };

        if (!string.IsNullOrEmpty(error))
        {
            properties["Error"] = error;
        }

        var metrics = new Dictionary<string, double>
        {
            ["ItemsProcessed"] = itemsProcessed,
            ["DurationSeconds"] = duration.TotalSeconds
        };

        TrackBusinessEvent("CatalogSync", properties, metrics);
        TrackMetric("CatalogSyncDuration", duration.TotalSeconds);
        TrackMetric("CatalogItemsProcessed", itemsProcessed);

        if (!success)
        {
            _logger.LogError("Catalog sync failed after processing {ItemsProcessed} items: {Error}",
                itemsProcessed, error);
        }
    }

    public void TrackOrderProcessing(string orderId, string status, Dictionary<string, string>? additionalProperties = null)
    {
        var properties = new Dictionary<string, string>
        {
            ["OrderId"] = orderId,
            ["Status"] = status,
            ["ProcessType"] = "Order"
        };

        if (additionalProperties != null)
        {
            foreach (var prop in additionalProperties)
            {
                properties[prop.Key] = prop.Value;
            }
        }

        TrackBusinessEvent("OrderProcessing", properties);
        _logger.LogInformation("Order {OrderId} processed with status: {Status}", orderId, status);
    }

    public void TrackInventoryUpdate(string productId, int oldQuantity, int newQuantity, string updateReason)
    {
        var properties = new Dictionary<string, string>
        {
            ["ProductId"] = productId,
            ["UpdateReason"] = updateReason,
            ["UpdateType"] = "Inventory"
        };

        var metrics = new Dictionary<string, double>
        {
            ["OldQuantity"] = oldQuantity,
            ["NewQuantity"] = newQuantity,
            ["QuantityChange"] = newQuantity - oldQuantity
        };

        TrackBusinessEvent("InventoryUpdate", properties, metrics);
        _logger.LogInformation("Inventory updated for {ProductId}: {OldQuantity} -> {NewQuantity} ({Reason})",
            productId, oldQuantity, newQuantity, updateReason);
    }
}

/// <summary>
/// No-operation implementation of ITelemetryService for development environments 
/// where Application Insights is not configured
/// </summary>
public class NoOpTelemetryService : ITelemetryService
{
    private readonly ILogger<NoOpTelemetryService> _logger;

    public NoOpTelemetryService(ILogger<NoOpTelemetryService> logger)
    {
        _logger = logger;
    }

    public void TrackBusinessEvent(string eventName, Dictionary<string, string>? properties = null, Dictionary<string, double>? metrics = null)
    {
        _logger.LogDebug("NoOp: TrackBusinessEvent - {EventName}", eventName);
    }

    public void TrackException(Exception exception, Dictionary<string, string>? properties = null)
    {
        _logger.LogError(exception, "NoOp: TrackException");
    }

    public void TrackMetric(string metricName, double value, Dictionary<string, string>? properties = null)
    {
        _logger.LogDebug("NoOp: TrackMetric - {MetricName} = {Value}", metricName, value);
    }

    public void TrackDependency(string dependencyName, string commandName, DateTimeOffset startTime, TimeSpan duration, bool success)
    {
        _logger.LogDebug("NoOp: TrackDependency - {DependencyName} - {CommandName} - Success: {Success}",
            dependencyName, commandName, success);
    }

    public void TrackInvoiceImport(string invoiceId, bool success, string? error = null)
    {
        _logger.LogDebug("NoOp: TrackInvoiceImport - {InvoiceId}, Success: {Success}", invoiceId, success);
        if (!success && !string.IsNullOrEmpty(error))
        {
            _logger.LogError("Invoice import failed for {InvoiceId}: {Error}", invoiceId, error);
        }
    }

    public void TrackPaymentImport(string paymentId, bool success, string? error = null)
    {
        _logger.LogDebug("NoOp: TrackPaymentImport - {PaymentId}, Success: {Success}", paymentId, success);
        if (!success && !string.IsNullOrEmpty(error))
        {
            _logger.LogError("Payment import failed for {PaymentId}: {Error}", paymentId, error);
        }
    }

    public void TrackCatalogSync(int itemsProcessed, TimeSpan duration, bool success, string? error = null)
    {
        _logger.LogDebug("NoOp: TrackCatalogSync - Items: {ItemsProcessed}, Duration: {Duration}, Success: {Success}",
            itemsProcessed, duration, success);
        if (!success && !string.IsNullOrEmpty(error))
        {
            _logger.LogError("Catalog sync failed after processing {ItemsProcessed} items: {Error}",
                itemsProcessed, error);
        }
    }

    public void TrackOrderProcessing(string orderId, string status, Dictionary<string, string>? additionalProperties = null)
    {
        _logger.LogDebug("NoOp: TrackOrderProcessing - {OrderId}, Status: {Status}", orderId, status);
    }

    public void TrackInventoryUpdate(string productId, int oldQuantity, int newQuantity, string updateReason)
    {
        _logger.LogDebug("NoOp: TrackInventoryUpdate - {ProductId}: {OldQuantity} -> {NewQuantity} ({Reason})",
            productId, oldQuantity, newQuantity, updateReason);
    }
}
using Anela.Heblo.Xcc.Audit;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;

namespace Anela.Heblo.Xcc;

/// <summary>
/// Cross-cutting concerns module registration
/// </summary>
public static class XccModule
{
    public static IServiceCollection AddXccServices(this IServiceCollection services)
    {
        // Register audit services
        services.TryAddSingleton<IDataLoadAuditService, InMemoryDataLoadAuditService>();

        return services;
    }
}
namespace Anela.Heblo.Xcc.Domain;

public interface IEntity<T>
{
    /// <summary>
    /// Gets or sets the unique identifier for the entity
    /// </summary>
    T Id { get; }
}
namespace Anela.Heblo.Xcc.Domain;

public class Entity<T> : IEntity<T>
{
    public T Id { get; set; }
}
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Anela.Heblo.Domain")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+6cd183ef4ac33ad09cbb7ecd6a8b9c35891c45cb")]
[assembly: System.Reflection.AssemblyProductAttribute("Anela.Heblo.Domain")]
[assembly: System.Reflection.AssemblyTitleAttribute("Anela.Heblo.Domain")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

namespace Anela.Heblo.Domain.Features.Configuration;

/// <summary>
/// Configuration constants and keys
/// </summary>
public static class ConfigurationConstants
{
    // Environment variable keys
    public const string APP_VERSION = "APP_VERSION";
    public const string ASPNETCORE_ENVIRONMENT = "ASPNETCORE_ENVIRONMENT";

    // Configuration keys
    public const string USE_MOCK_AUTH = "UseMockAuth";
    public const string BYPASS_JWT_VALIDATION = "BypassJwtValidation";

    // Default values
    public const string DEFAULT_VERSION = "1.0.0";
    public const string DEFAULT_ENVIRONMENT = "Production";

    // Application Insights configuration keys
    public const string APPLICATION_INSIGHTS_CONNECTION_STRING = "ApplicationInsights:ConnectionString";
    public const string APPINSIGHTS_INSTRUMENTATION_KEY = "APPINSIGHTS_INSTRUMENTATIONKEY";
    public const string APPLICATIONINSIGHTS_CONNECTION_STRING = "APPLICATIONINSIGHTS_CONNECTION_STRING";

    // Database configuration keys
    public const string DEFAULT_CONNECTION = "DefaultConnection";

    // CORS configuration keys
    public const string CORS_ALLOWED_ORIGINS = "Cors:AllowedOrigins";

    // Policy names
    public const string CORS_POLICY_NAME = "AllowFrontend";
    public const string MOCK_AUTH_SCHEME = "Mock";

    // Health check tags
    public const string DB_TAG = "db";
    public const string POSTGRESQL_TAG = "postgresql";

    // Health check names
    public const string DATABASE_HEALTH_CHECK = "database";
}
namespace Anela.Heblo.Domain.Features.Configuration;

/// <summary>
/// Domain model representing application configuration
/// </summary>
public class ApplicationConfiguration
{
    public string Version { get; private set; }
    public string Environment { get; private set; }
    public bool UseMockAuth { get; private set; }
    public DateTime Timestamp { get; private set; }

    public ApplicationConfiguration(string version, string environment, bool useMockAuth)
    {
        Version = version ?? throw new ArgumentNullException(nameof(version));
        Environment = environment ?? throw new ArgumentNullException(nameof(environment));
        UseMockAuth = useMockAuth;
        Timestamp = DateTime.UtcNow;
    }

    /// <summary>
    /// Creates configuration with fallback values
    /// </summary>
    public static ApplicationConfiguration CreateWithDefaults(string? version, string? environment, bool useMockAuth)
    {
        return new ApplicationConfiguration(
            version ?? "1.0.0",
            environment ?? "Production",
            useMockAuth
        );
    }
}
namespace Anela.Heblo.Domain.Features.Invoices;

public interface IIssuedInvoiceSource
{
    Task<List<IssuedInvoiceDetailBatch>> GetAllAsync(IssuedInvoiceSourceQuery query);

    Task CommitAsync(IssuedInvoiceDetailBatch batch, string? commitMessage = default);

    Task FailAsync(IssuedInvoiceDetailBatch batch, string? errorMessage = default);
}
﻿namespace Anela.Heblo.Domain.Features.Invoices
{
    public class InvoiceCustomer
    {
        public object Guid { get; set; }

        public string Phone { get; set; }

        public string Email { get; set; }

        public string CompanyId { get; set; }

        public string VatId { get; set; }

        public object ClientCode { get; set; }

        public string? Company { get; set; }
        public string Name { get; set; }
        public string DisplayName => string.IsNullOrEmpty(Company) ? Name : $"{Company} - {Name}";

        //public string BankAccount { get; set; }

        //public string Iban { get; set; }

        //public string Bic { get; set; }

        //public string TaxMode { get; set; }
        //public bool? VatPayer { get; set; }
    }
}
﻿namespace Anela.Heblo.Domain.Features.Invoices
{
    public enum ShippingMethod
    {
        PickUp,
        PPL,
        PPLParcelShop,
        ZasilkovnaDoRuky,
        Zasilkovna,
        GLS,
    }
}
namespace Anela.Heblo.Domain.Features.Invoices;

public enum CurrencyCode
{
    CZK,
    EUR
}
﻿namespace Anela.Heblo.Domain.Features.Invoices
{
    public class InvoiceAddress
    {
        public string Company { get; set; }

        public string FullName { get; set; }

        public string Street { get; set; }

        public string HouseNumber { get; set; }

        public string City { get; set; }

        public string District { get; set; }


        public string Zip { get; set; }

        public string CountryCode { get; set; }
    }
}
﻿namespace Anela.Heblo.Domain.Features.Invoices
{
    public class IssuedInvoiceDetailItem
    {
        public string Code { get; set; }

        public string Name { get; set; }

        public string VariantName { get; set; }

        public string Amount { get; set; }

        public Guid? ProductGuid { get; set; }

        public string AmountUnit { get; set; }

        public InvoicePrice ItemPrice { get; set; }

        public InvoicePrice BuyPrice { get; set; }
    }
}
﻿namespace Anela.Heblo.Domain.Features.Invoices
{
    public class InvoicePrice
    {
        public decimal Vat { get; set; }

        public string CurrencyCode { get; set; } = "CZK";

        public decimal WithVat { get; set; }

        public decimal WithoutVat { get; set; }

        public decimal? ExchangeRate { get; set; }

        public string? VatRate { get; set; }

    }
}
﻿namespace Anela.Heblo.Domain.Features.Invoices
{
    public enum BillingMethod
    {
        BankTransfer,
        Cash,
        CoD,
        Comgate,
        CreditCard
    }
}
namespace Anela.Heblo.Domain.Features.Invoices;

public class IssuedInvoiceDetail
{
    public string Code { get; set; } = string.Empty;

    public string? OrderCode { get; set; }

    public DateTime CreationTime { get; set; }

    public DateTime ChangeTime { get; set; }

    public DateTime DueDate { get; set; }

    public DateTime TaxDate { get; set; }

    public bool? AddressesEqual { get; set; }

    public long? VarSymbol { get; set; }

    public long? ConstSymbol { get; set; }

    public long? SpecSymbol { get; set; }

    public BillingMethod BillingMethod { get; set; }

    public ShippingMethod ShippingMethod { get; set; }

    public bool? VatPayer { get; set; }

    public List<IssuedInvoiceDetailItem> Items { get; set; } = new();

    public InvoiceAddress BillingAddress { get; set; } = new();

    public InvoiceAddress DeliveryAddress { get; set; } = new();

    public InvoicePrice Price { get; set; } = new();

    public InvoiceCustomer Customer { get; set; } = new();
}
namespace Anela.Heblo.Domain.Features.Invoices;

public class IssuedInvoiceSourceQuery
{
    public string RequestId { get; set; } = "undefined";
    public string? InvoiceId { get; set; }

    public DateTime? DateFrom { get; set; }
    public DateTime? DateTo { get; set; }
    public string Currency { get; set; } = "CZK";

    public bool QueryByInvoice => InvoiceId != null;
    public bool QueryByDate => DateFrom != null && DateTo != null;

    public string DateFromString => DateFrom?.ToString("d.M.yyyy") ?? "";
    public string DateToString => DateTo?.ToString("d.M.yyyy") ?? "";
}



namespace Anela.Heblo.Domain.Features.Invoices;

public class IssuedInvoiceDetailBatch
{
    public List<IssuedInvoiceDetail> Invoices { get; set; } = new();
    public string BatchId { get; set; } = string.Empty;
}
namespace Anela.Heblo.Domain.Features.Bank;

public class BankAccountSettings
{
    public static string ConfigurationKey { get; set; } = "BankAccounts";

    public List<BankAccountConfiguration> Accounts { get; set; }
}
namespace Anela.Heblo.Domain.Features.Bank;

public class BankStatementData
{
    public string StatementId { get; set; }
    public int ItemCount { get; set; }
    public string Data { get; set; }
}
namespace Anela.Heblo.Domain.Features.Bank;

public class BankAccountConfiguration
{
    public string Name { get; set; }
    public string AccountNumber { get; set; }
    public int FlexiBeeId { get; set; }
}
namespace Anela.Heblo.Domain.Features.Bank;

public interface IBankClient
{
    Task<BankStatementData> GetStatementAsync(string statementId);
    Task<IList<BankStatementHeader>> GetStatementsAsync(string accountNumber, DateTime requestStatementDate);
}
namespace Anela.Heblo.Domain.Features.Bank;

public class BankStatementHeader
{
    public string StatementId { get; set; }
    public DateTime Date { get; set; }
    public string Account { get; set; }
}
namespace Anela.Heblo.Domain.Features.Catalog;

public record CatalogProperties
{
    public int OptimalStockDaysSetup { get; set; } = 0;
    public decimal StockMinSetup { get; set; } = 0;
    public int BatchSize { get; set; } = 0;
    public int[] SeasonMonths { get; set; } = Array.Empty<int>();
}
namespace Anela.Heblo.Domain.Features.Catalog.Sales;

public class SaleHistorySummary
{
    public Dictionary<string, MonthlySalesSummary> MonthlyData { get; set; } = new();
    public DateTime LastUpdated { get; set; }
}

public class MonthlySalesSummary
{
    public int Year { get; set; }
    public int Month { get; set; }
    public decimal TotalB2B { get; set; }
    public decimal TotalB2C { get; set; }
    public double AmountB2B { get; set; }
    public double AmountB2C { get; set; }
    public int TransactionCount { get; set; }

    public string MonthKey => $"{Year:D4}-{Month:D2}";
    public decimal TotalRevenue => TotalB2B + TotalB2C;
    public double TotalAmount => AmountB2B + AmountB2C;
}

namespace Anela.Heblo.Domain.Features.Catalog.Sales;

public record CatalogSaleRecord
{
    public DateTime Date { get; set; }

    public string ProductCode { get; set; }

    public string ProductName { get; set; }

    public double AmountTotal { get; set; }
    public double AmountB2B { get; set; }
    public double AmountB2C { get; set; }

    public decimal SumTotal { get; set; }
    public decimal SumB2B { get; set; }
    public decimal SumB2C { get; set; }
}
namespace Anela.Heblo.Domain.Features.Catalog.Sales;

public interface ICatalogSalesClient
{
    Task<IList<CatalogSaleRecord>> GetAsync(DateTime dateFrom, DateTime dateTo, int limit = 0, CancellationToken cancellationToken = default);
}
namespace Anela.Heblo.Domain.Features.Catalog.PurchaseHistory;

public class PurchaseHistorySummary
{
    public Dictionary<string, MonthlyPurchaseSummary> MonthlyData { get; set; } = new();
    public DateTime LastUpdated { get; set; }
}
namespace Anela.Heblo.Domain.Features.Catalog.PurchaseHistory;

public class MonthlyPurchaseSummary
{
    public int Year { get; set; }
    public int Month { get; set; }
    public double TotalAmount { get; set; }
    public decimal TotalCost { get; set; }
    public decimal AveragePricePerPiece { get; set; }
    public int PurchaseCount { get; set; }
    public Dictionary<string, SupplierPurchaseSummary> SupplierBreakdown { get; set; } = new();

    public string MonthKey => $"{Year:D4}-{Month:D2}";
}
namespace Anela.Heblo.Domain.Features.Catalog.PurchaseHistory;

public class CatalogPurchaseRecord
{
    public int? SupplierId { get; set; }
    public string SupplierName { get; set; }
    public DateTime Date { get; set; }
    public double Amount { get; set; }
    public decimal PricePerPiece { get; set; }
    public decimal PriceTotal { get; set; }
    public string ProductCode { get; set; }
    public string DocumentNumber { get; set; }
}
namespace Anela.Heblo.Domain.Features.Catalog.PurchaseHistory;

public class SupplierPurchaseSummary
{
    public string SupplierName { get; set; }
    public double Amount { get; set; }
    public decimal Cost { get; set; }
    public int PurchaseCount { get; set; }
}
namespace Anela.Heblo.Domain.Features.Catalog.PurchaseHistory;

public interface IPurchaseHistoryClient
{
    Task<IReadOnlyList<CatalogPurchaseRecord>> GetHistoryAsync(string? productCode, DateTime dateFrom, DateTime dateTo, int limit = 0, CancellationToken cancellationToken = default);
}
using Anela.Heblo.Xcc.Persistance;

namespace Anela.Heblo.Domain.Features.Catalog;

public interface ICatalogRepository : IReadOnlyRepository<CatalogAggregate, string>
{
    Task RefreshTransportData(CancellationToken ct);
    Task RefreshReserveData(CancellationToken ct);
    Task RefreshSalesData(CancellationToken ct);
    Task RefreshAttributesData(CancellationToken ct);
    Task RefreshErpStockData(CancellationToken ct);
    Task RefreshEshopStockData(CancellationToken ct);
    Task RefreshPurchaseHistoryData(CancellationToken ct);
    Task RefreshConsumedHistoryData(CancellationToken ct);
    Task RefreshStockTakingData(CancellationToken ct);
    Task RefreshLotsData(CancellationToken ct);
    Task RefreshEshopPricesData(CancellationToken ct);
    Task RefreshErpPricesData(CancellationToken ct);
}
using Anela.Heblo.Domain.Features.Catalog.ConsumedMaterials;
using Anela.Heblo.Domain.Features.Catalog.Price;
using Anela.Heblo.Domain.Features.Catalog.PurchaseHistory;
using Anela.Heblo.Domain.Features.Catalog.Sales;
using Anela.Heblo.Domain.Features.Catalog.Stock;
using Anela.Heblo.Domain.Features.Purchase;
using Anela.Heblo.Xcc;
using Anela.Heblo.Xcc.Domain;

namespace Anela.Heblo.Domain.Features.Catalog;

public class CatalogAggregate : Entity<string>
{
    public string ProductCode { get => Id; set => Id = value; }
    public string ProductName { get; set; }

    public int ErpId { get; set; }

    public ProductType Type { get; set; } = Catalog.ProductType.UNDEFINED;

    public StockData Stock { get; set; } = new();
    public CatalogProperties Properties { get; set; } = new();

    public ProductPriceEshop? EshopPrice { get; set; }
    public ProductPriceErp? ErpPrice { get; set; }

    public List<StockTakingRecord> StockTakingHistory { get; set; } = new();

    public string Location { get; set; } = string.Empty;

    private IList<CatalogSaleRecord> _salesHistory = new List<CatalogSaleRecord>();
    private IList<ConsumedMaterialRecord> _consumedHistory = new List<ConsumedMaterialRecord>();
    private IReadOnlyList<CatalogPurchaseRecord> _purchaseHistory = new List<CatalogPurchaseRecord>();

    public IList<CatalogSaleRecord> SalesHistory
    {
        get => _salesHistory;
        set
        {
            _salesHistory = value;
            UpdateSaleHistorySummary();
        }
    }

    public IList<ConsumedMaterialRecord> ConsumedHistory
    {
        get => _consumedHistory;
        set
        {
            _consumedHistory = value;
            UpdateConsumedHistorySummary();
        }
    }

    public IReadOnlyList<CatalogPurchaseRecord> PurchaseHistory
    {
        get => _purchaseHistory;
        set
        {
            _purchaseHistory = value;
            UpdatePurchaseHistorySummary();
        }
    }

    public SaleHistorySummary SaleHistorySummary { get; set; } = new();
    public ConsumedHistorySummary ConsumedHistorySummary { get; set; } = new();
    public PurchaseHistorySummary PurchaseHistorySummary { get; set; } = new();

    public IReadOnlyList<Supplier> Suppliers { get; set; } = new List<Supplier>();

    public string MinimalOrderQuantity { get; set; } = "";
    public double MinimalManufactureQuantity { get; set; } = 0;



    // Readonly PROPS
    public string? PrimarySupplier => Suppliers.FirstOrDefault(f => f.IsPrimary)?.Name;
    public bool IsSameFamily(CatalogAggregate product) => product.ProductFamily == this.ProductFamily;
    public bool IsSameType(CatalogAggregate product) => product.ProductType == this.ProductType;
    public string? ProductFamily => ProductCode?.Left(Math.Min(6, ProductCode.Length));
    public string? ProductType => ProductCode?.Left(Math.Min(3, ProductCode.Length));
    public string? SizeCode => ProductCode?.Substring(Math.Min(6, ProductCode.Length));


    public bool IsInSeason(DateTime referenceTime) => Properties.SeasonMonths.Length > 0 && !Properties.SeasonMonths.Contains(referenceTime.Month);

    public bool IsUnderStocked => Stock.Available < Properties.StockMinSetup && IsMinStockConfigured;
    public bool IsMinStockConfigured => Properties.StockMinSetup > 0;
    public bool IsOptimalStockConfigured => Properties.OptimalStockDaysSetup > 0;
    public DateTime? LastStockTaking => StockTakingHistory.LastOrDefault()?.Date;
    public bool HasExpiration { get; set; }
    public bool HasLots { get; set; }
    public double Volume { get; set; }
    public double Weight { get; set; }

    // Price convenience properties
    public decimal? CurrentSellingPrice => EshopPrice?.PriceWithVat ?? ErpPrice?.PriceWithoutVat;
    public decimal? CurrentPurchasePrice => EshopPrice?.PurchasePrice ?? ErpPrice?.PurchasePrice;
    public decimal? SellingPriceWithVat => EshopPrice?.PriceWithVat ?? ErpPrice?.PriceWithVat;
    public decimal? PurchasePriceWithVat => ErpPrice?.PurchasePriceWithVat;

    public double GetConsumed(DateTime dateFrom, DateTime dateTo) => ConsumedHistory
        .Where(w => w.Date >= dateFrom && w.Date <= dateTo)
        .Sum(s => s.Amount);

    public double GetTotalSold(DateTime dateFrom, DateTime dateTo) => SalesHistory
        .Where(w => w.Date >= dateFrom && w.Date <= dateTo)
        .Sum(s => s.AmountB2B + s.AmountB2C);

    public void UpdateSaleHistorySummary()
    {
        var monthlyData = new Dictionary<string, MonthlySalesSummary>();

        var groupedSales = SalesHistory
            .GroupBy(s => new { s.Date.Year, s.Date.Month })
            .ToList();

        foreach (var group in groupedSales)
        {
            var monthKey = $"{group.Key.Year:D4}-{group.Key.Month:D2}";
            monthlyData[monthKey] = new MonthlySalesSummary
            {
                Year = group.Key.Year,
                Month = group.Key.Month,
                TotalB2B = group.Sum(s => s.SumB2B),
                TotalB2C = group.Sum(s => s.SumB2C),
                AmountB2B = group.Sum(s => s.AmountB2B),
                AmountB2C = group.Sum(s => s.AmountB2C),
                TransactionCount = group.Count()
            };
        }

        SaleHistorySummary.MonthlyData = monthlyData;
        SaleHistorySummary.LastUpdated = DateTime.UtcNow;
    }

    public void UpdatePurchaseHistorySummary()
    {
        var monthlyData = new Dictionary<string, MonthlyPurchaseSummary>();

        var groupedPurchases = PurchaseHistory
            .GroupBy(p => new { p.Date.Year, p.Date.Month })
            .ToList();

        foreach (var group in groupedPurchases)
        {
            var monthKey = $"{group.Key.Year:D4}-{group.Key.Month:D2}";

            var supplierBreakdown = group
                .GroupBy(p => p.SupplierName ?? "Unknown")
                .ToDictionary(
                    sg => sg.Key,
                    sg => new SupplierPurchaseSummary
                    {
                        SupplierName = sg.Key,
                        Amount = sg.Sum(p => p.Amount),
                        Cost = sg.Sum(p => p.PriceTotal),
                        PurchaseCount = sg.Count()
                    });

            monthlyData[monthKey] = new MonthlyPurchaseSummary
            {
                Year = group.Key.Year,
                Month = group.Key.Month,
                TotalAmount = group.Sum(p => p.Amount),
                TotalCost = group.Sum(p => p.PriceTotal),
                AveragePricePerPiece = group.Count() > 0 ? group.Average(p => p.PricePerPiece) : 0,
                PurchaseCount = group.Count(),
                SupplierBreakdown = supplierBreakdown
            };
        }

        PurchaseHistorySummary.MonthlyData = monthlyData;
        PurchaseHistorySummary.LastUpdated = DateTime.UtcNow;
    }

    public void UpdateConsumedHistorySummary()
    {
        var monthlyData = new Dictionary<string, MonthlyConsumedSummary>();

        var groupedConsumed = ConsumedHistory
            .GroupBy(c => new { c.Date.Year, c.Date.Month })
            .ToList();

        foreach (var group in groupedConsumed)
        {
            var monthKey = $"{group.Key.Year:D4}-{group.Key.Month:D2}";
            monthlyData[monthKey] = new MonthlyConsumedSummary
            {
                Year = group.Key.Year,
                Month = group.Key.Month,
                TotalAmount = group.Sum(c => c.Amount),
                ConsumptionCount = group.Count()
            };
        }

        ConsumedHistorySummary.MonthlyData = monthlyData;
        ConsumedHistorySummary.LastUpdated = DateTime.UtcNow;
    }

    public void UpdateAllSummaries()
    {
        UpdateSaleHistorySummary();
        UpdatePurchaseHistorySummary();
        UpdateConsumedHistorySummary();
    }

}

namespace Anela.Heblo.Domain.Features.Catalog.Lots
{
    public interface ILotsClient
    {
        Task<IReadOnlyList<CatalogLot>> GetAsync(string? productCode = null, int limit = 0, int skip = 0, CancellationToken cancellationToken = default);
    }
}

namespace Anela.Heblo.Domain.Features.Catalog.Lots;

public class CatalogLot
{
    public string ProductCode { get; set; }
    public decimal Amount { get; set; }
    public DateTime? Expiration { get; set; }
    public string? Lot { get; set; }
}
namespace Anela.Heblo.Domain.Features.Catalog.Attributes;

public class CatalogAttributes
{
    public int ProductId { get; set; }

    public string ProductCode { get; set; }

    public int OptimalStockDays { get; set; } = 0;
    public decimal StockMin { get; set; } = 0;
    public int BatchSize { get; set; } = 0;

    public int MinimalManufactureQuantity { get; set; } = 0;
    public ProductType ProductType { get; set; }
    public int[] SeasonMonthsArray { get; set; } = Array.Empty<int>();
}
namespace Anela.Heblo.Domain.Features.Catalog.Attributes;

public interface ICatalogAttributesClient
{
    Task<IList<CatalogAttributes>> GetAttributesAsync(int limit = 0, CancellationToken cancellationToken = default);
}
namespace Anela.Heblo.Domain.Features.Catalog.Price;

public interface IProductPriceErpClient
{
    Task<IEnumerable<ProductPriceErp>> GetAllAsync(bool forceReload, CancellationToken cancellationToken);
}
namespace Anela.Heblo.Domain.Features.Catalog.Price;

public class ProductPriceEshop
{
    public string ProductCode { get; set; } = string.Empty;
    public decimal? PriceWithVat { get; set; }
    public decimal? PurchasePrice { get; set; }
}
namespace Anela.Heblo.Domain.Features.Catalog.Price;

public class ProductPriceErp
{
    public string ProductCode { get; set; } = string.Empty;
    public decimal PriceWithVat { get; set; }
    public decimal PurchasePriceWithVat { get; set; }
    public decimal PriceWithoutVat { get; set; }
    public decimal PurchasePrice { get; set; }
}
namespace Anela.Heblo.Domain.Features.Catalog.Price;

public class SetProductPricesResultDto
{
    public string FilePath { get; set; }
    public byte[] Data { get; set; }
}
namespace Anela.Heblo.Domain.Features.Catalog.Price;

public interface IProductPriceEshopClient
{
    Task<IEnumerable<ProductPriceEshop>> GetAllAsync(CancellationToken cancellationToken);
    Task<SetProductPricesResultDto> SetAllAsync(IEnumerable<ProductPriceEshop> eshopData, CancellationToken cancellationToken);
}
namespace Anela.Heblo.Domain.Features.Catalog.ConsumedMaterials;

public interface IConsumedMaterialsClient
{
    Task<IReadOnlyList<ConsumedMaterialRecord>> GetConsumedAsync(DateTime dateFrom, DateTime dateTo, int limit = 0, CancellationToken cancellationToken = default);
}
namespace Anela.Heblo.Domain.Features.Catalog.ConsumedMaterials;

public class ConsumedMaterialRecord
{
    public string ProductCode { get; set; }
    public string ProductName { get; set; }
    public double Amount { get; set; }
    public DateTime Date { get; set; }
}
namespace Anela.Heblo.Domain.Features.Catalog.ConsumedMaterials;

public class ConsumedHistorySummary
{
    public Dictionary<string, MonthlyConsumedSummary> MonthlyData { get; set; } = new();
    public DateTime LastUpdated { get; set; }
}

public class MonthlyConsumedSummary
{
    public int Year { get; set; }
    public int Month { get; set; }
    public double TotalAmount { get; set; }
    public int ConsumptionCount { get; set; }

    public string MonthKey => $"{Year:D4}-{Month:D2}";
    public double AverageConsumption => ConsumptionCount > 0 ? TotalAmount / ConsumptionCount : 0;
}
namespace Anela.Heblo.Domain.Features.Catalog.Stock;

public class StockUpRecord
{
}
using Anela.Heblo.Xcc.Persistance;

namespace Anela.Heblo.Domain.Features.Catalog.Stock;

public class EmptyStockTakingRepository : EmptyRepository<StockTakingRecord, int>, IStockTakingRepository
{
}
namespace Anela.Heblo.Domain.Features.Catalog.Stock;


public class EshopStock
{
    public string Code { get; set; }
    public string PairCode { get; set; }
    public string Name { get; set; }
    public decimal Stock { get; set; }
    public string NameSuffix { get; set; }
    public string Location { get; set; }
}
using Anela.Heblo.Xcc.Persistance;

namespace Anela.Heblo.Domain.Features.Catalog.Stock;

public interface IStockTakingRepository : IRepository<StockTakingRecord, int>
{

}
namespace Anela.Heblo.Domain.Features.Catalog.Stock;

public interface IErpStockDomainService
{
    Task<StockTakingRecord> SubmitStockTakingAsync(ErpStockTakingRequest order);
}
namespace Anela.Heblo.Domain.Features.Catalog.Stock;

public class EshopStockTakingRequest
{
    public string ProductCode { get; set; }
    public decimal TargetAmount { get; set; }
    public bool SoftStockTaking { get; set; }
}
namespace Anela.Heblo.Domain.Features.Catalog.Stock;

public interface IEshopStockClient
{
    Task<List<EshopStock>> ListAsync(CancellationToken cancellationToken);
}
namespace Anela.Heblo.Domain.Features.Catalog.Stock;

public enum StockTakingType
{
    Eshop,
    Erp
}
namespace Anela.Heblo.Domain.Features.Catalog.Stock;

public enum StockSource
{
    Erp,
    Eshop
}
namespace Anela.Heblo.Domain.Features.Catalog.Stock;

public class ErpStockTakingLot
{
    public string? LotCode { get; set; }
    public DateTime? Expiration { get; set; }
    public decimal Amount { get; set; }
    public bool SoftStockTaking { get; set; } = true; // Default to true
}
namespace Anela.Heblo.Domain.Features.Catalog.Stock;

public class ErpStock
{
    public string ProductCode { get; set; }
    public string ProductName { get; set; }
    public decimal Stock { get; set; }
    public string MOQ { get; set; }
    public int? ProductTypeId { get; set; }
    public int ProductId { get; set; }
    public bool HasExpiration { get; set; }
    public bool HasLots { get; set; }
    public double Volume { get; set; }
    public double Weight { get; set; }
}
namespace Anela.Heblo.Domain.Features.Catalog.Stock;

public interface IEshopStockDomainService
{
    Task StockUpAsync(StockUpRequest stockUpOrder);

    Task<StockTakingRecord> SubmitStockTakingAsync(EshopStockTakingRequest order);
}
namespace Anela.Heblo.Domain.Features.Catalog.Stock;

public class ErpStockTakingRequest
{
    public string ProductCode { get; set; }
    public bool SoftStockTaking => StockTakingItems.All(s => s.SoftStockTaking);
    public List<ErpStockTakingLot> StockTakingItems { get; set; } = new();
    public bool RemoveMissingLots { get; set; } = false;
    public bool DryRun { get; set; } = true;
}
namespace Anela.Heblo.Domain.Features.Catalog.Stock;

public class StockUpRequest
{
    public string StockUpId { get; set; }
    public string Product { get; set; }
    public double Amount { get; set; }
}
using Anela.Heblo.Domain.Features.Catalog.Lots;

namespace Anela.Heblo.Domain.Features.Catalog.Stock;

public record StockData
{
    public decimal Eshop { get; set; }
    public decimal Erp { get; set; }
    public decimal Transport { get; set; }
    public decimal Reserve { get; set; }

    public StockSource PrimaryStockSource { get; set; } = StockSource.Erp;

    public decimal Available => (PrimaryStockSource == StockSource.Erp ? Erp : Eshop) + Transport;
    public List<CatalogLot> Lots { get; set; } = new();

}
namespace Anela.Heblo.Domain.Features.Catalog.Stock;

public interface IErpStockClient
{
    Task<IReadOnlyList<ErpStock>> ListAsync(CancellationToken cancellationToken);
}
using Anela.Heblo.Xcc.Domain;

namespace Anela.Heblo.Domain.Features.Catalog.Stock;

public class StockTakingRecord : IEntity<int>
{
    public int Id { get; set; }

    public StockTakingType Type { get; set; }
    public string Code { get; set; }
    public double AmountNew { get; set; }
    public double AmountOld { get; set; }
    public DateTime Date { get; set; }
    public string? User { get; set; }
    public string? Error { get; set; }
}
namespace Anela.Heblo.Domain.Features.Catalog;

public enum ProductType
{
    Product = 8,
    Goods = 1,
    Material = 3,
    SemiProduct = 7,

    UNDEFINED = 0,
}
namespace Anela.Heblo.Domain.Features.CashRegister;

public class CashRegistryRequest
{
    public int Month { get; set; }
    public int Year { get; set; }
    public int[] RegistersId { get; set; }
}
namespace Anela.Heblo.Domain.Features.CashRegister;

public class CashRegister
{
    public int Id { get; set; }
}
namespace Anela.Heblo.Domain.Features.CashRegister;

public interface ICashRegisterOrdersSource
{
    Task<List<CashRegisterOrder>> GetAllAsync(CashRegistryRequest query);
}
using Anela.Heblo.Domain.Features.Invoices;

namespace Anela.Heblo.Domain.Features.CashRegister;

public class CashRegisterOrder
{
    public int CashRegisterId { get; set; }
    public string User { get; set; }
    public DateTime Date { get; set; }
    public decimal Amount { get; set; }
    public BillingMethod TransactionType { get; set; }
    public string OrderNo { get; set; }
}
namespace Anela.Heblo.Domain.Features.CashRegister;

public class CashRegisterStatistics
{
    public List<CashRegisterOrder> Orders { get; set; } = new();
}
namespace Anela.Heblo.Domain.Features.Users;

public record CurrentUser(
    string? Id,
    string? Name,
    string? Email,
    bool IsAuthenticated
);
namespace Anela.Heblo.Domain.Features.Users;

public static class CurrentUserExtensions
{
    /// <summary>
    /// Gets the display name for the user, fallback to "System" if not authenticated
    /// </summary>
    public static string GetDisplayName(this CurrentUser user)
    {
        return user.IsAuthenticated ? user.Name ?? "Unknown User" : "System";
    }

    /// <summary>
    /// Gets the user identifier, fallback to "system" if not available
    /// </summary>
    public static string GetIdentifier(this CurrentUser user)
    {
        return user.Id ?? user.Email ?? "system";
    }
}
namespace Anela.Heblo.Domain.Features.Users;

public interface ICurrentUserService
{
    CurrentUser GetCurrentUser();
}
namespace Anela.Heblo.Domain.Features.Purchase;

public enum PurchaseOrderStatus
{
    Draft,
    InTransit,
    Completed
}
namespace Anela.Heblo.Domain.Features.Purchase;

public static class PurchaseOrderConstants
{
    public const int OrderNumberMaxLength = 50;
    public const int NotesMaxLength = 2000;
    public const int ActionMaxLength = 200;
    public const int ValueMaxLength = 500;
    public const int UserNameMaxLength = 100;

    public static readonly string[] ValidStatusTransitions = new[]
    {
        "Draft -> InTransit",
        "InTransit -> Completed"
    };

    public static class ValidationMessages
    {
        public const string OrderNumberRequired = "Order number is required";
        public const string OrderNumberTooLong = "Order number cannot exceed 50 characters";
        public const string SupplierIdRequired = "Supplier ID is required";
        public const string OrderDateRequired = "Order date is required";
        public const string CreatedByRequired = "Created by is required";
        public const string QuantityMustBePositive = "Quantity must be greater than zero";
        public const string UnitPriceCannotBeNegative = "Unit price cannot be negative";
        public const string MaterialIdRequired = "Material ID is required";
        public const string InvalidStatusTransition = "Invalid status transition";
        public const string CannotModifyNonDraftOrder = "Cannot modify orders that are not in draft status";
        public const string CannotModifyCompletedOrder = "Cannot modify completed orders";
    }
}
using Anela.Heblo.Xcc.Domain;

namespace Anela.Heblo.Domain.Features.Purchase;

public class PurchaseOrderHistory : IEntity<Guid>
{
    public Guid Id { get; private set; }
    public Guid PurchaseOrderId { get; private set; }
    public string Action { get; private set; } = null!;
    public string? OldValue { get; private set; }
    public string? NewValue { get; private set; }
    public string ChangedBy { get; private set; } = null!;
    public DateTime ChangedAt { get; private set; }

    protected PurchaseOrderHistory()
    {
    }

    public PurchaseOrderHistory(Guid purchaseOrderId, string action, string? oldValue, string? newValue, string changedBy)
    {
        Id = Guid.NewGuid();
        PurchaseOrderId = purchaseOrderId;
        Action = action ?? throw new ArgumentNullException(nameof(action));
        OldValue = oldValue;
        NewValue = newValue;
        ChangedBy = changedBy ?? throw new ArgumentNullException(nameof(changedBy));
        ChangedAt = DateTime.UtcNow;
    }
}
namespace Anela.Heblo.Domain.Features.Purchase;

public class Supplier
{
    public bool IsPrimary { get; set; }
    public string Name { get; set; }
}
namespace Anela.Heblo.Domain.Features.Purchase;

public interface IPurchaseOrderNumberGenerator
{
    Task<string> GenerateOrderNumberAsync(DateTime orderDate, CancellationToken cancellationToken = default);
}

public class PurchaseOrderNumberGenerator : IPurchaseOrderNumberGenerator
{
    public Task<string> GenerateOrderNumberAsync(DateTime orderDate, CancellationToken cancellationToken = default)
    {
        var year = orderDate.Year;
        var month = orderDate.Month;
        var timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
        
        var orderNumber = $"PO{year:D4}{month:D2}-{timestamp}";
        
        return Task.FromResult(orderNumber);
    }
}
using Anela.Heblo.Xcc.Persistance;

namespace Anela.Heblo.Domain.Features.Purchase;

public interface IPurchaseOrderRepository : IRepository<PurchaseOrder, Guid>
{
    Task<(List<PurchaseOrder> Orders, int TotalCount)> GetPaginatedAsync(
        string? searchTerm,
        string? status,
        DateTime? fromDate,
        DateTime? toDate,
        Guid? supplierId,
        int pageNumber,
        int pageSize,
        string sortBy,
        bool sortDescending,
        CancellationToken cancellationToken = default);

    Task<PurchaseOrder?> GetByIdWithDetailsAsync(Guid id, CancellationToken cancellationToken = default);
    
    Task<bool> OrderNumberExistsAsync(string orderNumber, CancellationToken cancellationToken = default);
}
using Anela.Heblo.Xcc.Domain;

namespace Anela.Heblo.Domain.Features.Purchase;

public class PurchaseOrderLine : IEntity<Guid>
{
    public Guid Id { get; private set; }
    public Guid PurchaseOrderId { get; private set; }
    public Guid MaterialId { get; private set; }
    public decimal Quantity { get; private set; }
    public decimal UnitPrice { get; private set; }
    public string? Notes { get; private set; }

    public decimal LineTotal => Quantity * UnitPrice;

    protected PurchaseOrderLine()
    {
    }

    public PurchaseOrderLine(Guid purchaseOrderId, Guid materialId, decimal quantity, decimal unitPrice, string? notes)
    {
        Id = Guid.NewGuid();
        PurchaseOrderId = purchaseOrderId;
        MaterialId = materialId;
        
        if (quantity <= 0)
        {
            throw new ArgumentException("Quantity must be greater than zero", nameof(quantity));
        }
        Quantity = quantity;

        if (unitPrice < 0)
        {
            throw new ArgumentException("Unit price cannot be negative", nameof(unitPrice));
        }
        UnitPrice = unitPrice;

        Notes = notes;
    }

    internal void Update(decimal quantity, decimal unitPrice, string? notes)
    {
        if (quantity <= 0)
        {
            throw new ArgumentException("Quantity must be greater than zero", nameof(quantity));
        }
        Quantity = quantity;

        if (unitPrice < 0)
        {
            throw new ArgumentException("Unit price cannot be negative", nameof(unitPrice));
        }
        UnitPrice = unitPrice;

        Notes = notes;
    }
}
using Anela.Heblo.Xcc.Domain;

namespace Anela.Heblo.Domain.Features.Purchase;

public class PurchaseOrder : IEntity<Guid>
{
    public Guid Id { get; private set; }
    public string OrderNumber { get; private set; } = null!;
    public Guid SupplierId { get; private set; }
    public DateTime OrderDate { get; private set; }
    public DateTime? ExpectedDeliveryDate { get; private set; }
    public PurchaseOrderStatus Status { get; private set; }
    public string? Notes { get; private set; }
    public string CreatedBy { get; private set; } = null!;
    public DateTime CreatedAt { get; private set; }
    public string? UpdatedBy { get; private set; }
    public DateTime? UpdatedAt { get; private set; }

    private readonly List<PurchaseOrderLine> _lines = new();
    public IReadOnlyCollection<PurchaseOrderLine> Lines => _lines.AsReadOnly();

    private readonly List<PurchaseOrderHistory> _history = new();
    public IReadOnlyCollection<PurchaseOrderHistory> History => _history.AsReadOnly();

    public decimal TotalAmount => _lines.Sum(l => l.LineTotal);

    protected PurchaseOrder()
    {
    }

    public PurchaseOrder(
        string orderNumber,
        Guid supplierId,
        DateTime orderDate,
        DateTime? expectedDeliveryDate,
        string? notes,
        string createdBy)
    {
        Id = Guid.NewGuid();
        OrderNumber = orderNumber ?? throw new ArgumentNullException(nameof(orderNumber));
        SupplierId = supplierId;
        OrderDate = orderDate;
        ExpectedDeliveryDate = expectedDeliveryDate;
        Status = PurchaseOrderStatus.Draft;
        Notes = notes;
        CreatedBy = createdBy ?? throw new ArgumentNullException(nameof(createdBy));
        CreatedAt = DateTime.UtcNow;

        AddHistoryEntry($"Order created", null, Status.ToString(), createdBy);
    }

    public void AddLine(Guid materialId, decimal quantity, decimal unitPrice, string? notes)
    {
        if (Status != PurchaseOrderStatus.Draft)
        {
            throw new InvalidOperationException("Cannot add lines to non-draft orders");
        }

        var line = new PurchaseOrderLine(Id, materialId, quantity, unitPrice, notes);
        _lines.Add(line);
        
        UpdatedBy = CreatedBy;
        UpdatedAt = DateTime.UtcNow;
    }

    public void RemoveLine(Guid lineId)
    {
        if (Status != PurchaseOrderStatus.Draft)
        {
            throw new InvalidOperationException("Cannot remove lines from non-draft orders");
        }

        var line = _lines.FirstOrDefault(l => l.Id == lineId);
        if (line != null)
        {
            _lines.Remove(line);
            UpdatedBy = CreatedBy;
            UpdatedAt = DateTime.UtcNow;
        }
    }

    public void UpdateLine(Guid lineId, decimal quantity, decimal unitPrice, string? notes)
    {
        if (Status != PurchaseOrderStatus.Draft)
        {
            throw new InvalidOperationException("Cannot update lines in non-draft orders");
        }

        var line = _lines.FirstOrDefault(l => l.Id == lineId);
        if (line != null)
        {
            line.Update(quantity, unitPrice, notes);
            UpdatedBy = CreatedBy;
            UpdatedAt = DateTime.UtcNow;
        }
    }

    public void Update(DateTime? expectedDeliveryDate, string? notes, string updatedBy)
    {
        if (Status == PurchaseOrderStatus.Completed)
        {
            throw new InvalidOperationException("Cannot update completed orders");
        }

        ExpectedDeliveryDate = expectedDeliveryDate;
        Notes = notes;
        UpdatedBy = updatedBy;
        UpdatedAt = DateTime.UtcNow;
    }

    public void ChangeStatus(PurchaseOrderStatus newStatus, string changedBy)
    {
        if (!IsValidStatusTransition(Status, newStatus))
        {
            throw new InvalidOperationException($"Invalid status transition from {Status} to {newStatus}");
        }

        var oldStatus = Status.ToString();
        Status = newStatus;
        UpdatedBy = changedBy;
        UpdatedAt = DateTime.UtcNow;

        AddHistoryEntry($"Status changed from {oldStatus} to {newStatus}", oldStatus, newStatus.ToString(), changedBy);
    }

    private bool IsValidStatusTransition(PurchaseOrderStatus from, PurchaseOrderStatus to)
    {
        return (from, to) switch
        {
            (PurchaseOrderStatus.Draft, PurchaseOrderStatus.InTransit) => true,
            (PurchaseOrderStatus.InTransit, PurchaseOrderStatus.Completed) => true,
            _ => false
        };
    }

    private void AddHistoryEntry(string action, string? oldValue, string? newValue, string changedBy)
    {
        var historyEntry = new PurchaseOrderHistory(Id, action, oldValue, newValue, changedBy);
        _history.Add(historyEntry);
    }
}
namespace Anela.Heblo.Domain.Features.Weather;

public class WeatherForecast
{
    public DateOnly Date { get; set; }
    public int TemperatureC { get; set; }
    public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
    public string? Summary { get; set; }
}
namespace Anela.Heblo.Domain.Features.Weather;

public static class WeatherConstants
{
    public const int FORECAST_DAYS = 5;
    public const int MIN_TEMPERATURE = -20;
    public const int MAX_TEMPERATURE = 55;

    public static readonly string[] WEATHER_SUMMARIES = new[]
    {
        "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
    };
}
using System.ComponentModel.DataAnnotations;
using System.Linq.Expressions;
using Anela.Heblo.Xcc.Domain;

namespace Anela.Heblo.Domain.Features.Logistics.Transport;

public class TransportBox : Entity<int>
{
    private List<TransportBoxItem> _items = new();
    private List<TransportBoxStateLog> _stateLog = new();

    public IReadOnlyList<TransportBoxItem> Items => _items;

    public string? Code { get; private set; }
    public TransportBoxState State { get; private set; } = TransportBoxState.New;
    public TransportBoxState DefaultReceiveState { get; private set; } = TransportBoxState.Stocked;
    public string? Description { get; set; }
    public DateTime? LastStateChanged { get; set; }

    public string? Location { get; set; }

    public IReadOnlyList<TransportBoxStateLog> StateLog => _stateLog;

    public static Expression<Func<TransportBox, bool>> IsInTransportPredicate = b => b.State == TransportBoxState.InTransit || b.State == TransportBoxState.Received || b.State == TransportBoxState.Opened;
    public static Func<TransportBox, bool> IsInTransportFunc = IsInTransportPredicate.Compile();
    public bool IsInTransit => IsInTransportFunc(this);

    public static Expression<Func<TransportBox, bool>> IsInReservePredicate = b => b.State == TransportBoxState.Reserve;
    public static Func<TransportBox, bool> IsInReserveFunc = IsInReservePredicate.Compile();
    public bool IsInReserve => IsInReserveFunc(this);

    public TransportBoxState? NextState => TransitionNode.NextState?.NewState;
    public TransportBoxState? PreviousState => TransitionNode.PreviousState?.NewState;
    public TransportBoxStateNode TransitionNode => _transitions[State];

    public void Open(string boxCode, DateTime date, string userName)
    {
        ChangeState(TransportBoxState.Opened, date, userName, TransportBoxState.New, TransportBoxState.InTransit, TransportBoxState.Reserve);
        Code = boxCode;
        Location = null;
    }


    public TransportBoxItem AddItem(string productCode, string productName, double amount, DateTime date, string userName)
    {
        CheckState(TransportBoxState.Opened, TransportBoxState.Opened);
        var newItem = new TransportBoxItem(productCode, productName, amount, date, userName);
        _items.Add(newItem);

        return newItem;
    }

    public TransportBoxItem? DeleteItem(int itemId)
    {
        CheckState(TransportBoxState.Opened, TransportBoxState.Opened);
        var toDelete = _items.SingleOrDefault(s => s.Id == itemId);
        return toDelete;
    }


    public void Reset(DateTime date, string userName)
    {
        _items.Clear();
        Code = null;
        ChangeState(TransportBoxState.New, date, userName);
    }

    public void ToTransit(DateTime date, string userName)
    {
        ChangeState(TransportBoxState.InTransit, date, userName, TransportBoxState.Opened, TransportBoxState.Error);
    }

    public void ToReserve(DateTime date, string userName, TransportBoxLocation location)
    {
        Location = location.ToString();
        ChangeState(TransportBoxState.Reserve, date, userName, TransportBoxState.Opened, TransportBoxState.Error);
    }

    public void Receive(DateTime date, string userName, TransportBoxState receiveState = TransportBoxState.Stocked)
    {
        DefaultReceiveState = receiveState;
        ChangeState(TransportBoxState.Received, date, userName, TransportBoxState.InTransit, TransportBoxState.Reserve);
    }


    public void ToSwap(DateTime date, string userName)
    {
        ChangeState(TransportBoxState.InSwap, date, userName, TransportBoxState.Received, TransportBoxState.Stocked);
    }

    public void ToPick(DateTime date, string userName)
    {
        ChangeState(TransportBoxState.Stocked, date, userName, TransportBoxState.InSwap, TransportBoxState.Received);
    }

    public void Close(DateTime date, string userName)
    {
        ChangeState(TransportBoxState.Closed, date, userName);
    }

    private void ChangeState(TransportBoxState newState, DateTime now, string userName, params TransportBoxState[] allowedStates)
    {
        ChangeState(newState, now, userName, null, allowedStates);
    }

    private void ChangeState(TransportBoxState newState, DateTime now, string userName, string? description, TransportBoxState[] allowedStates)
    {
        CheckState(newState, allowedStates);

        if (description != null)
            Description += Environment.NewLine + description;
        State = newState;
        LastStateChanged = now;
        _stateLog.Add(new TransportBoxStateLog(newState, now, userName, description));
    }

    private void CheckState(TransportBoxState newState, params TransportBoxState[] allowedStates)
    {
        if (allowedStates.Any() && !allowedStates.Contains(State))
        {
            throw new ValidationException($"Unable to change state from {State} to {newState} ({string.Join(", ", allowedStates)} state is required for this action)");
        }
    }

    public void Error(DateTime date, string userName, string exMessage)
    {
        ChangeState(TransportBoxState.Error, date, userName, exMessage, Array.Empty<TransportBoxState>());
    }


    private static readonly Dictionary<TransportBoxState, TransportBoxStateNode> _transitions = new();

    static TransportBox()
    {
        _transitions.Add(TransportBoxState.New, new TransportBoxStateNode()
        {
            NextState = new TransportBoxAction(TransportBoxState.Opened, (box, time, userName) => box.Open(box.Code!, time, userName), condition: b => b.Code != null),
            PreviousState = new TransportBoxAction(TransportBoxState.Closed, (box, time, userName) => box.Close(time, userName)),
        }
        );

        _transitions.Add(TransportBoxState.Opened, new TransportBoxStateNode()
        {
            NextState = new TransportBoxAction(TransportBoxState.InTransit, (box, time, userName) => box.ToTransit(time, userName)),
            PreviousState = new TransportBoxAction(TransportBoxState.New, (box, time, userName) => box.Reset(time, userName)),
        }
        );

        _transitions.Add(TransportBoxState.InTransit, new TransportBoxStateNode()
        {
            NextState = new TransportBoxAction(TransportBoxState.Received, (box, time, userName) => box.Receive(time, userName)),
            PreviousState = new TransportBoxAction(TransportBoxState.Opened, (box, time, userName) => box.Open(box.Code!, time, userName), condition: b => b.Code != null),
        }
        );

        _transitions.Add(TransportBoxState.Received, new TransportBoxStateNode());

        _transitions.Add(TransportBoxState.InSwap, new TransportBoxStateNode()
        {
            NextState = new TransportBoxAction(TransportBoxState.Stocked, (box, time, userName) => box.ToPick(time, userName)),
        }
        );

        _transitions.Add(TransportBoxState.Stocked, new TransportBoxStateNode()
        {
            NextState = new TransportBoxAction(TransportBoxState.Closed, (box, time, userName) => box.Close(time, userName)),
            //PreviousState = new TransportBoxAction(TransportBoxState.InSwap, (box, time, userName) => box.ToSwap(time, userName))
        }
        );

        _transitions.Add(TransportBoxState.Closed, new TransportBoxStateNode());

        _transitions.Add(TransportBoxState.Reserve, new TransportBoxStateNode()
        {
            NextState = new TransportBoxAction(TransportBoxState.Received, (box, time, userName) => box.Receive(time, userName)),
            PreviousState = new TransportBoxAction(TransportBoxState.Opened, (box, time, userName) => box.Open(box.Code!, time, userName), condition: b => b.Code != null),
        }
        );
    }

}
using System.ComponentModel.DataAnnotations;

namespace Anela.Heblo.Domain.Features.Logistics.Transport;

public class TransportBoxStateNode
{
    public TransportBoxAction? NextState { get; set; }
    public TransportBoxAction? PreviousState { get; set; }

    public TransportBoxAction GetTransition(TransportBoxState targetState)
    {
        if (targetState == NextState?.NewState)
            return NextState;
        if (targetState == PreviousState?.NewState)
            return PreviousState;

        throw new ValidationException($"Unable to change state to {targetState}");
    }
}
namespace Anela.Heblo.Domain.Features.Logistics.Transport;

public enum TransportBoxLocation
{
    Kumbal,
    Relax,
    SkladSkla,
}
namespace Anela.Heblo.Domain.Features.Logistics.Transport;

public enum TransportBoxState
{
    New,
    Opened,
    InTransit,
    Received,
    InSwap,
    Stocked,
    Closed,
    Error,

    Reserve
}
using Anela.Heblo.Xcc.Domain;

namespace Anela.Heblo.Domain.Features.Logistics.Transport;

public class TransportBoxStateLog : Entity<int>
{
    public TransportBoxState State { get; private set; }
    public DateTime StateDate { get; private set; }
    public string? User { get; private set; }
    public string? Description { get; set; }

    internal TransportBoxStateLog(TransportBoxState state, DateTime stateDate, string? user, string? description = null)
    {
        State = state;
        StateDate = stateDate;
        User = user;
        Description = description;
    }
}
using Anela.Heblo.Xcc.Domain;

namespace Anela.Heblo.Domain.Features.Logistics.Transport;

public class TransportBoxItem : Entity<int>
{
    public string ProductCode { get; private set; }

    public string ProductName { get; private set; }
    public double Amount { get; private set; }

    public DateTime DateAdded { get; private set; }

    public string UserAdded { get; private set; }

    public TransportBoxItem(string productCode, string productName, double amount, DateTime dateAdded, string userAdded)
    {
        ProductCode = productCode;
        ProductName = productName;
        Amount = amount;
        DateAdded = dateAdded;
        UserAdded = userAdded;
    }
}
using Anela.Heblo.Xcc.Persistance;

namespace Anela.Heblo.Domain.Features.Logistics.Transport;

public interface ITransportBoxRepository : IRepository<TransportBox, int>
{
}
namespace Anela.Heblo.Domain.Features.Logistics.Transport;

public class TransportBoxAction
{
    private readonly Action<TransportBox, DateTime, string>? _transitionCallback;

    public TransportBoxAction(
        TransportBoxState newState,
        Action<TransportBox, DateTime, string>? transitionCallback = null,
        Func<TransportBox, bool>? condition = null)
    {
        _transitionCallback = transitionCallback;
        NewState = newState;
        Condition = condition;
    }

    public TransportBoxState NewState { get; }
    public Func<TransportBox, bool>? Condition { get; }

    public Task<TransportBox> ChangeStateAsync(TransportBox box, DateTime actionDate, string username)
    {
        _transitionCallback?.Invoke(box, actionDate, username);
        return Task.FromResult(box);
    }
}

namespace Anela.Heblo.Domain.Features.Logistics;

public enum Carriers
{
    Zasilkovna = 1,
    PPL = 2,
    GLS = 3,
    Osobak = 4
}
namespace Anela.Heblo.Domain.Features.Logistics.Picking;

public interface IPickingListSource
{
    Task<PrintPickingListResult> CreatePickingList(PrintPickingListRequest request, CancellationToken cancellationToken = default);
}
namespace Anela.Heblo.Domain.Features.Logistics.Picking;

public class PrintPickingListRequest
{
    public const int DefaultSourceStateId = -2; // Vyrizuje se
    //private const string SourceStateId = "55"; // K Expedici
    //private const string SourceStateId = "26"; // Bali se
    //private const string DesiredStateId = "26"; // Bali se
    public const int DefaultDesiredStateId = 55; // K Expedici

    public IList<Carriers> Carriers { get; set; } = new List<Carriers>();
    public int SourceStateId { get; set; } = DefaultSourceStateId;
    public int DesiredStateId { get; set; } = DefaultDesiredStateId;
    public bool ChangeOrderState { get; set; } = false;

    public static IList<Carriers> DefaultCarriers { get; set; } = new List<Carriers>()
    {
        Logistics.Carriers.Zasilkovna,
        Logistics.Carriers.GLS,
        Logistics.Carriers.PPL,
        Logistics.Carriers.Osobak
    };

    public bool SendToPrinter { get; set; } = false;
}
namespace Anela.Heblo.Domain.Features.Logistics.Picking;

public class PrintPickingListResult
{
    public IList<string> ExportedFiles { get; set; } = new List<string>();
    public int TotalCount { get; set; }
}
namespace Anela.Heblo.Domain.Features.Logistics;

public enum Warehouses
{
    Product = 4,
    Material = 5,
    SemiProduct = 20,

    UNDEFINED = 0,
}
namespace Anela.Heblo.Domain.Features.Manufacture;

public class ManufactureTemplate
{
    public int TemplateId { get; set; }
    public string ProductCode { get; set; }

    public string ProductName { get; set; }
    public double Amount { get; set; }
    public double OriginalAmount { get; set; }

    public List<Ingredient> Ingredients { get; set; } = new List<Ingredient>();

}
namespace Anela.Heblo.Domain.Features.Manufacture;

public class Ingredient
{
    public int TemplateId { get; set; }
    public string ProductCode { get; set; }
    public string ProductName { get; set; }
    public double Amount { get; set; }
    public double OriginalAmount { get; set; }
    public decimal Price { get; set; }
}
namespace Anela.Heblo.Domain.Features.Manufacture;

public interface IManufactureRepository
{
    Task<ManufactureTemplate> GetManufactureTemplateAsync(string id, CancellationToken cancellationToken = default);
    Task<List<ManufactureTemplate>> FindByIngredientAsync(string ingredientCode, CancellationToken cancellationToken = default);
}
using Anela.Heblo.Domain.Features.Purchase;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace Anela.Heblo.Persistence.Configurations;

public class PurchaseOrderConfiguration : IEntityTypeConfiguration<PurchaseOrder>
{
    public void Configure(EntityTypeBuilder<PurchaseOrder> builder)
    {
        builder.ToTable("PurchaseOrders");
        
        builder.HasKey(x => x.Id);
        
        builder.Property(x => x.Id)
            .ValueGeneratedNever();
        
        builder.Property(x => x.OrderNumber)
            .IsRequired()
            .HasMaxLength(PurchaseOrderConstants.OrderNumberMaxLength);
        
        builder.HasIndex(x => x.OrderNumber)
            .IsUnique();
        
        builder.Property(x => x.SupplierId)
            .IsRequired();
        
        builder.Property(x => x.OrderDate)
            .IsRequired();
        
        builder.Property(x => x.ExpectedDeliveryDate);
        
        builder.Property(x => x.Status)
            .IsRequired()
            .HasConversion<string>();
        
        builder.Property(x => x.Notes)
            .HasMaxLength(PurchaseOrderConstants.NotesMaxLength);
        
        builder.Property(x => x.CreatedBy)
            .IsRequired()
            .HasMaxLength(PurchaseOrderConstants.UserNameMaxLength);
        
        builder.Property(x => x.CreatedAt)
            .IsRequired();
        
        builder.Property(x => x.UpdatedBy)
            .HasMaxLength(PurchaseOrderConstants.UserNameMaxLength);
        
        builder.Property(x => x.UpdatedAt);

        builder.HasMany(x => x.Lines)
            .WithOne()
            .HasForeignKey(x => x.PurchaseOrderId)
            .OnDelete(DeleteBehavior.Cascade);

        builder.HasMany(x => x.History)
            .WithOne()
            .HasForeignKey(x => x.PurchaseOrderId)
            .OnDelete(DeleteBehavior.Cascade);

        builder.Navigation(x => x.Lines)
            .EnableLazyLoading(false);

        builder.Navigation(x => x.History)
            .EnableLazyLoading(false);
    }
}
using Anela.Heblo.Domain.Features.Purchase;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace Anela.Heblo.Persistence.Configurations;

public class PurchaseOrderHistoryConfiguration : IEntityTypeConfiguration<PurchaseOrderHistory>
{
    public void Configure(EntityTypeBuilder<PurchaseOrderHistory> builder)
    {
        builder.ToTable("PurchaseOrderHistory");
        
        builder.HasKey(x => x.Id);
        
        builder.Property(x => x.Id)
            .ValueGeneratedNever();
        
        builder.Property(x => x.PurchaseOrderId)
            .IsRequired();
        
        builder.Property(x => x.Action)
            .IsRequired()
            .HasMaxLength(PurchaseOrderConstants.ActionMaxLength);
        
        builder.Property(x => x.OldValue)
            .HasMaxLength(PurchaseOrderConstants.ValueMaxLength);
        
        builder.Property(x => x.NewValue)
            .HasMaxLength(PurchaseOrderConstants.ValueMaxLength);
        
        builder.Property(x => x.ChangedBy)
            .IsRequired()
            .HasMaxLength(PurchaseOrderConstants.UserNameMaxLength);
        
        builder.Property(x => x.ChangedAt)
            .IsRequired();

        builder.HasIndex(x => x.PurchaseOrderId);
        builder.HasIndex(x => x.ChangedAt);
    }
}
using Anela.Heblo.Domain.Features.Purchase;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace Anela.Heblo.Persistence.Configurations;

public class PurchaseOrderLineConfiguration : IEntityTypeConfiguration<PurchaseOrderLine>
{
    public void Configure(EntityTypeBuilder<PurchaseOrderLine> builder)
    {
        builder.ToTable("PurchaseOrderLines");
        
        builder.HasKey(x => x.Id);
        
        builder.Property(x => x.Id)
            .ValueGeneratedNever();
        
        builder.Property(x => x.PurchaseOrderId)
            .IsRequired();
        
        builder.Property(x => x.MaterialId)
            .IsRequired();
        
        builder.Property(x => x.Quantity)
            .IsRequired()
            .HasPrecision(18, 4);
        
        builder.Property(x => x.UnitPrice)
            .IsRequired()
            .HasPrecision(18, 4);
        
        builder.Property(x => x.Notes)
            .HasMaxLength(PurchaseOrderConstants.NotesMaxLength);

        builder.Ignore(x => x.LineTotal);

        builder.HasIndex(x => x.PurchaseOrderId);
        builder.HasIndex(x => x.MaterialId);
    }
}
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Anela.Heblo.Persistence")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+6cd183ef4ac33ad09cbb7ecd6a8b9c35891c45cb")]
[assembly: System.Reflection.AssemblyProductAttribute("Anela.Heblo.Persistence")]
[assembly: System.Reflection.AssemblyTitleAttribute("Anela.Heblo.Persistence")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

﻿// <auto-generated />
using System;
using Anela.Heblo.Persistence;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace Anela.Heblo.Persistence.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    [Migration("20250802070938_AddPurchaseOrderTables")]
    partial class AddPurchaseOrderTables
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.8")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("Anela.Heblo.Domain.Features.Purchase.Domain.PurchaseOrder", b =>
                {
                    b.Property<Guid>("Id")
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<DateTime?>("ExpectedDeliveryDate")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Notes")
                        .HasMaxLength(2000)
                        .HasColumnType("character varying(2000)");

                    b.Property<DateTime>("OrderDate")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("OrderNumber")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("character varying(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<Guid>("SupplierId")
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.HasKey("Id");

                    b.HasIndex("OrderNumber")
                        .IsUnique();

                    b.ToTable("PurchaseOrders", (string)null);
                });

            modelBuilder.Entity("Anela.Heblo.Domain.Features.Purchase.Domain.PurchaseOrderHistory", b =>
                {
                    b.Property<Guid>("Id")
                        .HasColumnType("uuid");

                    b.Property<string>("Action")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("character varying(200)");

                    b.Property<DateTime>("ChangedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("ChangedBy")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<string>("NewValue")
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.Property<string>("OldValue")
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.Property<Guid>("PurchaseOrderId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.HasIndex("ChangedAt");

                    b.HasIndex("PurchaseOrderId");

                    b.ToTable("PurchaseOrderHistory", (string)null);
                });

            modelBuilder.Entity("Anela.Heblo.Domain.Features.Purchase.Domain.PurchaseOrderLine", b =>
                {
                    b.Property<Guid>("Id")
                        .HasColumnType("uuid");

                    b.Property<Guid>("MaterialId")
                        .HasColumnType("uuid");

                    b.Property<string>("Notes")
                        .HasMaxLength(2000)
                        .HasColumnType("character varying(2000)");

                    b.Property<Guid>("PurchaseOrderId")
                        .HasColumnType("uuid");

                    b.Property<decimal>("Quantity")
                        .HasPrecision(18, 4)
                        .HasColumnType("numeric(18,4)");

                    b.Property<decimal>("UnitPrice")
                        .HasPrecision(18, 4)
                        .HasColumnType("numeric(18,4)");

                    b.HasKey("Id");

                    b.HasIndex("MaterialId");

                    b.HasIndex("PurchaseOrderId");

                    b.ToTable("PurchaseOrderLines", (string)null);
                });

            modelBuilder.Entity("Anela.Heblo.Domain.Features.Purchase.Domain.PurchaseOrderHistory", b =>
                {
                    b.HasOne("Anela.Heblo.Domain.Features.Purchase.Domain.PurchaseOrder", null)
                        .WithMany("History")
                        .HasForeignKey("PurchaseOrderId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Anela.Heblo.Domain.Features.Purchase.Domain.PurchaseOrderLine", b =>
                {
                    b.HasOne("Anela.Heblo.Domain.Features.Purchase.Domain.PurchaseOrder", null)
                        .WithMany("Lines")
                        .HasForeignKey("PurchaseOrderId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Anela.Heblo.Domain.Features.Purchase.Domain.PurchaseOrder", b =>
                {
                    b.Navigation("History");

                    b.Navigation("Lines");
                });
#pragma warning restore 612, 618
        }
    }
}
﻿using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Anela.Heblo.Persistence.Migrations
{
    /// <inheritdoc />
    public partial class AddPurchaseOrderTables : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "PurchaseOrders",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    OrderNumber = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    SupplierId = table.Column<Guid>(type: "uuid", nullable: false),
                    OrderDate = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    ExpectedDeliveryDate = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    Status = table.Column<string>(type: "text", nullable: false),
                    Notes = table.Column<string>(type: "character varying(2000)", maxLength: 2000, nullable: true),
                    CreatedBy = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    UpdatedBy = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: true),
                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_PurchaseOrders", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "PurchaseOrderHistory",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    PurchaseOrderId = table.Column<Guid>(type: "uuid", nullable: false),
                    Action = table.Column<string>(type: "character varying(200)", maxLength: 200, nullable: false),
                    OldValue = table.Column<string>(type: "character varying(500)", maxLength: 500, nullable: true),
                    NewValue = table.Column<string>(type: "character varying(500)", maxLength: 500, nullable: true),
                    ChangedBy = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: false),
                    ChangedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_PurchaseOrderHistory", x => x.Id);
                    table.ForeignKey(
                        name: "FK_PurchaseOrderHistory_PurchaseOrders_PurchaseOrderId",
                        column: x => x.PurchaseOrderId,
                        principalTable: "PurchaseOrders",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "PurchaseOrderLines",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    PurchaseOrderId = table.Column<Guid>(type: "uuid", nullable: false),
                    MaterialId = table.Column<Guid>(type: "uuid", nullable: false),
                    Quantity = table.Column<decimal>(type: "numeric(18,4)", precision: 18, scale: 4, nullable: false),
                    UnitPrice = table.Column<decimal>(type: "numeric(18,4)", precision: 18, scale: 4, nullable: false),
                    Notes = table.Column<string>(type: "character varying(2000)", maxLength: 2000, nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_PurchaseOrderLines", x => x.Id);
                    table.ForeignKey(
                        name: "FK_PurchaseOrderLines_PurchaseOrders_PurchaseOrderId",
                        column: x => x.PurchaseOrderId,
                        principalTable: "PurchaseOrders",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateIndex(
                name: "IX_PurchaseOrderHistory_ChangedAt",
                table: "PurchaseOrderHistory",
                column: "ChangedAt");

            migrationBuilder.CreateIndex(
                name: "IX_PurchaseOrderHistory_PurchaseOrderId",
                table: "PurchaseOrderHistory",
                column: "PurchaseOrderId");

            migrationBuilder.CreateIndex(
                name: "IX_PurchaseOrderLines_MaterialId",
                table: "PurchaseOrderLines",
                column: "MaterialId");

            migrationBuilder.CreateIndex(
                name: "IX_PurchaseOrderLines_PurchaseOrderId",
                table: "PurchaseOrderLines",
                column: "PurchaseOrderId");

            migrationBuilder.CreateIndex(
                name: "IX_PurchaseOrders_OrderNumber",
                table: "PurchaseOrders",
                column: "OrderNumber",
                unique: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "PurchaseOrderHistory");

            migrationBuilder.DropTable(
                name: "PurchaseOrderLines");

            migrationBuilder.DropTable(
                name: "PurchaseOrders");
        }
    }
}
﻿// <auto-generated />
using System;
using Anela.Heblo.Persistence;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace Anela.Heblo.Persistence.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    partial class ApplicationDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.8")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("Anela.Heblo.Domain.Features.Purchase.Domain.PurchaseOrder", b =>
                {
                    b.Property<Guid>("Id")
                        .HasColumnType("uuid");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("CreatedBy")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<DateTime?>("ExpectedDeliveryDate")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Notes")
                        .HasMaxLength(2000)
                        .HasColumnType("character varying(2000)");

                    b.Property<DateTime>("OrderDate")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("OrderNumber")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("character varying(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<Guid>("SupplierId")
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UpdatedBy")
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.HasKey("Id");

                    b.HasIndex("OrderNumber")
                        .IsUnique();

                    b.ToTable("PurchaseOrders", (string)null);
                });

            modelBuilder.Entity("Anela.Heblo.Domain.Features.Purchase.Domain.PurchaseOrderHistory", b =>
                {
                    b.Property<Guid>("Id")
                        .HasColumnType("uuid");

                    b.Property<string>("Action")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("character varying(200)");

                    b.Property<DateTime>("ChangedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("ChangedBy")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<string>("NewValue")
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.Property<string>("OldValue")
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.Property<Guid>("PurchaseOrderId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.HasIndex("ChangedAt");

                    b.HasIndex("PurchaseOrderId");

                    b.ToTable("PurchaseOrderHistory", (string)null);
                });

            modelBuilder.Entity("Anela.Heblo.Domain.Features.Purchase.Domain.PurchaseOrderLine", b =>
                {
                    b.Property<Guid>("Id")
                        .HasColumnType("uuid");

                    b.Property<Guid>("MaterialId")
                        .HasColumnType("uuid");

                    b.Property<string>("Notes")
                        .HasMaxLength(2000)
                        .HasColumnType("character varying(2000)");

                    b.Property<Guid>("PurchaseOrderId")
                        .HasColumnType("uuid");

                    b.Property<decimal>("Quantity")
                        .HasPrecision(18, 4)
                        .HasColumnType("numeric(18,4)");

                    b.Property<decimal>("UnitPrice")
                        .HasPrecision(18, 4)
                        .HasColumnType("numeric(18,4)");

                    b.HasKey("Id");

                    b.HasIndex("MaterialId");

                    b.HasIndex("PurchaseOrderId");

                    b.ToTable("PurchaseOrderLines", (string)null);
                });

            modelBuilder.Entity("Anela.Heblo.Domain.Features.Purchase.Domain.PurchaseOrderHistory", b =>
                {
                    b.HasOne("Anela.Heblo.Domain.Features.Purchase.Domain.PurchaseOrder", null)
                        .WithMany("History")
                        .HasForeignKey("PurchaseOrderId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Anela.Heblo.Domain.Features.Purchase.Domain.PurchaseOrderLine", b =>
                {
                    b.HasOne("Anela.Heblo.Domain.Features.Purchase.Domain.PurchaseOrder", null)
                        .WithMany("Lines")
                        .HasForeignKey("PurchaseOrderId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Anela.Heblo.Domain.Features.Purchase.Domain.PurchaseOrder", b =>
                {
                    b.Navigation("History");

                    b.Navigation("Lines");
                });
#pragma warning restore 612, 618
        }
    }
}
using Microsoft.EntityFrameworkCore;
using System.Linq.Expressions;
using Anela.Heblo.Xcc.Domain;
using Anela.Heblo.Xcc.Persistance;

namespace Anela.Heblo.Persistence.Repository;

/// <summary>
/// Base generic repository implementation using Entity Framework Core
/// </summary>
/// <typeparam name="TEntity">The entity type</typeparam>
/// <typeparam name="TKey">Entity unique key</typeparam>
public class BaseRepository<TEntity, TKey> : IRepository<TEntity, TKey>
    where TEntity : class, IEntity<TKey>
{
    protected readonly ApplicationDbContext Context;
    protected readonly DbSet<TEntity> DbSet;

    public BaseRepository(ApplicationDbContext context)
    {
        Context = context ?? throw new ArgumentNullException(nameof(context));
        DbSet = context.Set<TEntity>();
    }

    public virtual async Task<TEntity?> GetByIdAsync(TKey id, CancellationToken cancellationToken = default)
    {
        return await DbSet.FindAsync(id, cancellationToken);
    }

    public virtual async Task<IEnumerable<TEntity>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        return await DbSet.ToListAsync(cancellationToken);
    }

    public virtual async Task<IEnumerable<TEntity>> FindAsync(Expression<Func<TEntity, bool>> predicate, CancellationToken cancellationToken = default)
    {
        return await DbSet.Where(predicate).ToListAsync(cancellationToken);
    }

    public virtual async Task<TEntity?> SingleOrDefaultAsync(Expression<Func<TEntity, bool>> predicate, CancellationToken cancellationToken = default)
    {
        return await DbSet.SingleOrDefaultAsync(predicate, cancellationToken);
    }

    public virtual async Task<bool> AnyAsync(Expression<Func<TEntity, bool>> predicate, CancellationToken cancellationToken = default)
    {
        return await DbSet.AnyAsync(predicate, cancellationToken);
    }

    public virtual async Task<int> CountAsync(Expression<Func<TEntity, bool>>? predicate = null, CancellationToken cancellationToken = default)
    {
        return predicate == null
            ? await DbSet.CountAsync(cancellationToken)
            : await DbSet.CountAsync(predicate, cancellationToken);
    }

    public virtual async Task<TEntity> AddAsync(TEntity entity, CancellationToken cancellationToken = default)
    {
        var result = await DbSet.AddAsync(entity, cancellationToken);
        return result.Entity;
    }

    public virtual async Task<IEnumerable<TEntity>> AddRangeAsync(IEnumerable<TEntity> entities, CancellationToken cancellationToken = default)
    {
        var entityList = entities.ToList();
        await DbSet.AddRangeAsync(entityList, cancellationToken);
        return entityList;
    }

    public virtual Task UpdateAsync(TEntity entity, CancellationToken cancellationToken = default)
    {
        DbSet.Update(entity);
        return Task.CompletedTask;
    }

    public virtual async Task DeleteAsync(TEntity entity, CancellationToken cancellationToken = default)
    {
        DbSet.Remove(entity);
        await Task.CompletedTask;
    }

    public virtual async Task DeleteAsync(TKey id, CancellationToken cancellationToken = default)
    {
        var entity = await GetByIdAsync(id, cancellationToken);
        if (entity != null)
        {
            await DeleteAsync(entity, cancellationToken);
        }
    }

    public virtual async Task DeleteRangeAsync(IEnumerable<TEntity> entities, CancellationToken cancellationToken = default)
    {
        DbSet.RemoveRange(entities);
        await Task.CompletedTask;
    }

    public virtual async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        return await Context.SaveChangesAsync(cancellationToken);
    }
}
using Anela.Heblo.Xcc.Telemetry;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace Anela.Heblo.Persistence;

/// <summary>
/// Extension methods for registering persistence services
/// </summary>
public static class PersistenceModule
{
    public static IServiceCollection AddPersistenceServices(this IServiceCollection services, IConfiguration configuration)
    {
        // Register DbContext
        services.AddDbContext<ApplicationDbContext>(options =>
        {
            var connectionString = configuration.GetConnectionString("DefaultConnection");
            if (!string.IsNullOrEmpty(connectionString))
            {
                options.UseNpgsql(connectionString);
            }
            else
            {
                // For testing scenarios where no real database is needed
                options.UseInMemoryDatabase("TestDatabase");
            }
        });

        // Register telemetry services
        services.AddScoped<ITelemetryService, NoOpTelemetryService>(); // Default to NoOp, can be overridden by API layer

        return services;
    }
}
using Anela.Heblo.Domain.Features.Purchase;
using Microsoft.EntityFrameworkCore;

namespace Anela.Heblo.Persistence;

/// <summary>
/// Main application database context
/// Phase 1: Single DbContext for all modules
/// Phase 2: Will be split into module-specific contexts
/// </summary>
public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options)
    {
    }

    public DbSet<PurchaseOrder> PurchaseOrders { get; set; } = null!;
    public DbSet<PurchaseOrderLine> PurchaseOrderLines { get; set; } = null!;
    public DbSet<PurchaseOrderHistory> PurchaseOrderHistory { get; set; } = null!;

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // Apply configurations from current assembly
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(ApplicationDbContext).Assembly);
    }
}
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Anela.Heblo.Application")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+6cd183ef4ac33ad09cbb7ecd6a8b9c35891c45cb")]
[assembly: System.Reflection.AssemblyProductAttribute("Anela.Heblo.Application")]
[assembly: System.Reflection.AssemblyTitleAttribute("Anela.Heblo.Application")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

using Microsoft.Extensions.DependencyInjection;

namespace Anela.Heblo.Application.Features.Configuration;

/// <summary>
/// Configuration module for dependency injection registration
/// </summary>
public static class ConfigurationModule
{
    /// <summary>
    /// Registers configuration feature services
    /// </summary>
    public static IServiceCollection AddConfigurationModule(this IServiceCollection services)
    {
        // MediatR handlers are automatically registered by MediatR assembly scanning
        // No manual registration needed for handlers

        return services;
    }
}
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Hosting;
using System.Reflection;
using Anela.Heblo.Application.Features.Configuration.Model;
using Anela.Heblo.Domain.Features.Configuration;
using MediatR;

namespace Anela.Heblo.Application.Features.Configuration;

/// <summary>
/// Handler for retrieving application configuration
/// </summary>
public class GetConfigurationHandler : IRequestHandler<GetConfigurationRequest, GetConfigurationResponse>
{
    private readonly IConfiguration _configuration;
    private readonly IHostEnvironment _environment;
    private readonly ILogger<GetConfigurationHandler> _logger;

    public GetConfigurationHandler(IConfiguration configuration, IHostEnvironment environment, ILogger<GetConfigurationHandler> logger)
    {
        _configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
        _environment = environment ?? throw new ArgumentNullException(nameof(environment));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task<GetConfigurationResponse> Handle(GetConfigurationRequest request, CancellationToken cancellationToken)
    {
        try
        {
            _logger.LogDebug("Handling GetConfiguration request");

            var appConfig = await BuildApplicationConfigurationAsync();

            var response = new GetConfigurationResponse
            {
                Version = appConfig.Version,
                Environment = appConfig.Environment,
                UseMockAuth = appConfig.UseMockAuth,
                Timestamp = appConfig.Timestamp
            };

            _logger.LogDebug("Configuration retrieved successfully: {@Config}", response);

            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving application configuration");
            throw;
        }
    }

    private async Task<ApplicationConfiguration> BuildApplicationConfigurationAsync()
    {
        // Get version with priority order:
        // 1. APP_VERSION (set by CI/CD pipeline with GitVersion)
        // 2. Assembly informational version
        // 3. Assembly version
        // 4. Fallback to default
        var version = GetVersionFromSources();

        // Get environment
        var environment = _environment.EnvironmentName;

        // Get mock auth setting
        var useMockAuth = _configuration.GetValue<bool>(ConfigurationConstants.USE_MOCK_AUTH, false);

        var config = ApplicationConfiguration.CreateWithDefaults(version, environment, useMockAuth);

        await Task.CompletedTask; // Placeholder for potential async operations

        return config;
    }

    private string? GetVersionFromSources()
    {
        // 1. Try environment variable first (CI/CD pipeline)
        var version = Environment.GetEnvironmentVariable(ConfigurationConstants.APP_VERSION);
        if (!string.IsNullOrEmpty(version))
        {
            _logger.LogDebug("Version found from APP_VERSION environment variable: {Version}", version);
            return version;
        }

        // 2. Try assembly informational version
        var assembly = Assembly.GetExecutingAssembly();
        version = assembly.GetCustomAttribute<AssemblyInformationalVersionAttribute>()?.InformationalVersion;
        if (!string.IsNullOrEmpty(version))
        {
            _logger.LogDebug("Version found from assembly informational version: {Version}", version);
            return version;
        }

        // 3. Try assembly version
        version = assembly.GetName().Version?.ToString();
        if (!string.IsNullOrEmpty(version))
        {
            _logger.LogDebug("Version found from assembly version: {Version}", version);
            return version;
        }

        _logger.LogDebug("No version found, will use default");
        return null;
    }
}
namespace Anela.Heblo.Application.Features.Configuration.Model;

/// <summary>
/// Response containing application configuration information
/// </summary>
public class GetConfigurationResponse
{
    /// <summary>
    /// Application version from CI/CD pipeline or assembly
    /// </summary>
    public string Version { get; set; } = default!;

    /// <summary>
    /// Current environment (Development, Test, Production)
    /// </summary>
    public string Environment { get; set; } = default!;

    /// <summary>
    /// Whether mock authentication is enabled
    /// </summary>
    public bool UseMockAuth { get; set; }

    /// <summary>
    /// Response timestamp in UTC
    /// </summary>
    public DateTime Timestamp { get; set; }
}
using MediatR;

namespace Anela.Heblo.Application.Features.Configuration.Model;

/// <summary>
/// Request for getting application configuration
/// </summary>
public class GetConfigurationRequest : IRequest<GetConfigurationResponse>
{
    // Empty request - no parameters needed for configuration endpoint
}
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Application.Features.Catalog.Model;
using MediatR;

namespace Anela.Heblo.Application.Features.Catalog;

public class RefreshEshopPricesDataHandler : IRequestHandler<RefreshEshopPricesDataRequest>
{
    private readonly ICatalogRepository _catalogRepository;

    public RefreshEshopPricesDataHandler(ICatalogRepository catalogRepository)
    {
        _catalogRepository = catalogRepository;
    }

    public async Task Handle(RefreshEshopPricesDataRequest request, CancellationToken cancellationToken)
    {
        await _catalogRepository.RefreshEshopPricesData(cancellationToken);
    }
}
using Anela.Heblo.Application.Features.Catalog.Model;
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Domain.Features.Catalog.Price;
using Anela.Heblo.Domain.Features.Catalog.Stock;
using AutoMapper;

namespace Anela.Heblo.Application.Features.Catalog;

public class CatalogMappingProfile : Profile
{
    public CatalogMappingProfile()
    {
        CreateMap<CatalogAggregate, CatalogItemDto>()
            .ForMember(dest => dest.Price, opt => opt.MapFrom(src => src));

        CreateMap<StockData, StockDto>();

        CreateMap<CatalogProperties, PropertiesDto>();

        CreateMap<CatalogAggregate, PriceDto>()
            .ForMember(dest => dest.CurrentSellingPrice, opt => opt.MapFrom(src => src.CurrentSellingPrice))
            .ForMember(dest => dest.CurrentPurchasePrice, opt => opt.MapFrom(src => src.CurrentPurchasePrice))
            .ForMember(dest => dest.SellingPriceWithVat, opt => opt.MapFrom(src => src.SellingPriceWithVat))
            .ForMember(dest => dest.PurchasePriceWithVat, opt => opt.MapFrom(src => src.PurchasePriceWithVat))
            .ForMember(dest => dest.EshopPrice, opt => opt.MapFrom(src => src.EshopPrice))
            .ForMember(dest => dest.ErpPrice, opt => opt.MapFrom(src => src.ErpPrice));

        CreateMap<ProductPriceEshop, EshopPriceDto>();

        CreateMap<ProductPriceErp, ErpPriceDto>();
    }
}
using MediatR;
using Anela.Heblo.Xcc.Persistance;
using System.Linq.Expressions;
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Application.Features.Catalog.Model;
using Anela.Heblo.Xcc;
using AutoMapper;

namespace Anela.Heblo.Application.Features.Catalog;

public class GetCatalogListHandler : IRequestHandler<GetCatalogListRequest, GetCatalogListResponse>
{
    private readonly ICatalogRepository _catalogRepository;
    private readonly IMapper _mapper;

    public GetCatalogListHandler(ICatalogRepository catalogRepository, IMapper mapper)
    {
        _catalogRepository = catalogRepository;
        _mapper = mapper;
    }

    public async Task<GetCatalogListResponse> Handle(GetCatalogListRequest request, CancellationToken cancellationToken)
    {
        // Build filter expression
        Expression<Func<CatalogAggregate, bool>> filter = x => true;

        if (request.Type.HasValue)
        {
            var typeValue = request.Type.Value;
            filter = filter.And(x => x.Type == typeValue);
        }

        if (!string.IsNullOrWhiteSpace(request.ProductName))
        {
            var productName = request.ProductName.Trim();
            filter = filter.And(x => x.ProductName.ToLowerInvariant().Contains(productName.ToLowerInvariant()));
        }

        if (!string.IsNullOrWhiteSpace(request.ProductCode))
        {
            var productCode = request.ProductCode.Trim();
            filter = filter.And(x => x.ProductCode.ToLowerInvariant().Contains(productCode.ToLowerInvariant()));
        }

        // Get all filtered items (repository doesn't support paging directly)
        var allItems = await _catalogRepository.FindAsync(filter, cancellationToken);

        // Apply sorting
        var query = allItems.AsQueryable();

        query = request.SortBy?.ToLower() switch
        {
            "productcode" => request.SortDescending ? query.OrderByDescending(x => x.ProductCode) : query.OrderBy(x => x.ProductCode),
            "productname" => request.SortDescending ? query.OrderByDescending(x => x.ProductName) : query.OrderBy(x => x.ProductName),
            "type" => request.SortDescending ? query.OrderByDescending(x => x.Type) : query.OrderBy(x => x.Type),
            "location" => request.SortDescending ? query.OrderByDescending(x => x.Location) : query.OrderBy(x => x.Location),
            "available" => request.SortDescending ? query.OrderByDescending(x => x.Stock.Available) : query.OrderBy(x => x.Stock.Available),
            "erp" => request.SortDescending ? query.OrderByDescending(x => x.Stock.Erp) : query.OrderBy(x => x.Stock.Erp),
            "eshop" => request.SortDescending ? query.OrderByDescending(x => x.Stock.Eshop) : query.OrderBy(x => x.Stock.Eshop),
            _ => query.OrderBy(x => x.ProductCode) // Default sort by ProductCode
        };

        // Count total items
        var totalCount = query.Count();

        // Apply paging
        var pagedItems = query
            .Skip((request.PageNumber - 1) * request.PageSize)
            .Take(request.PageSize)
            .ToList();

        // Map to DTOs using AutoMapper
        var items = _mapper.Map<List<CatalogItemDto>>(pagedItems);

        return new GetCatalogListResponse
        {
            Items = items,
            TotalCount = totalCount,
            PageNumber = request.PageNumber,
            PageSize = request.PageSize
        };
    }
}
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Application.Features.Catalog.Model;
using MediatR;

namespace Anela.Heblo.Application.Features.Catalog;

public class RefreshConsumedHistoryDataHandler : IRequestHandler<RefreshConsumedHistoryDataRequest>
{
    private readonly ICatalogRepository _catalogRepository;

    public RefreshConsumedHistoryDataHandler(ICatalogRepository catalogRepository)
    {
        _catalogRepository = catalogRepository;
    }

    public async Task Handle(RefreshConsumedHistoryDataRequest request, CancellationToken cancellationToken)
    {
        await _catalogRepository.RefreshConsumedHistoryData(cancellationToken);
    }
}
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Application.Features.Catalog.Model;
using MediatR;

namespace Anela.Heblo.Application.Features.Catalog;

public class RefreshReserveDataHandler : IRequestHandler<RefreshReserveDataRequest>
{
    private readonly ICatalogRepository _catalogRepository;

    public RefreshReserveDataHandler(ICatalogRepository catalogRepository)
    {
        _catalogRepository = catalogRepository;
    }

    public async Task Handle(RefreshReserveDataRequest request, CancellationToken cancellationToken)
    {
        await _catalogRepository.RefreshReserveData(cancellationToken);
    }
}
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Application.Features.Catalog.Model;
using MediatR;

namespace Anela.Heblo.Application.Features.Catalog;

public class RefreshAttributesDataHandler : IRequestHandler<RefreshAttributesDataRequest>
{
    private readonly ICatalogRepository _catalogRepository;

    public RefreshAttributesDataHandler(ICatalogRepository catalogRepository)
    {
        _catalogRepository = catalogRepository;
    }

    public async Task Handle(RefreshAttributesDataRequest request, CancellationToken cancellationToken)
    {
        await _catalogRepository.RefreshAttributesData(cancellationToken);
    }
}
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Application.Features.Catalog.Model;
using MediatR;

namespace Anela.Heblo.Application.Features.Catalog;

public class RefreshSalesDataHandler : IRequestHandler<RefreshSalesDataRequest>
{
    private readonly ICatalogRepository _catalogRepository;

    public RefreshSalesDataHandler(ICatalogRepository catalogRepository)
    {
        _catalogRepository = catalogRepository;
    }

    public async Task Handle(RefreshSalesDataRequest request, CancellationToken cancellationToken)
    {
        await _catalogRepository.RefreshSalesData(cancellationToken);
    }
}
using Anela.Heblo.Domain.Features.Logistics.Transport;
using Anela.Heblo.Xcc.Persistance;

namespace Anela.Heblo.Application.Features.Catalog.Fakes;

public class EmptyTransportBoxRepository : EmptyRepository<TransportBox, int>, ITransportBoxRepository
{
}
using Anela.Heblo.Application.Features.Catalog.Model;
using Anela.Heblo.Domain.Features.Catalog;
using AutoMapper;
using MediatR;

namespace Anela.Heblo.Application.Features.Catalog;

public class GetCatalogDetailHandler : IRequestHandler<GetCatalogDetailRequest, GetCatalogDetailResponse>
{
    private readonly ICatalogRepository _catalogRepository;
    private readonly IMapper _mapper;
    private readonly TimeProvider _timeProvider;

    public GetCatalogDetailHandler(
        ICatalogRepository catalogRepository,
        IMapper mapper,
        TimeProvider timeProvider)
    {
        _catalogRepository = catalogRepository;
        _mapper = mapper;
        _timeProvider = timeProvider;
    }

    public async Task<GetCatalogDetailResponse> Handle(GetCatalogDetailRequest request, CancellationToken cancellationToken)
    {
        // Get catalog item with all historical data already loaded from cache
        var catalogItem = await _catalogRepository.SingleOrDefaultAsync(
            x => x.ProductCode == request.ProductCode,
            cancellationToken);

        if (catalogItem == null)
        {
            throw new InvalidOperationException($"Product with code '{request.ProductCode}' not found.");
        }

        // Convert historical data to DTOs with monthly grouping
        var salesHistory = GetSalesHistoryFromAggregate(catalogItem, request.MonthsBack);
        var purchaseHistory = GetPurchaseHistoryFromAggregate(catalogItem, request.MonthsBack);
        var consumedHistory = GetConsumedHistoryFromAggregate(catalogItem, request.MonthsBack);

        return new GetCatalogDetailResponse
        {
            Item = _mapper.Map<CatalogItemDto>(catalogItem),
            HistoricalData = new CatalogHistoricalDataDto
            {
                SalesHistory = salesHistory.OrderByDescending(x => x.Year).ThenByDescending(x => x.Month).ToList(),
                PurchaseHistory = purchaseHistory.OrderByDescending(x => x.Year).ThenByDescending(x => x.Month).ToList(),
                ConsumedHistory = consumedHistory.OrderByDescending(x => x.Year).ThenByDescending(x => x.Month).ToList()
            }
        };
    }

    private List<CatalogSalesRecordDto> GetSalesHistoryFromAggregate(CatalogAggregate catalogItem, int monthsBack)
    {
        // Use pre-calculated summary data - much faster than runtime aggregation
        var currentDate = _timeProvider.GetUtcNow().Date;
        var fromDate = currentDate.AddMonths(-monthsBack);
        var fromKey = $"{fromDate.Year:D4}-{fromDate.Month:D2}";

        return catalogItem.SaleHistorySummary.MonthlyData
            .Where(kvp => string.Compare(kvp.Key, fromKey, StringComparison.Ordinal) >= 0)
            .Select(kvp => new CatalogSalesRecordDto
            {
                Year = kvp.Value.Year,
                Month = kvp.Value.Month,
                AmountTotal = kvp.Value.TotalAmount,
                AmountB2B = kvp.Value.AmountB2B,
                AmountB2C = kvp.Value.AmountB2C,
                SumTotal = kvp.Value.TotalRevenue,
                SumB2B = kvp.Value.TotalB2B,
                SumB2C = kvp.Value.TotalB2C
            }).ToList();
    }

    private List<CatalogPurchaseRecordDto> GetPurchaseHistoryFromAggregate(CatalogAggregate catalogItem, int monthsBack)
    {
        // Use pre-calculated summary data - much faster than runtime aggregation
        var currentDate = _timeProvider.GetUtcNow().Date;
        var fromDate = currentDate.AddMonths(-monthsBack);
        var fromKey = $"{fromDate.Year:D4}-{fromDate.Month:D2}";

        return catalogItem.PurchaseHistorySummary.MonthlyData
            .Where(kvp => string.Compare(kvp.Key, fromKey, StringComparison.Ordinal) >= 0)
            .Select(kvp => new CatalogPurchaseRecordDto
            {
                Year = kvp.Value.Year,
                Month = kvp.Value.Month,
                SupplierName = kvp.Value.SupplierBreakdown.FirstOrDefault().Value?.SupplierName ?? string.Empty,
                Amount = kvp.Value.TotalAmount,
                PricePerPiece = kvp.Value.AveragePricePerPiece,
                PriceTotal = kvp.Value.TotalCost,
                DocumentNumber = string.Empty // Document numbers not stored in summary
            }).ToList();
    }

    private List<CatalogConsumedRecordDto> GetConsumedHistoryFromAggregate(CatalogAggregate catalogItem, int monthsBack)
    {
        // Use pre-calculated summary data - much faster than runtime aggregation
        var currentDate = _timeProvider.GetUtcNow().Date;
        var fromDate = currentDate.AddMonths(-monthsBack);
        var fromKey = $"{fromDate.Year:D4}-{fromDate.Month:D2}";

        return catalogItem.ConsumedHistorySummary.MonthlyData
            .Where(kvp => string.Compare(kvp.Key, fromKey, StringComparison.Ordinal) >= 0)
            .Select(kvp => new CatalogConsumedRecordDto
            {
                Year = kvp.Value.Year,
                Month = kvp.Value.Month,
                Amount = kvp.Value.TotalAmount,
                ProductName = catalogItem.ProductName // Use product name from main aggregate
            }).ToList();
    }
}
using Anela.Heblo.Application.Features.Catalog.Fakes;
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Domain.Features.Catalog.Stock;
using Anela.Heblo.Domain.Features.Logistics.Transport;
using Microsoft.Extensions.DependencyInjection;

namespace Anela.Heblo.Application.Features.Catalog;

public static class CatalogModule
{
    public static IServiceCollection AddCatalogModule(this IServiceCollection services)
    {
        // MediatR handlers are automatically registered by AddMediatR scan

        services.AddTransient<ICatalogRepository, CatalogRepository>();
        // Register any catalog-specific services here if needed

        services.AddTransient<ITransportBoxRepository, EmptyTransportBoxRepository>();
        services.AddTransient<IStockTakingRepository, EmptyStockTakingRepository>();

        // Register background service for periodic refresh operations
        services.AddHostedService<CatalogRefreshBackgroundService>();

        // Configure catalog repository options
        services.Configure<CatalogRepositoryOptions>(options => { });

        // Register AutoMapper for catalog mappings
        services.AddAutoMapper(typeof(CatalogModule));

        return services;
    }
}
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Application.Features.Catalog.Model;
using MediatR;

namespace Anela.Heblo.Application.Features.Catalog;

public class RefreshStockTakingDataHandler : IRequestHandler<RefreshStockTakingDataRequest>
{
    private readonly ICatalogRepository _catalogRepository;

    public RefreshStockTakingDataHandler(ICatalogRepository catalogRepository)
    {
        _catalogRepository = catalogRepository;
    }

    public async Task Handle(RefreshStockTakingDataRequest request, CancellationToken cancellationToken)
    {
        await _catalogRepository.RefreshStockTakingData(cancellationToken);
    }
}
using Anela.Heblo.Domain.Features.Catalog;

namespace Anela.Heblo.Application.Features.Catalog.Model;

public class CatalogItemDto
{
    public string ProductCode { get; set; } = string.Empty;
    public string ProductName { get; set; } = string.Empty;
    public ProductType Type { get; set; }
    public StockDto Stock { get; set; } = new();
    public PriceDto Price { get; set; } = new();
    public PropertiesDto Properties { get; set; } = new();
    public string Location { get; set; } = string.Empty;
    public string MinimalOrderQuantity { get; set; } = string.Empty;
    public double MinimalManufactureQuantity { get; set; }
}
namespace Anela.Heblo.Application.Features.Catalog.Model;

public class GetCatalogDetailResponse
{
    public CatalogItemDto Item { get; set; } = new();
    public CatalogHistoricalDataDto HistoricalData { get; set; } = new();
}
using System.Text.Json.Serialization;

namespace Anela.Heblo.Application.Features.Catalog.Model;

public class CatalogHistoricalDataDto
{
    [JsonPropertyName("salesHistory")]
    public List<CatalogSalesRecordDto> SalesHistory { get; set; } = new();

    [JsonPropertyName("purchaseHistory")]
    public List<CatalogPurchaseRecordDto> PurchaseHistory { get; set; } = new();

    [JsonPropertyName("consumedHistory")]
    public List<CatalogConsumedRecordDto> ConsumedHistory { get; set; } = new();
}
using System.Text.Json.Serialization;

namespace Anela.Heblo.Application.Features.Catalog.Model;

public class CatalogPurchaseRecordDto
{
    [JsonPropertyName("year")]
    public int Year { get; set; }

    [JsonPropertyName("month")]
    public int Month { get; set; }

    [JsonPropertyName("supplierName")]
    public string SupplierName { get; set; } = string.Empty;

    [JsonPropertyName("amount")]
    public double Amount { get; set; }

    [JsonPropertyName("pricePerPiece")]
    public decimal PricePerPiece { get; set; }

    [JsonPropertyName("priceTotal")]
    public decimal PriceTotal { get; set; }

    [JsonPropertyName("documentNumber")]
    public string DocumentNumber { get; set; } = string.Empty;
}
using System.Text.Json.Serialization;

namespace Anela.Heblo.Application.Features.Catalog.Model;

public class CatalogSalesRecordDto
{
    [JsonPropertyName("year")]
    public int Year { get; set; }

    [JsonPropertyName("month")]
    public int Month { get; set; }

    [JsonPropertyName("amountTotal")]
    public double AmountTotal { get; set; }

    [JsonPropertyName("amountB2B")]
    public double AmountB2B { get; set; }

    [JsonPropertyName("amountB2C")]
    public double AmountB2C { get; set; }

    [JsonPropertyName("sumTotal")]
    public decimal SumTotal { get; set; }

    [JsonPropertyName("sumB2B")]
    public decimal SumB2B { get; set; }

    [JsonPropertyName("sumB2C")]
    public decimal SumB2C { get; set; }
}
namespace Anela.Heblo.Application.Features.Catalog.Model;

public class StockDto
{
    public decimal Eshop { get; set; }
    public decimal Erp { get; set; }
    public decimal Transport { get; set; }
    public decimal Reserve { get; set; }
    public decimal Available { get; set; }
}
using Anela.Heblo.Domain.Features.Catalog;
using MediatR;

namespace Anela.Heblo.Application.Features.Catalog.Model;

public class GetCatalogListRequest : IRequest<GetCatalogListResponse>
{
    public ProductType? Type { get; set; }
    public int PageNumber { get; set; } = 1;
    public int PageSize { get; set; } = 20;
    public string? SortBy { get; set; }
    public bool SortDescending { get; set; } = false;
    public string? ProductName { get; set; }
    public string? ProductCode { get; set; }
}
using System.Text.Json.Serialization;

namespace Anela.Heblo.Application.Features.Catalog.Model;

public class CatalogConsumedRecordDto
{
    [JsonPropertyName("year")]
    public int Year { get; set; }

    [JsonPropertyName("month")]
    public int Month { get; set; }

    [JsonPropertyName("amount")]
    public double Amount { get; set; }

    [JsonPropertyName("productName")]
    public string ProductName { get; set; } = string.Empty;
}
namespace Anela.Heblo.Application.Features.Catalog.Model;

public class PriceDto
{
    public decimal? CurrentSellingPrice { get; set; }
    public decimal? CurrentPurchasePrice { get; set; }
    public decimal? SellingPriceWithVat { get; set; }
    public decimal? PurchasePriceWithVat { get; set; }
    public EshopPriceDto? EshopPrice { get; set; }
    public ErpPriceDto? ErpPrice { get; set; }
}

public class EshopPriceDto
{
    public decimal PriceWithVat { get; set; }
    public decimal PurchasePrice { get; set; }
}

public class ErpPriceDto
{
    public decimal PriceWithoutVat { get; set; }
    public decimal PriceWithVat { get; set; }
    public decimal PurchasePrice { get; set; }
    public decimal PurchasePriceWithVat { get; set; }
}
using MediatR;

namespace Anela.Heblo.Application.Features.Catalog.Model;

public class GetCatalogDetailRequest : IRequest<GetCatalogDetailResponse>
{
    public string ProductCode { get; set; } = string.Empty;
    public int MonthsBack { get; set; } = 13;
}
namespace Anela.Heblo.Application.Features.Catalog.Model;

public class GetCatalogListResponse
{
    public List<CatalogItemDto> Items { get; set; } = new();
    public int TotalCount { get; set; }
    public int PageNumber { get; set; }
    public int PageSize { get; set; }
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
}
namespace Anela.Heblo.Application.Features.Catalog.Model;
public class PropertiesDto
{
    public int OptimalStockDaysSetup { get; set; }
    public decimal StockMinSetup { get; set; }
    public int BatchSize { get; set; }
    public int[] SeasonMonths { get; set; } = Array.Empty<int>();
}
using MediatR;

namespace Anela.Heblo.Application.Features.Catalog.Model;

public record RefreshTransportDataRequest() : IRequest;
public record RefreshReserveDataRequest() : IRequest;
public record RefreshSalesDataRequest() : IRequest;
public record RefreshAttributesDataRequest() : IRequest;
public record RefreshErpStockDataRequest() : IRequest;
public record RefreshEshopStockDataRequest() : IRequest;
public record RefreshPurchaseHistoryDataRequest() : IRequest;
public record RefreshConsumedHistoryDataRequest() : IRequest;
public record RefreshStockTakingDataRequest() : IRequest;
public record RefreshLotsDataRequest() : IRequest;
public record RefreshEshopPricesDataRequest() : IRequest;
public record RefreshErpPricesDataRequest() : IRequest;
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Application.Features.Catalog.Model;
using MediatR;

namespace Anela.Heblo.Application.Features.Catalog;

public class RefreshEshopStockDataHandler : IRequestHandler<RefreshEshopStockDataRequest>
{
    private readonly ICatalogRepository _catalogRepository;

    public RefreshEshopStockDataHandler(ICatalogRepository catalogRepository)
    {
        _catalogRepository = catalogRepository;
    }

    public async Task Handle(RefreshEshopStockDataRequest request, CancellationToken cancellationToken)
    {
        await _catalogRepository.RefreshEshopStockData(cancellationToken);
    }
}
using Anela.Heblo.Domain.Features.Catalog;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace Anela.Heblo.Application.Features.Catalog;

public class CatalogRefreshBackgroundService : BackgroundService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<CatalogRefreshBackgroundService> _logger;
    private readonly CatalogRepositoryOptions _options;

    private DateTime _lastTransportRefresh = DateTime.MinValue;
    private DateTime _lastReserveRefresh = DateTime.MinValue;
    private DateTime _lastSalesRefresh = DateTime.MinValue;
    private DateTime _lastAttributesRefresh = DateTime.MinValue;
    private DateTime _lastErpStockRefresh = DateTime.MinValue;
    private DateTime _lastEshopStockRefresh = DateTime.MinValue;
    private DateTime _lastPurchaseHistoryRefresh = DateTime.MinValue;
    private DateTime _lastConsumedRefresh = DateTime.MinValue;
    private DateTime _lastStockTakingRefresh = DateTime.MinValue;
    private DateTime _lastLotsRefresh = DateTime.MinValue;
    private DateTime _lastEshopPricesRefresh = DateTime.MinValue;
    private DateTime _lastErpPricesRefresh = DateTime.MinValue;

    public CatalogRefreshBackgroundService(
        IServiceProvider serviceProvider,
        ILogger<CatalogRefreshBackgroundService> logger,
        IOptions<CatalogRepositoryOptions> options)
    {
        _serviceProvider = serviceProvider;
        _logger = logger;
        _options = options.Value;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("Catalog Refresh Background Service started");

        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                var now = DateTime.UtcNow;

                using var scope = _serviceProvider.CreateScope();
                var catalogRepository = scope.ServiceProvider.GetRequiredService<ICatalogRepository>();

                // Check and execute refresh operations based on intervals
                if (await RefreshIfNeeded(catalogRepository, "Transport",
                    _lastTransportRefresh, _options.TransportRefreshInterval,
                    async ct => await catalogRepository.RefreshTransportData(ct),
                    now, stoppingToken))
                {
                    _lastTransportRefresh = now;
                }

                if (await RefreshIfNeeded(catalogRepository, "Reserve",
                    _lastReserveRefresh, _options.ReserveRefreshInterval,
                    async ct => await catalogRepository.RefreshReserveData(ct),
                    now, stoppingToken))
                {
                    _lastReserveRefresh = now;
                }

                if (await RefreshIfNeeded(catalogRepository, "Sales",
                    _lastSalesRefresh, _options.SalesRefreshInterval,
                    async ct => await catalogRepository.RefreshSalesData(ct),
                    now, stoppingToken))
                {
                    _lastSalesRefresh = now;
                }

                if (await RefreshIfNeeded(catalogRepository, "Attributes",
                    _lastAttributesRefresh, _options.AttributesRefreshInterval,
                    async ct => await catalogRepository.RefreshAttributesData(ct),
                    now, stoppingToken))
                {
                    _lastAttributesRefresh = now;
                }

                if (await RefreshIfNeeded(catalogRepository, "ERP Stock",
                    _lastErpStockRefresh, _options.ErpStockRefreshInterval,
                    async ct => await catalogRepository.RefreshErpStockData(ct),
                    now, stoppingToken))
                {
                    _lastErpStockRefresh = now;
                }

                if (await RefreshIfNeeded(catalogRepository, "E-shop Stock",
                    _lastEshopStockRefresh, _options.EshopStockRefreshInterval,
                    async ct => await catalogRepository.RefreshEshopStockData(ct),
                    now, stoppingToken))
                {
                    _lastEshopStockRefresh = now;
                }

                if (await RefreshIfNeeded(catalogRepository, "Purchase History",
                    _lastPurchaseHistoryRefresh, _options.PurchaseHistoryRefreshInterval,
                    async ct => await catalogRepository.RefreshPurchaseHistoryData(ct),
                    now, stoppingToken))
                {
                    _lastPurchaseHistoryRefresh = now;
                }

                if (await RefreshIfNeeded(catalogRepository, "Consumed History",
                    _lastConsumedRefresh, _options.ConsumedRefreshInterval,
                    async ct => await catalogRepository.RefreshConsumedHistoryData(ct),
                    now, stoppingToken))
                {
                    _lastConsumedRefresh = now;
                }

                if (await RefreshIfNeeded(catalogRepository, "Stock Taking",
                    _lastStockTakingRefresh, _options.StockTakingRefreshInterval,
                    async ct => await catalogRepository.RefreshStockTakingData(ct),
                    now, stoppingToken))
                {
                    _lastStockTakingRefresh = now;
                }

                if (await RefreshIfNeeded(catalogRepository, "Lots Data",
                    _lastLotsRefresh, _options.LotsRefreshInterval,
                    async ct => await catalogRepository.RefreshLotsData(ct),
                    now, stoppingToken))
                {
                    _lastLotsRefresh = now;
                }

                if (await RefreshIfNeeded(catalogRepository, "E-shop Prices",
                    _lastEshopPricesRefresh, _options.EshopPricesRefreshInterval,
                    async ct => await catalogRepository.RefreshEshopPricesData(ct),
                    now, stoppingToken))
                {
                    _lastEshopPricesRefresh = now;
                }

                if (await RefreshIfNeeded(catalogRepository, "ERP Prices",
                    _lastErpPricesRefresh, _options.ErpPricesRefreshInterval,
                    async ct => await catalogRepository.RefreshErpPricesData(ct),
                    now, stoppingToken))
                {
                    _lastErpPricesRefresh = now;
                }

                // Wait before next cycle (check every minute)
                await Task.Delay(TimeSpan.FromMinutes(1), stoppingToken);
            }
            catch (OperationCanceledException)
            {
                // Expected when cancellation is requested
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error occurred in Catalog Refresh Background Service");

                // Wait before retrying in case of error
                await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken);
            }
        }

        _logger.LogInformation("Catalog Refresh Background Service stopped");
    }

    private async Task<bool> RefreshIfNeeded(
        ICatalogRepository catalogRepository,
        string operationName,
        DateTime lastRefresh,
        TimeSpan interval,
        Func<CancellationToken, Task> refreshAction,
        DateTime now,
        CancellationToken cancellationToken)
    {
        if (now - lastRefresh >= interval)
        {
            try
            {
                _logger.LogInformation("Starting {OperationName} refresh", operationName);
                await refreshAction(cancellationToken);
                _logger.LogInformation("Completed {OperationName} refresh", operationName);
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to refresh {OperationName}", operationName);
                // Continue with other refresh operations even if one fails
                return false;
            }
        }
        return false;
    }
}
namespace Anela.Heblo.Application.Features.Catalog;

public class CatalogRepositoryOptions
{
    public const string ConfigKey = "CatalogRepositoryOptions";

    public TimeSpan ErpStockRefreshInterval { get; set; } = TimeSpan.FromMinutes(10);

    public TimeSpan EshopStockRefreshInterval { get; set; } = TimeSpan.FromMinutes(5);

    public TimeSpan AttributesRefreshInterval { get; set; } = TimeSpan.FromMinutes(60);

    public TimeSpan SalesRefreshInterval { get; set; } = TimeSpan.FromMinutes(60);

    public TimeSpan ConsumedRefreshInterval { get; set; } = TimeSpan.FromMinutes(60);

    public TimeSpan TransportRefreshInterval { get; set; } = TimeSpan.FromMinutes(5);
    public TimeSpan ReserveRefreshInterval { get; set; } = TimeSpan.FromMinutes(5);
    public TimeSpan StockTakingRefreshInterval { get; set; } = TimeSpan.FromMinutes(5);
    public TimeSpan PurchaseHistoryRefreshInterval { get; set; } = TimeSpan.FromMinutes(60);
    public TimeSpan LotsRefreshInterval { get; set; } = TimeSpan.FromMinutes(60);

    public TimeSpan EshopPricesRefreshInterval { get; set; } = TimeSpan.FromMinutes(30);
    public TimeSpan ErpPricesRefreshInterval { get; set; } = TimeSpan.FromMinutes(60);

    public int SalesHistoryDays { get; set; } = 400;
    public int PurchaseHistoryDays { get; set; } = 400;
    public int ConsumedHistoryDays { get; set; } = 720;
}
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Application.Features.Catalog.Model;
using MediatR;

namespace Anela.Heblo.Application.Features.Catalog;

public class RefreshErpPricesDataHandler : IRequestHandler<RefreshErpPricesDataRequest>
{
    private readonly ICatalogRepository _catalogRepository;

    public RefreshErpPricesDataHandler(ICatalogRepository catalogRepository)
    {
        _catalogRepository = catalogRepository;
    }

    public async Task Handle(RefreshErpPricesDataRequest request, CancellationToken cancellationToken)
    {
        await _catalogRepository.RefreshErpPricesData(cancellationToken);
    }
}
using Anela.Heblo.Domain.Features.Catalog;
using MediatR;
using Anela.Heblo.Application.Features.Catalog.Model;

namespace Anela.Heblo.Application.Features.Catalog;

public class RefreshTransportDataHandler : IRequestHandler<RefreshTransportDataRequest>
{
    private readonly ICatalogRepository _catalogRepository;

    public RefreshTransportDataHandler(ICatalogRepository catalogRepository)
    {
        _catalogRepository = catalogRepository;
    }

    public async Task Handle(RefreshTransportDataRequest request, CancellationToken cancellationToken)
    {
        await _catalogRepository.RefreshTransportData(cancellationToken);
    }
}
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Application.Features.Catalog.Model;
using MediatR;

namespace Anela.Heblo.Application.Features.Catalog;

public class RefreshLotsDataHandler : IRequestHandler<RefreshLotsDataRequest>
{
    private readonly ICatalogRepository _catalogRepository;

    public RefreshLotsDataHandler(ICatalogRepository catalogRepository)
    {
        _catalogRepository = catalogRepository;
    }

    public async Task Handle(RefreshLotsDataRequest request, CancellationToken cancellationToken)
    {
        await _catalogRepository.RefreshLotsData(cancellationToken);
    }
}
using System.Linq.Expressions;
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Domain.Features.Catalog.Attributes;
using Anela.Heblo.Domain.Features.Catalog.ConsumedMaterials;
using Anela.Heblo.Domain.Features.Catalog.Lots;
using Anela.Heblo.Domain.Features.Catalog.Price;
using Anela.Heblo.Domain.Features.Catalog.PurchaseHistory;
using Anela.Heblo.Domain.Features.Catalog.Sales;
using Anela.Heblo.Domain.Features.Catalog.Stock;
using Anela.Heblo.Domain.Features.Logistics.Transport;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace Anela.Heblo.Application.Features.Catalog;

public class CatalogRepository : ICatalogRepository
{
    private readonly ICatalogSalesClient _salesClient;
    private readonly ICatalogAttributesClient _attributesClient;
    private readonly IEshopStockClient _eshopStockClient;
    private readonly IConsumedMaterialsClient _consumedMaterialClient;
    private readonly IPurchaseHistoryClient _purchaseHistoryClient;
    private readonly IErpStockClient _erpStockClient;
    private readonly ILotsClient _lotsClient;
    private readonly IProductPriceEshopClient _productPriceEshopClient;
    private readonly IProductPriceErpClient _productPriceErpClient;
    private readonly ITransportBoxRepository _transportBoxRepository;
    private readonly IStockTakingRepository _stockTakingRepository;
    private readonly IMemoryCache _cache;
    private readonly TimeProvider _timeProvider;
    private readonly IOptions<CatalogRepositoryOptions> _options;
    private readonly ILogger<CatalogRepository> _logger;


    public CatalogRepository(
        ICatalogSalesClient salesClient,
        ICatalogAttributesClient attributesClient,
        IEshopStockClient eshopStockClient,
        IConsumedMaterialsClient consumedMaterialClient,
        IPurchaseHistoryClient purchaseHistoryClient,
        IErpStockClient erpStockClient,
        ILotsClient lotsClient,
        IProductPriceEshopClient productPriceEshopClient,
        IProductPriceErpClient productPriceErpClient,
        ITransportBoxRepository transportBoxRepository,
        IStockTakingRepository stockTakingRepository,
        IMemoryCache cache,
        TimeProvider timeProvider,
        IOptions<CatalogRepositoryOptions> _options,
        ILogger<CatalogRepository> logger)
    {
        _salesClient = salesClient;
        _attributesClient = attributesClient;
        _eshopStockClient = eshopStockClient;
        _consumedMaterialClient = consumedMaterialClient;
        _purchaseHistoryClient = purchaseHistoryClient;
        _erpStockClient = erpStockClient;
        _lotsClient = lotsClient;
        _productPriceEshopClient = productPriceEshopClient;
        _productPriceErpClient = productPriceErpClient;
        _transportBoxRepository = transportBoxRepository;
        _stockTakingRepository = stockTakingRepository;
        _cache = cache;
        _timeProvider = timeProvider;
        this._options = _options;
        _logger = logger;
    }


    // public async Task UpdateStockAsync(UpdateCatalogStockRequest updateRequest, CancellationToken cancellationToken = default)
    // {
    //     var product = CatalogData.FirstOrDefault(s => s.ProductCode == updateRequest.ProductCode);
    //
    //     if (product == null)
    //         return;
    //
    //     if (product.Stock.PrimaryStockSource == StockSource.Eshop && product.Stock.Eshop != updateRequest.OnStockEshop)
    //     {
    //         await RefreshEshopStockData(cancellationToken);
    //     }
    //     else if(product.Stock.PrimaryStockSource == StockSource.Erp && product.Stock.Erp != updateRequest.OnStockErp)
    //     {
    //         await RefreshErpStockData(cancellationToken);
    //     }
    //
    //     await RefreshLostData(cancellationToken);
    //     await RefreshStockTakingData(cancellationToken);
    // }

    public async Task RefreshTransportData(CancellationToken ct)
    {
        var transportData = await GetProductsInTransport(ct);
        CachedInTransportData = transportData;
    }

    public async Task RefreshReserveData(CancellationToken ct)
    {
        var reserveData = await GetProductsInReserve(ct);
        CachedInReserveData = reserveData;
    }

    public async Task RefreshSalesData(CancellationToken ct)
    {
        CachedSalesData = await _salesClient.GetAsync(_timeProvider.GetUtcNow().Date.AddDays(-1 * _options.Value.SalesHistoryDays),
            _timeProvider.GetUtcNow().Date, cancellationToken: ct);
    }

    public async Task RefreshAttributesData(CancellationToken ct)
    {
        CachedCatalogAttributesData = await _attributesClient.GetAttributesAsync(cancellationToken: ct);
    }

    public async Task RefreshErpStockData(CancellationToken ct)
    {
        CachedErpStockData = (await _erpStockClient.ListAsync(ct)).ToList();
    }

    public async Task RefreshEshopStockData(CancellationToken ct)
    {
        CachedEshopStockData = (await _eshopStockClient.ListAsync(ct)).ToList();
    }

    public async Task RefreshPurchaseHistoryData(CancellationToken ct)
    {
        CachedPurchaseHistoryData = (await _purchaseHistoryClient.GetHistoryAsync(null, _timeProvider.GetUtcNow().Date.AddDays(-1 * _options.Value.PurchaseHistoryDays), _timeProvider.GetUtcNow().Date, cancellationToken: ct))
            .ToList();
    }

    public async Task RefreshConsumedHistoryData(CancellationToken ct)
    {
        CachedConsumedData = (await _consumedMaterialClient.GetConsumedAsync(_timeProvider.GetUtcNow().Date.AddDays(-1 * _options.Value.ConsumedHistoryDays), _timeProvider.GetUtcNow().Date, cancellationToken: ct))
            .ToList();
    }

    public async Task RefreshStockTakingData(CancellationToken ct)
    {
        CachedStockTakingData = (await _stockTakingRepository.GetAllAsync(ct)).ToList();
    }

    public async Task RefreshLotsData(CancellationToken ct)
    {
        CachedLotsData = (await _lotsClient.GetAsync(cancellationToken: ct)).ToList();
    }

    public async Task RefreshEshopPricesData(CancellationToken ct)
    {
        CachedEshopPriceData = (await _productPriceEshopClient.GetAllAsync(ct)).ToList();
    }

    public async Task RefreshErpPricesData(CancellationToken ct)
    {
        CachedErpPriceData = (await _productPriceErpClient.GetAllAsync(false, ct)).ToList();
    }


    private List<CatalogAggregate> CatalogData => _cache.GetOrCreate(nameof(CatalogData), c => Merge())!;

    private List<CatalogAggregate> Merge()
    {
        var products = CachedErpStockData.Select(s => new CatalogAggregate()
        {
            ProductCode = s.ProductCode,
            ProductName = s.ProductName,
            ErpId = s.ProductId,
            Stock = new StockData()
            {
                Erp = s.Stock
            },
            Type = (ProductType?)s.ProductTypeId ?? ProductType.UNDEFINED,
            MinimalOrderQuantity = s.MOQ,
            HasLots = s.HasLots,
            HasExpiration = s.HasExpiration,
            Volume = s.Volume,
            Weight = s.Weight,
        }).ToList();

        var attributesMap = CachedCatalogAttributesData.ToDictionary(k => k.ProductCode, v => v);
        var eshopProductsMap = CachedEshopStockData.ToDictionary(k => k.Code, v => v);
        var consumedMap = CachedConsumedData
            .GroupBy(p => p.ProductCode)
            .ToDictionary(k => k.Key, v => v.ToList());
        var purchaseMap = CachedPurchaseHistoryData
            .GroupBy(p => p.ProductCode)
            .ToDictionary(k => k.Key, v => v.ToList());
        var stockTakingMap = CachedStockTakingData
            .GroupBy(p => p.Code)
            .ToDictionary(k => k.Key, v => v.ToList());
        var lotsMap = CachedLotsData
            .GroupBy(p => p.ProductCode)
            .ToDictionary(k => k.Key, v => v.ToList());
        var eshopPriceMap = CachedEshopPriceData.ToDictionary(k => k.ProductCode, v => v);
        var erpPriceMap = CachedErpPriceData.ToDictionary(k => k.ProductCode, v => v);

        foreach (var product in products)
        {
            product.SalesHistory = CachedSalesData.Where(w => w.ProductCode == product.ProductCode).ToList();

            if (attributesMap.TryGetValue(product.ProductCode, out var attributes))
            {
                product.Properties.OptimalStockDaysSetup = attributes.OptimalStockDays;
                product.Properties.StockMinSetup = attributes.StockMin;
                product.Properties.BatchSize = attributes.BatchSize;
                product.Properties.SeasonMonths = attributes.SeasonMonthsArray;
                product.MinimalManufactureQuantity = attributes.MinimalManufactureQuantity;
            }

            if (CachedInTransportData.TryGetValue(product.ProductCode, out var inTransport))
            {
                product.Stock.Transport = inTransport;
            }

            if (CachedInReserveData.TryGetValue(product.ProductCode, out var inReserve))
            {
                product.Stock.Reserve = inReserve;
            }

            if (eshopProductsMap.TryGetValue(product.ProductCode, out var eshopProduct))
            {
                product.Stock.Eshop = eshopProduct.Stock;
                product.Stock.PrimaryStockSource = StockSource.Eshop;
                product.Location = eshopProduct.Location;
            }

            if (consumedMap.TryGetValue(product.ProductCode, out var consumed))
            {
                product.ConsumedHistory = consumed.ToList();
            }

            if (purchaseMap.TryGetValue(product.ProductCode, out var purchases))
            {
                product.PurchaseHistory = purchases.ToList();
            }

            if (stockTakingMap.TryGetValue(product.ProductCode, out var stockTakings))
            {
                product.StockTakingHistory = stockTakings.OrderByDescending(o => o.Date).ToList();
            }

            if (lotsMap.TryGetValue(product.ProductCode, out var lots))
            {
                product.Stock.Lots = lots.ToList();
            }

            // Mapování eshop cen podle ProductCode
            if (eshopPriceMap.TryGetValue(product.ProductCode, out var eshopPrice))
            {
                product.EshopPrice = eshopPrice;
            }

            // Mapování ERP cen podle ProductCode
            if (erpPriceMap.TryGetValue(product.ProductCode, out var erpPrice))
            {
                product.ErpPrice = erpPrice;
            }
        }

        return products.ToList();
    }

    private void Invalidate()
    {
        _cache.Remove(nameof(CatalogData));
    }

    private IList<CatalogSaleRecord> CachedSalesData
    {
        get => _cache.Get<List<CatalogSaleRecord>>(nameof(CachedSalesData)) ?? new List<CatalogSaleRecord>();
        set
        {
            _cache.Set(nameof(CachedSalesData), value);
            Invalidate();
        }
    }



    private IList<CatalogAttributes> CachedCatalogAttributesData
    {
        get => _cache.Get<List<CatalogAttributes>>(nameof(CachedCatalogAttributesData)) ?? new List<CatalogAttributes>();
        set
        {
            _cache.Set(nameof(CachedCatalogAttributesData), value);
            Invalidate();
        }
    }
    private IDictionary<string, int> CachedInTransportData
    {
        get => _cache.Get<Dictionary<string, int>>(nameof(CachedInTransportData)) ?? new Dictionary<string, int>();
        set
        {
            _cache.Set(nameof(CachedInTransportData), value);
            Invalidate();
        }
    }

    private IDictionary<string, int> CachedInReserveData
    {
        get => _cache.Get<Dictionary<string, int>>(nameof(CachedInReserveData)) ?? new Dictionary<string, int>();
        set
        {
            _cache.Set(nameof(CachedInReserveData), value);
            Invalidate();
        }
    }

    private IList<ErpStock> CachedErpStockData
    {
        get => _cache.Get<List<ErpStock>>(nameof(CachedErpStockData)) ?? new List<ErpStock>();
        set
        {
            _cache.Set(nameof(CachedErpStockData), value);
            Invalidate();
        }
    }
    private IList<EshopStock> CachedEshopStockData
    {
        get => _cache.Get<List<EshopStock>>(nameof(CachedEshopStockData)) ?? new List<EshopStock>();
        set
        {
            _cache.Set(nameof(CachedEshopStockData), value);
            Invalidate();
        }
    }
    private IList<CatalogPurchaseRecord> CachedPurchaseHistoryData
    {
        get => _cache.Get<List<CatalogPurchaseRecord>>(nameof(CachedPurchaseHistoryData)) ?? new List<CatalogPurchaseRecord>();
        set
        {
            _cache.Set(nameof(CachedPurchaseHistoryData), value);
            Invalidate();
        }
    }
    private IList<ConsumedMaterialRecord> CachedConsumedData
    {
        get => _cache.Get<List<ConsumedMaterialRecord>>(nameof(CachedConsumedData)) ?? new List<ConsumedMaterialRecord>();
        set
        {
            _cache.Set(nameof(CachedConsumedData), value);
            Invalidate();
        }
    }

    private IList<StockTakingRecord> CachedStockTakingData
    {
        get => _cache.Get<List<StockTakingRecord>>(nameof(CachedStockTakingData)) ?? new List<StockTakingRecord>();
        set
        {
            _cache.Set(nameof(CachedStockTakingData), value);
            Invalidate();
        }
    }

    private IList<CatalogLot> CachedLotsData
    {
        get => _cache.Get<List<CatalogLot>>(nameof(CachedLotsData)) ?? new List<CatalogLot>();
        set
        {
            _cache.Set(nameof(CachedLotsData), value);
            Invalidate();
        }
    }

    private IList<ProductPriceEshop> CachedEshopPriceData
    {
        get => _cache.Get<List<ProductPriceEshop>>(nameof(CachedEshopPriceData)) ?? new List<ProductPriceEshop>();
        set
        {
            _cache.Set(nameof(CachedEshopPriceData), value);
            Invalidate();
        }
    }

    private IList<ProductPriceErp> CachedErpPriceData
    {
        get => _cache.Get<List<ProductPriceErp>>(nameof(CachedErpPriceData)) ?? new List<ProductPriceErp>();
        set
        {
            _cache.Set(nameof(CachedErpPriceData), value);
            Invalidate();
        }
    }


    private async Task<Dictionary<string, int>> GetProductsInTransport(CancellationToken ct)
    {
        var boxes = await _transportBoxRepository.FindAsync(TransportBox.IsInTransportPredicate, cancellationToken: ct);
        return boxes.SelectMany(s => s.Items)
            .GroupBy(g => g.ProductCode)
            .ToDictionary(k => k.Key, v => v.Sum(s => (int)s.Amount));
    }

    private async Task<Dictionary<string, int>> GetProductsInReserve(CancellationToken ct)
    {
        var boxes = await _transportBoxRepository.FindAsync(TransportBox.IsInReservePredicate, cancellationToken: ct);
        return boxes.SelectMany(s => s.Items)
            .GroupBy(g => g.ProductCode)
            .ToDictionary(k => k.Key, v => v.Sum(s => (int)s.Amount));
    }

    public Task<CatalogAggregate?> GetByIdAsync(string id, CancellationToken cancellationToken = default) => Task.FromResult(CatalogData.SingleOrDefault(s => s.ProductCode == id));
    public Task<IEnumerable<CatalogAggregate>> GetAllAsync(CancellationToken cancellationToken = default) => Task.FromResult(CatalogData.AsEnumerable());
    public Task<IEnumerable<CatalogAggregate>> FindAsync(Expression<Func<CatalogAggregate, bool>> predicate, CancellationToken cancellationToken = default) => Task.FromResult(CatalogData.AsQueryable().Where(predicate).AsEnumerable());
    public Task<CatalogAggregate?> SingleOrDefaultAsync(Expression<Func<CatalogAggregate, bool>> predicate, CancellationToken cancellationToken = default) => Task.FromResult(CatalogData.AsQueryable().SingleOrDefault(predicate));
    public Task<bool> AnyAsync(Expression<Func<CatalogAggregate, bool>> predicate, CancellationToken cancellationToken = default) => Task.FromResult(CatalogData.AsQueryable().Any(predicate));
    public Task<int> CountAsync(Expression<Func<CatalogAggregate, bool>>? predicate = null, CancellationToken cancellationToken = default) =>
        Task.FromResult(predicate == null ? CatalogData.Count : CatalogData.AsQueryable().Count(predicate));
}
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Application.Features.Catalog.Model;
using MediatR;

namespace Anela.Heblo.Application.Features.Catalog;

public class RefreshErpStockDataHandler : IRequestHandler<RefreshErpStockDataRequest>
{
    private readonly ICatalogRepository _catalogRepository;

    public RefreshErpStockDataHandler(ICatalogRepository catalogRepository)
    {
        _catalogRepository = catalogRepository;
    }

    public async Task Handle(RefreshErpStockDataRequest request, CancellationToken cancellationToken)
    {
        await _catalogRepository.RefreshErpStockData(cancellationToken);
    }
}
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Application.Features.Catalog.Model;
using MediatR;

namespace Anela.Heblo.Application.Features.Catalog;

public class RefreshPurchaseHistoryDataHandler : IRequestHandler<RefreshPurchaseHistoryDataRequest>
{
    private readonly ICatalogRepository _catalogRepository;

    public RefreshPurchaseHistoryDataHandler(ICatalogRepository catalogRepository)
    {
        _catalogRepository = catalogRepository;
    }

    public async Task Handle(RefreshPurchaseHistoryDataRequest request, CancellationToken cancellationToken)
    {
        await _catalogRepository.RefreshPurchaseHistoryData(cancellationToken);
    }
}
using Microsoft.Extensions.DependencyInjection;

namespace Anela.Heblo.Application.Features.Audit;

/// <summary>
/// Audit module for dependency injection registration
/// </summary>
public static class AuditModule
{
    /// <summary>
    /// Registers audit feature services
    /// </summary>
    public static IServiceCollection AddAuditModule(this IServiceCollection services)
    {
        // MediatR handlers are automatically registered by MediatR assembly scanning
        // No manual registration needed for handlers

        return services;
    }
}
using Anela.Heblo.Application.Features.Audit.Model;
using Anela.Heblo.Xcc.Audit;
using MediatR;
using Microsoft.Extensions.Logging;

namespace Anela.Heblo.Application.Features.Audit;

/// <summary>
/// Handler for retrieving data load audit logs
/// </summary>
public class GetAuditLogsHandler : IRequestHandler<GetAuditLogsRequest, GetAuditLogsResponse>
{
    private readonly IDataLoadAuditService _auditService;
    private readonly ILogger<GetAuditLogsHandler> _logger;

    public GetAuditLogsHandler(IDataLoadAuditService auditService, ILogger<GetAuditLogsHandler> logger)
    {
        _auditService = auditService ?? throw new ArgumentNullException(nameof(auditService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task<GetAuditLogsResponse> Handle(GetAuditLogsRequest request, CancellationToken cancellationToken)
    {
        try
        {
            _logger.LogInformation("Retrieving data load audit logs with limit: {Limit}, fromDate: {FromDate}, toDate: {ToDate}",
                request.Limit, request.FromDate, request.ToDate);

            var auditLogs = await _auditService.GetAuditLogsAsync(request.Limit, request.FromDate, request.ToDate);

            var response = new GetAuditLogsResponse
            {
                Count = auditLogs.Count,
                Logs = auditLogs
            };

            _logger.LogDebug("Retrieved {Count} audit logs successfully", response.Count);

            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving data load audit logs");
            throw;
        }
    }
}
using MediatR;

namespace Anela.Heblo.Application.Features.Audit.Model;

/// <summary>
/// Request for getting data load audit logs
/// </summary>
public class GetAuditLogsRequest : IRequest<GetAuditLogsResponse>
{
    /// <summary>
    /// Maximum number of logs to return (default: 100)
    /// </summary>
    public int? Limit { get; set; } = 100;

    /// <summary>
    /// Filter logs from this date (inclusive)
    /// </summary>
    public DateTime? FromDate { get; set; }

    /// <summary>
    /// Filter logs to this date (inclusive)
    /// </summary>
    public DateTime? ToDate { get; set; }
}
namespace Anela.Heblo.Application.Features.Audit.Model;

/// <summary>
/// Response containing audit summary statistics
/// </summary>
public class GetAuditSummaryResponse
{
    /// <summary>
    /// Period start date for the summary
    /// </summary>
    public DateTime? PeriodFrom { get; set; }

    /// <summary>
    /// Period end date for the summary
    /// </summary>
    public DateTime? PeriodTo { get; set; }

    /// <summary>
    /// Summary statistics grouped by data type and source
    /// </summary>
    public IReadOnlyList<AuditSummaryItem> Summary { get; set; } = new List<AuditSummaryItem>();
}

/// <summary>
/// Summary statistics for a specific data type and source combination
/// </summary>
public class AuditSummaryItem
{
    /// <summary>
    /// Type of data (Stock, Purchase History, etc.)
    /// </summary>
    public string DataType { get; set; } = string.Empty;

    /// <summary>
    /// Source of data (Flexi ERP, Shoptet E-shop, etc.)
    /// </summary>
    public string Source { get; set; } = string.Empty;

    /// <summary>
    /// Total number of requests made
    /// </summary>
    public int TotalRequests { get; set; }

    /// <summary>
    /// Number of successful requests
    /// </summary>
    public int SuccessfulRequests { get; set; }

    /// <summary>
    /// Number of failed requests
    /// </summary>
    public int FailedRequests { get; set; }

    /// <summary>
    /// Total number of records loaded successfully
    /// </summary>
    public int TotalRecords { get; set; }

    /// <summary>
    /// Average duration of successful requests in milliseconds
    /// </summary>
    public double AverageDuration { get; set; }

    /// <summary>
    /// Timestamp of the last successful load
    /// </summary>
    public DateTime? LastSuccessfulLoad { get; set; }

    /// <summary>
    /// Timestamp of the last failed load
    /// </summary>
    public DateTime? LastFailedLoad { get; set; }
}
using Anela.Heblo.Xcc.Audit;

namespace Anela.Heblo.Application.Features.Audit.Model;

/// <summary>
/// Response containing audit logs
/// </summary>
public class GetAuditLogsResponse
{
    /// <summary>
    /// Number of audit logs returned
    /// </summary>
    public int Count { get; set; }

    /// <summary>
    /// List of audit log entries
    /// </summary>
    public IReadOnlyList<DataLoadAuditEntry> Logs { get; set; } = new List<DataLoadAuditEntry>();
}
using MediatR;

namespace Anela.Heblo.Application.Features.Audit.Model;

/// <summary>
/// Request for getting audit summary statistics
/// </summary>
public class GetAuditSummaryRequest : IRequest<GetAuditSummaryResponse>
{
    /// <summary>
    /// Filter summary from this date (inclusive)
    /// </summary>
    public DateTime? FromDate { get; set; }

    /// <summary>
    /// Filter summary to this date (inclusive)
    /// </summary>
    public DateTime? ToDate { get; set; }
}
using Anela.Heblo.Application.Features.Audit.Model;
using Anela.Heblo.Xcc.Audit;
using MediatR;
using Microsoft.Extensions.Logging;

namespace Anela.Heblo.Application.Features.Audit;

/// <summary>
/// Handler for retrieving audit summary statistics
/// </summary>
public class GetAuditSummaryHandler : IRequestHandler<GetAuditSummaryRequest, GetAuditSummaryResponse>
{
    private readonly IDataLoadAuditService _auditService;
    private readonly ILogger<GetAuditSummaryHandler> _logger;

    public GetAuditSummaryHandler(IDataLoadAuditService auditService, ILogger<GetAuditSummaryHandler> logger)
    {
        _auditService = auditService ?? throw new ArgumentNullException(nameof(auditService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task<GetAuditSummaryResponse> Handle(GetAuditSummaryRequest request, CancellationToken cancellationToken)
    {
        try
        {
            _logger.LogInformation("Retrieving audit summary for period fromDate: {FromDate}, toDate: {ToDate}",
                request.FromDate, request.ToDate);

            var auditLogs = await _auditService.GetAuditLogsAsync(null, request.FromDate, request.ToDate);

            var summary = auditLogs
                .GroupBy(x => new { x.DataType, x.Source })
                .Select(g => new AuditSummaryItem
                {
                    DataType = g.Key.DataType,
                    Source = g.Key.Source,
                    TotalRequests = g.Count(),
                    SuccessfulRequests = g.Count(x => x.Success),
                    FailedRequests = g.Count(x => !x.Success),
                    TotalRecords = g.Where(x => x.Success).Sum(x => x.RecordCount),
                    AverageDuration = g.Where(x => x.Success).Any()
                        ? g.Where(x => x.Success).Average(x => x.Duration.TotalMilliseconds)
                        : 0,
                    LastSuccessfulLoad = g.Where(x => x.Success).Max(x => (DateTime?)x.Timestamp),
                    LastFailedLoad = g.Where(x => !x.Success).Max(x => (DateTime?)x.Timestamp)
                })
                .OrderBy(x => x.DataType)
                .ThenBy(x => x.Source)
                .ToList();

            var response = new GetAuditSummaryResponse
            {
                PeriodFrom = request.FromDate,
                PeriodTo = request.ToDate,
                Summary = summary
            };

            _logger.LogDebug("Generated audit summary with {SummaryCount} items", summary.Count);

            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving audit summary");
            throw;
        }
    }
}
using System.Security.Claims;
using Anela.Heblo.Domain.Features.Users;
using Microsoft.AspNetCore.Http;

namespace Anela.Heblo.Application.Features.Users;

public class CurrentUserService : ICurrentUserService
{
    private readonly IHttpContextAccessor _httpContextAccessor;

    public CurrentUserService(IHttpContextAccessor httpContextAccessor)
    {
        _httpContextAccessor = httpContextAccessor;
    }

    public CurrentUser GetCurrentUser()
    {
        var user = _httpContextAccessor.HttpContext?.User;
        var isAuthenticated = user?.Identity?.IsAuthenticated ?? false;

        var name = user?.Identity?.Name
                   ?? user?.FindFirst(ClaimTypes.Name)?.Value
                   ?? user?.FindFirst("name")?.Value
                   ?? (isAuthenticated ? "Unknown User" : "Anonymous");

        var id = user?.FindFirst(ClaimTypes.NameIdentifier)?.Value
                 ?? user?.FindFirst("sub")?.Value;

        var email = user?.FindFirst(ClaimTypes.Email)?.Value
                    ?? user?.FindFirst("email")?.Value;

        return new CurrentUser(
            Id: id,
            Name: name,
            Email: email,
            IsAuthenticated: isAuthenticated
        );
    }
}
using MediatR;
using Microsoft.Extensions.Logging;
using Anela.Heblo.Application.Features.Purchase.Model;
using Anela.Heblo.Domain.Features.Purchase;

namespace Anela.Heblo.Application.Features.Purchase;

public class UpdatePurchaseOrderHandler : IRequestHandler<UpdatePurchaseOrderRequest, UpdatePurchaseOrderResponse?>
{
    private readonly ILogger<UpdatePurchaseOrderHandler> _logger;
    private readonly IPurchaseOrderRepository _repository;

    public UpdatePurchaseOrderHandler(
        ILogger<UpdatePurchaseOrderHandler> logger,
        IPurchaseOrderRepository repository)
    {
        _logger = logger;
        _repository = repository;
    }

    public async Task<UpdatePurchaseOrderResponse?> Handle(UpdatePurchaseOrderRequest request, CancellationToken cancellationToken)
    {
        _logger.LogInformation("Updating purchase order {Id}", request.Id);

        var purchaseOrder = await _repository.GetByIdWithDetailsAsync(request.Id, cancellationToken);

        if (purchaseOrder == null)
        {
            _logger.LogWarning("Purchase order not found for ID {Id}", request.Id);
            return null;
        }

        try
        {
            purchaseOrder.Update(request.ExpectedDeliveryDate, request.Notes, "System"); // TODO: Get actual user

            var existingLineIds = purchaseOrder.Lines.Select(l => l.Id).ToHashSet();
            var requestLineIds = request.Lines.Where(l => l.Id.HasValue).Select(l => l.Id!.Value).ToHashSet();

            var linesToRemove = existingLineIds.Except(requestLineIds).ToList();
            foreach (var lineId in linesToRemove)
            {
                purchaseOrder.RemoveLine(lineId);
            }

            foreach (var lineRequest in request.Lines)
            {
                if (lineRequest.Id.HasValue)
                {
                    purchaseOrder.UpdateLine(
                        lineRequest.Id.Value,
                        lineRequest.Quantity,
                        lineRequest.UnitPrice,
                        lineRequest.Notes);
                }
                else
                {
                    purchaseOrder.AddLine(
                        lineRequest.MaterialId,
                        lineRequest.Quantity,
                        lineRequest.UnitPrice,
                        lineRequest.Notes);
                }
            }

            await _repository.UpdateAsync(purchaseOrder, cancellationToken);
            await _repository.SaveChangesAsync(cancellationToken);

            _logger.LogInformation("Purchase order {OrderNumber} updated successfully", purchaseOrder.OrderNumber);

            return new UpdatePurchaseOrderResponse(
                purchaseOrder.Id,
                purchaseOrder.OrderNumber,
                purchaseOrder.SupplierId,
                purchaseOrder.OrderDate,
                purchaseOrder.ExpectedDeliveryDate,
                purchaseOrder.Status.ToString(),
                purchaseOrder.Notes,
                purchaseOrder.TotalAmount,
                purchaseOrder.Lines.Select(l => new PurchaseOrderLineDto(
                    l.Id,
                    l.MaterialId,
                    "Unknown Material", // TODO: Join with material catalog
                    l.Quantity,
                    l.UnitPrice,
                    l.LineTotal,
                    l.Notes
                )).ToList(),
                purchaseOrder.UpdatedAt,
                purchaseOrder.UpdatedBy
            );
        }
        catch (InvalidOperationException ex)
        {
            _logger.LogWarning("Cannot update purchase order {OrderNumber}: {Message}", 
                purchaseOrder.OrderNumber, ex.Message);
            throw;
        }
    }
}
using MediatR;
using Microsoft.Extensions.Logging;
using Anela.Heblo.Application.Features.Purchase.Model;
using Anela.Heblo.Domain.Features.Purchase;

namespace Anela.Heblo.Application.Features.Purchase;

public class CreatePurchaseOrderHandler : IRequestHandler<CreatePurchaseOrderRequest, CreatePurchaseOrderResponse>
{
    private readonly ILogger<CreatePurchaseOrderHandler> _logger;
    private readonly IPurchaseOrderRepository _repository;
    private readonly IPurchaseOrderNumberGenerator _orderNumberGenerator;

    public CreatePurchaseOrderHandler(
        ILogger<CreatePurchaseOrderHandler> logger,
        IPurchaseOrderRepository repository,
        IPurchaseOrderNumberGenerator orderNumberGenerator)
    {
        _logger = logger;
        _repository = repository;
        _orderNumberGenerator = orderNumberGenerator;
    }

    public async Task<CreatePurchaseOrderResponse> Handle(CreatePurchaseOrderRequest request, CancellationToken cancellationToken)
    {
        _logger.LogInformation("Creating new purchase order for supplier {SupplierId}", request.SupplierId);

        var orderNumber = await _orderNumberGenerator.GenerateOrderNumberAsync(request.OrderDate, cancellationToken);
        
        var purchaseOrder = new PurchaseOrder(
            orderNumber,
            request.SupplierId,
            request.OrderDate,
            request.ExpectedDeliveryDate,
            request.Notes,
            "System"); // TODO: Get actual user from context

        foreach (var lineRequest in request.Lines)
        {
            purchaseOrder.AddLine(
                lineRequest.MaterialId,
                lineRequest.Quantity,
                lineRequest.UnitPrice,
                lineRequest.Notes);
        }

        await _repository.AddAsync(purchaseOrder, cancellationToken);
        await _repository.SaveChangesAsync(cancellationToken);

        _logger.LogInformation("Purchase order {OrderNumber} created successfully with ID {Id}", 
            orderNumber, purchaseOrder.Id);

        return MapToResponse(purchaseOrder);
    }

    private static CreatePurchaseOrderResponse MapToResponse(PurchaseOrder purchaseOrder)
    {
        return new CreatePurchaseOrderResponse(
            purchaseOrder.Id,
            purchaseOrder.OrderNumber,
            purchaseOrder.SupplierId,
            purchaseOrder.OrderDate,
            purchaseOrder.ExpectedDeliveryDate,
            purchaseOrder.Status.ToString(),
            purchaseOrder.Notes,
            purchaseOrder.TotalAmount,
            purchaseOrder.Lines.Select(l => new PurchaseOrderLineDto(
                l.Id,
                l.MaterialId,
                "Unknown Material", // TODO: Join with material catalog
                l.Quantity,
                l.UnitPrice,
                l.LineTotal,
                l.Notes
            )).ToList(),
            purchaseOrder.CreatedAt,
            purchaseOrder.CreatedBy
        );
    }
}
using MediatR;
using Microsoft.Extensions.Logging;
using Anela.Heblo.Application.Features.Purchase.Model;
using Anela.Heblo.Domain.Features.Purchase;

namespace Anela.Heblo.Application.Features.Purchase;

public class GetPurchaseOrdersHandler : IRequestHandler<GetPurchaseOrdersRequest, GetPurchaseOrdersResponse>
{
    private readonly ILogger<GetPurchaseOrdersHandler> _logger;
    private readonly IPurchaseOrderRepository _repository;

    public GetPurchaseOrdersHandler(
        ILogger<GetPurchaseOrdersHandler> logger,
        IPurchaseOrderRepository repository)
    {
        _logger = logger;
        _repository = repository;
    }

    public async Task<GetPurchaseOrdersResponse> Handle(GetPurchaseOrdersRequest request, CancellationToken cancellationToken)
    {
        _logger.LogInformation("Getting purchase orders with filters - SearchTerm: {SearchTerm}, Status: {Status}, Page: {PageNumber}/{PageSize}",
            request.SearchTerm, request.Status, request.PageNumber, request.PageSize);

        var (orders, totalCount) = await _repository.GetPaginatedAsync(
            request.SearchTerm,
            request.Status,
            request.FromDate,
            request.ToDate,
            request.SupplierId,
            request.PageNumber,
            request.PageSize,
            request.SortBy,
            request.SortDescending,
            cancellationToken);

        var totalPages = (int)Math.Ceiling((double)totalCount / request.PageSize);

        var orderSummaries = orders.Select(order => new PurchaseOrderSummaryDto(
            order.Id,
            order.OrderNumber,
            order.SupplierId,
            "Unknown Supplier", // TODO: Join with supplier catalog
            order.OrderDate,
            order.ExpectedDeliveryDate,
            order.Status.ToString(),
            order.TotalAmount,
            order.Lines.Count,
            order.CreatedAt,
            order.CreatedBy
        )).ToList();

        _logger.LogInformation("Found {Count} purchase orders out of {TotalCount} total", 
            orders.Count, totalCount);

        return new GetPurchaseOrdersResponse(
            orderSummaries,
            totalCount,
            request.PageNumber,
            request.PageSize,
            totalPages
        );
    }
}
using MediatR;
using Microsoft.Extensions.Logging;
using Anela.Heblo.Application.Features.Purchase.Model;
using Anela.Heblo.Domain.Features.Purchase;

namespace Anela.Heblo.Application.Features.Purchase;

public class UpdatePurchaseOrderStatusHandler : IRequestHandler<UpdatePurchaseOrderStatusRequest, UpdatePurchaseOrderStatusResponse?>
{
    private readonly ILogger<UpdatePurchaseOrderStatusHandler> _logger;
    private readonly IPurchaseOrderRepository _repository;

    public UpdatePurchaseOrderStatusHandler(
        ILogger<UpdatePurchaseOrderStatusHandler> logger,
        IPurchaseOrderRepository repository)
    {
        _logger = logger;
        _repository = repository;
    }

    public async Task<UpdatePurchaseOrderStatusResponse?> Handle(UpdatePurchaseOrderStatusRequest request, CancellationToken cancellationToken)
    {
        _logger.LogInformation("Updating purchase order status for ID {Id} to {Status}", request.Id, request.Status);

        var purchaseOrder = await _repository.GetByIdAsync(request.Id, cancellationToken);

        if (purchaseOrder == null)
        {
            _logger.LogWarning("Purchase order not found for ID {Id}", request.Id);
            return null;
        }

        if (!Enum.TryParse<PurchaseOrderStatus>(request.Status, out var newStatus))
        {
            _logger.LogWarning("Invalid status {Status} for purchase order {OrderNumber}", 
                request.Status, purchaseOrder.OrderNumber);
            throw new ArgumentException($"Invalid status: {request.Status}");
        }

        try
        {
            purchaseOrder.ChangeStatus(newStatus, "System"); // TODO: Get actual user from context

            await _repository.UpdateAsync(purchaseOrder, cancellationToken);
            await _repository.SaveChangesAsync(cancellationToken);

            _logger.LogInformation("Purchase order {OrderNumber} status updated to {Status}", 
                purchaseOrder.OrderNumber, newStatus);

            return new UpdatePurchaseOrderStatusResponse(
                purchaseOrder.Id,
                purchaseOrder.OrderNumber,
                purchaseOrder.Status.ToString(),
                purchaseOrder.UpdatedAt,
                purchaseOrder.UpdatedBy
            );
        }
        catch (InvalidOperationException ex)
        {
            _logger.LogWarning("Cannot update status for purchase order {OrderNumber}: {Message}", 
                purchaseOrder.OrderNumber, ex.Message);
            throw;
        }
    }
}
namespace Anela.Heblo.Application.Features.Purchase.Model;

public record UpdatePurchaseOrderResponse(
    Guid Id,
    string OrderNumber,
    Guid SupplierId,
    DateTime OrderDate,
    DateTime? ExpectedDeliveryDate,
    string Status,
    string? Notes,
    decimal TotalAmount,
    List<PurchaseOrderLineDto> Lines,
    DateTime? UpdatedAt,
    string? UpdatedBy
);
using MediatR;

namespace Anela.Heblo.Application.Features.Purchase.Model;

public record CreatePurchaseOrderRequest(
    Guid SupplierId,
    DateTime OrderDate,
    DateTime? ExpectedDeliveryDate,
    string? Notes,
    List<CreatePurchaseOrderLineRequest> Lines
) : IRequest<CreatePurchaseOrderResponse>;

public record CreatePurchaseOrderLineRequest(
    Guid MaterialId,
    decimal Quantity,
    decimal UnitPrice,
    string? Notes
);
namespace Anela.Heblo.Application.Features.Purchase.Model;

public record UpdatePurchaseOrderStatusResponse(
    Guid Id,
    string OrderNumber,
    string Status,
    DateTime? UpdatedAt,
    string? UpdatedBy
);
using MediatR;

namespace Anela.Heblo.Application.Features.Purchase.Model;

public record GetPurchaseOrdersRequest(
    string? SearchTerm = null,
    string? Status = null,
    DateTime? FromDate = null,
    DateTime? ToDate = null,
    Guid? SupplierId = null,
    int PageNumber = 1,
    int PageSize = 20,
    string SortBy = "OrderDate",
    bool SortDescending = true
) : IRequest<GetPurchaseOrdersResponse>;
using MediatR;

namespace Anela.Heblo.Application.Features.Purchase.Model;

public record UpdatePurchaseOrderRequest(
    Guid Id,
    DateTime? ExpectedDeliveryDate,
    string? Notes,
    List<UpdatePurchaseOrderLineRequest> Lines
) : IRequest<UpdatePurchaseOrderResponse>;

public record UpdatePurchaseOrderLineRequest(
    Guid? Id,
    Guid MaterialId,
    decimal Quantity,
    decimal UnitPrice,
    string? Notes
);
namespace Anela.Heblo.Application.Features.Purchase.Model;

public record CreatePurchaseOrderResponse(
    Guid Id,
    string OrderNumber,
    Guid SupplierId,
    DateTime OrderDate,
    DateTime? ExpectedDeliveryDate,
    string Status,
    string? Notes,
    decimal TotalAmount,
    List<PurchaseOrderLineDto> Lines,
    DateTime CreatedAt,
    string CreatedBy
);
namespace Anela.Heblo.Application.Features.Purchase.Model;

public record GetPurchaseOrdersResponse(
    List<PurchaseOrderSummaryDto> Orders,
    int TotalCount,
    int PageNumber,
    int PageSize,
    int TotalPages
);

public record PurchaseOrderSummaryDto(
    Guid Id,
    string OrderNumber,
    Guid SupplierId,
    string SupplierName,
    DateTime OrderDate,
    DateTime? ExpectedDeliveryDate,
    string Status,
    decimal TotalAmount,
    int LineCount,
    DateTime CreatedAt,
    string CreatedBy
);
namespace Anela.Heblo.Application.Features.Purchase.Model;

public record GetPurchaseOrderByIdResponse(
    Guid Id,
    string OrderNumber,
    Guid SupplierId,
    string SupplierName,
    DateTime OrderDate,
    DateTime? ExpectedDeliveryDate,
    string Status,
    string? Notes,
    decimal TotalAmount,
    List<PurchaseOrderLineDto> Lines,
    List<PurchaseOrderHistoryDto> History,
    DateTime CreatedAt,
    string CreatedBy,
    DateTime? UpdatedAt,
    string? UpdatedBy
);

public record PurchaseOrderLineDto(
    Guid Id,
    Guid MaterialId,
    string MaterialName,
    decimal Quantity,
    decimal UnitPrice,
    decimal LineTotal,
    string? Notes
);

public record PurchaseOrderHistoryDto(
    Guid Id,
    string Action,
    string? OldValue,
    string? NewValue,
    DateTime ChangedAt,
    string ChangedBy
);
using MediatR;

namespace Anela.Heblo.Application.Features.Purchase.Model;

public record GetPurchaseOrderByIdRequest(Guid Id) : IRequest<GetPurchaseOrderByIdResponse>;
using MediatR;

namespace Anela.Heblo.Application.Features.Purchase.Model;

public record UpdatePurchaseOrderStatusRequest(
    Guid Id,
    string Status
) : IRequest<UpdatePurchaseOrderStatusResponse>;
using Microsoft.Extensions.DependencyInjection;
using Anela.Heblo.Application.Features.Purchase.Infrastructure;
using Anela.Heblo.Domain.Features.Purchase;

namespace Anela.Heblo.Application.Features.Purchase;

public static class PurchaseModule
{
    public static IServiceCollection AddPurchaseModule(this IServiceCollection services)
    {
        services.AddScoped<IPurchaseOrderRepository, PurchaseOrderRepository>();
        services.AddScoped<IPurchaseOrderNumberGenerator, PurchaseOrderNumberGenerator>();

        return services;
    }
}
using Anela.Heblo.Domain.Features.Purchase;
using Microsoft.EntityFrameworkCore;
using Anela.Heblo.Persistence;
using Anela.Heblo.Persistence.Repository;

namespace Anela.Heblo.Application.Features.Purchase.Infrastructure;

public class PurchaseOrderRepository : BaseRepository<PurchaseOrder, Guid>, IPurchaseOrderRepository
{
    public PurchaseOrderRepository(ApplicationDbContext context) : base(context)
    {
    }

    public async Task<(List<PurchaseOrder> Orders, int TotalCount)> GetPaginatedAsync(
        string? searchTerm,
        string? status,
        DateTime? fromDate,
        DateTime? toDate,
        Guid? supplierId,
        int pageNumber,
        int pageSize,
        string sortBy,
        bool sortDescending,
        CancellationToken cancellationToken = default)
    {
        var query = DbSet.AsQueryable();

        if (!string.IsNullOrWhiteSpace(searchTerm))
        {
            query = query.Where(x => 
                x.OrderNumber.Contains(searchTerm) ||
                (x.Notes != null && x.Notes.Contains(searchTerm)));
        }

        if (!string.IsNullOrWhiteSpace(status) && Enum.TryParse<PurchaseOrderStatus>(status, out var statusEnum))
        {
            query = query.Where(x => x.Status == statusEnum);
        }

        if (fromDate.HasValue)
        {
            query = query.Where(x => x.OrderDate >= fromDate.Value);
        }

        if (toDate.HasValue)
        {
            query = query.Where(x => x.OrderDate <= toDate.Value);
        }

        if (supplierId.HasValue)
        {
            query = query.Where(x => x.SupplierId == supplierId.Value);
        }

        var totalCount = await query.CountAsync(cancellationToken);

        query = sortBy.ToLowerInvariant() switch
        {
            "ordernumber" => sortDescending ? query.OrderByDescending(x => x.OrderNumber) : query.OrderBy(x => x.OrderNumber),
            "orderdate" => sortDescending ? query.OrderByDescending(x => x.OrderDate) : query.OrderBy(x => x.OrderDate),
            "status" => sortDescending ? query.OrderByDescending(x => x.Status) : query.OrderBy(x => x.Status),
            "totalamount" => sortDescending ? query.OrderByDescending(x => x.Lines.Sum(l => l.LineTotal)) : query.OrderBy(x => x.Lines.Sum(l => l.LineTotal)),
            "createdat" => sortDescending ? query.OrderByDescending(x => x.CreatedAt) : query.OrderBy(x => x.CreatedAt),
            _ => sortDescending ? query.OrderByDescending(x => x.OrderDate) : query.OrderBy(x => x.OrderDate)
        };

        var orders = await query
            .Include(x => x.Lines)
            .Skip((pageNumber - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync(cancellationToken);

        return (orders, totalCount);
    }

    public async Task<PurchaseOrder?> GetByIdWithDetailsAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await DbSet
            .Include(x => x.Lines)
            .Include(x => x.History)
            .FirstOrDefaultAsync(x => x.Id == id, cancellationToken);
    }

    public async Task<bool> OrderNumberExistsAsync(string orderNumber, CancellationToken cancellationToken = default)
    {
        return await DbSet.AnyAsync(x => x.OrderNumber == orderNumber, cancellationToken);
    }
}
using MediatR;
using Microsoft.Extensions.Logging;
using Anela.Heblo.Application.Features.Purchase.Model;
using Anela.Heblo.Domain.Features.Purchase;

namespace Anela.Heblo.Application.Features.Purchase;

public class GetPurchaseOrderByIdHandler : IRequestHandler<GetPurchaseOrderByIdRequest, GetPurchaseOrderByIdResponse?>
{
    private readonly ILogger<GetPurchaseOrderByIdHandler> _logger;
    private readonly IPurchaseOrderRepository _repository;

    public GetPurchaseOrderByIdHandler(
        ILogger<GetPurchaseOrderByIdHandler> logger,
        IPurchaseOrderRepository repository)
    {
        _logger = logger;
        _repository = repository;
    }

    public async Task<GetPurchaseOrderByIdResponse?> Handle(GetPurchaseOrderByIdRequest request, CancellationToken cancellationToken)
    {
        _logger.LogInformation("Getting purchase order details for ID {Id}", request.Id);

        var purchaseOrder = await _repository.GetByIdWithDetailsAsync(request.Id, cancellationToken);

        if (purchaseOrder == null)
        {
            _logger.LogWarning("Purchase order not found for ID {Id}", request.Id);
            return null;
        }

        _logger.LogInformation("Found purchase order {OrderNumber} with {LineCount} lines and {HistoryCount} history entries",
            purchaseOrder.OrderNumber, purchaseOrder.Lines.Count, purchaseOrder.History.Count);

        return new GetPurchaseOrderByIdResponse(
            purchaseOrder.Id,
            purchaseOrder.OrderNumber,
            purchaseOrder.SupplierId,
            "Unknown Supplier", // TODO: Join with supplier catalog
            purchaseOrder.OrderDate,
            purchaseOrder.ExpectedDeliveryDate,
            purchaseOrder.Status.ToString(),
            purchaseOrder.Notes,
            purchaseOrder.TotalAmount,
            purchaseOrder.Lines.Select(l => new PurchaseOrderLineDto(
                l.Id,
                l.MaterialId,
                "Unknown Material", // TODO: Join with material catalog
                l.Quantity,
                l.UnitPrice,
                l.LineTotal,
                l.Notes
            )).ToList(),
            purchaseOrder.History.Select(h => new PurchaseOrderHistoryDto(
                h.Id,
                h.Action,
                h.OldValue,
                h.NewValue,
                h.ChangedAt,
                h.ChangedBy
            )).OrderByDescending(h => h.ChangedAt).ToList(),
            purchaseOrder.CreatedAt,
            purchaseOrder.CreatedBy,
            purchaseOrder.UpdatedAt,
            purchaseOrder.UpdatedBy
        );
    }
}
using Anela.Heblo.Application.Features.Weather.Model;
using Anela.Heblo.Domain.Features.Weather.Domain;
using Microsoft.Extensions.Logging;
using MediatR;

namespace Anela.Heblo.Application.Features.Weather;

public class GetWeatherForecastHandler : IRequestHandler<GetWeatherForecastRequest, IEnumerable<GetWeatherForecastResponse>>
{
    private readonly ILogger<GetWeatherForecastHandler> _logger;
    private readonly TimeProvider _timeProvider;

    public GetWeatherForecastHandler(ILogger<GetWeatherForecastHandler> logger, TimeProvider timeProvider)
    {
        _logger = logger;
        _timeProvider = timeProvider;
    }

    public async Task<IEnumerable<GetWeatherForecastResponse>> Handle(GetWeatherForecastRequest request, CancellationToken cancellationToken)
    {
        _logger.LogInformation("Handling GetWeatherForecast request - generating forecast for {Days} days", WeatherConstants.FORECAST_DAYS);

        var forecast = Enumerable.Range(1, WeatherConstants.FORECAST_DAYS).Select(index =>
            new GetWeatherForecastResponse
            {
                Date = _timeProvider.GetLocalNow().DateTime.AddDays(index),
                TemperatureC = Random.Shared.Next(WeatherConstants.MIN_TEMPERATURE, WeatherConstants.MAX_TEMPERATURE),
                Summary = WeatherConstants.WEATHER_SUMMARIES[Random.Shared.Next(WeatherConstants.WEATHER_SUMMARIES.Length)]
            });

        return await Task.FromResult(forecast);
    }
}
using Microsoft.Extensions.DependencyInjection;

namespace Anela.Heblo.Application.Features.Weather;

public static class WeatherModule
{
    public static IServiceCollection AddWeatherModule(this IServiceCollection services)
    {
        // MediatR handlers are automatically registered by MediatR assembly scanning
        // No manual registration needed for handlers

        return services;
    }
}
using MediatR;

namespace Anela.Heblo.Application.Features.Weather.Model;

public record GetWeatherForecastRequest : IRequest<IEnumerable<GetWeatherForecastResponse>>
{
    // Empty request for now - could add parameters like days, location etc.
}
namespace Anela.Heblo.Application.Features.Weather.Model;

public record GetWeatherForecastResponse
{
    public DateTime Date { get; init; }
    public int TemperatureC { get; init; }
    public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
    public string? Summary { get; init; }
}
using Anela.Heblo.Application.Features.Weather;
using Anela.Heblo.Application.Features.Configuration;
using Anela.Heblo.Application.Features.Audit;
using Anela.Heblo.Application.Features.Catalog;
using Anela.Heblo.Application.Features.Purchase;
using Microsoft.Extensions.DependencyInjection;

namespace Anela.Heblo.Application;

/// <summary>
/// Main application module registration
/// </summary>
public static class ApplicationModule
{
    public static IServiceCollection AddApplicationServices(this IServiceCollection services)
    {
        // Register MediatR
        services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(ApplicationModule).Assembly));

        // Register AutoMapper
        services.AddAutoMapper(typeof(ApplicationModule).Assembly);

        // Register all feature modules
        services.AddWeatherModule();
        services.AddConfigurationModule();
        services.AddAuditModule();
        services.AddCatalogModule();
        services.AddPurchaseModule();
        // services.AddOrdersModule();
        // services.AddInvoicesModule();
        // services.AddManufactureModule();
        // services.AddTransportModule();

        return services;
    }
}
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Anela.Heblo.API.Client")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+6cd183ef4ac33ad09cbb7ecd6a8b9c35891c45cb")]
[assembly: System.Reflection.AssemblyProductAttribute("Anela.Heblo.API.Client")]
[assembly: System.Reflection.AssemblyTitleAttribute("Anela.Heblo.API.Client")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Anela.Heblo.Adapters.Comgate")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+6cd183ef4ac33ad09cbb7ecd6a8b9c35891c45cb")]
[assembly: System.Reflection.AssemblyProductAttribute("Anela.Heblo.Adapters.Comgate")]
[assembly: System.Reflection.AssemblyTitleAttribute("Anela.Heblo.Adapters.Comgate")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
namespace Anela.Heblo.Adapters.Comgate;

public class ComgateSettings
{
    public static string ConfigurationKey { get; set; } = "Comgate";

    public string MerchantId { get; set; }
    public string Secret { get; set; }
}
using System.Globalization;
using Anela.Heblo.Adapters.Comgate.Model;
using Anela.Heblo.Application.Domain.Bank;
using Anela.Heblo.Domain.Features.Bank;
using Microsoft.Extensions.Options;

namespace Anela.Heblo.Adapters.Comgate;

public class ComgateBankClient : IBankClient
{
    private readonly HttpClient _httpClient;
    private readonly ComgateSettings _settings;

    private static string GetStatementsUrlTemplate =
        "https://payments.comgate.cz/v1.0/transferList?merchant={0}&secret={1}&date={2}";
    private static string GetStatementUrlTemplate =
        "https://payments.comgate.cz/v1.0/aboSingleTransfer?merchant={0}&secret={1}&transferId={2}&download=true&type=v2";

    public ComgateBankClient(HttpClient httpClient, IOptions<ComgateSettings> options)
    {
        _httpClient = httpClient;
        _settings = options.Value;
    }
    public async Task<BankStatementData> GetStatementAsync(string transferId)
    {
        var client = new HttpClient();
        var url = string.Format(GetStatementUrlTemplate, _settings.MerchantId, _settings.Secret, transferId);
        var response = await client.GetStreamAsync(url);

        using var sr = new StreamReader(response);
        var data = await sr.ReadToEndAsync();
        var abo = AboFile.Parse(data);

        return new BankStatementData()
        {
            StatementId = transferId,
            Data = data,
            ItemCount = abo.Lines.Count,
        };
    }

    public async Task<IList<BankStatementHeader>> GetStatementsAsync(string accountNumber, DateTime requestStatementDate)
    {
        var request = new HttpRequestMessage(HttpMethod.Post, string.Format(GetStatementsUrlTemplate, _settings.MerchantId, _settings.Secret, requestStatementDate.Date.ToString("yyyy-MM-dd")));

        var response = await _httpClient.SendAsync(request);
        response.EnsureSuccessStatusCode();

        var result = await response.Content.ReadAsAsync<List<ComgateStatementHeader>>();

        return result.Where(w => w.AccountCounterParty == accountNumber)
            .Select(s => new BankStatementHeader()
            {
                StatementId = s.TransferId,
                Date = DateTime.ParseExact(s.TransferDate, "yyyy-MM-dd", CultureInfo.InvariantCulture),
                Account = s.AccountCounterParty
            }).ToList();
    }
}


// https://github.com/jakubzapletal/bank-statements/blob/master/Parser/ABOParser.php
public class AboFile
{
    public AboHeader Header { get; set; }
    public List<AboLine> Lines { get; set; } = new List<AboLine>();

    public static AboFile Parse(string data)
    {
        var file = new AboFile()
        {
            Header = GetHeader(data),
            Lines = GetLines(data)
        };

        return file;
    }

    private static List<AboLine> GetLines(string data)
    {
        // Todo add some actual parsing
        var lines = data.Split(Environment.NewLine);

        return lines.Skip(1).Select(s => new AboLine(s)).ToList();
    }

    private static AboHeader GetHeader(string data)
    {
        // Todo add some actual parsing
        return new AboHeader();
    }
}

public class AboLine
{
    public string Raw { get; }

    public AboLine(string rawLine)
    {
        Raw = rawLine;
        // Todo add some actual parsing;
    }
}

public class AboHeader
{
}
﻿using Anela.Heblo.Application.Domain.Bank;
using Anela.Heblo.Domain.Features.Bank;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace Anela.Heblo.Adapters.Comgate;

public static class ComgateAdapterServiceCollectionExtensions
{
    public static IServiceCollection AddComgateAdapter(this IServiceCollection services, IConfiguration configuration)
    {
        services.AddHttpClient();

        // Configure ComgateSettings using Options pattern
        var comgateSection = configuration.GetSection(ComgateSettings.ConfigurationKey);
        services.Configure<ComgateSettings>(comgateSection);

        // Configure BankAccountSettings using Options pattern
        var bankAccountSection = configuration.GetSection(BankAccountSettings.ConfigurationKey);
        services.Configure<BankAccountSettings>(bankAccountSection);

        // Register IBankClient implementation
        services.AddTransient<IBankClient, ComgateBankClient>();

        return services;
    }
}
namespace Anela.Heblo.Adapters.Comgate.Model;

internal class ComgateStatementHeader
{
    public string TransferId { get; set; }
    public string TransferDate { get; set; }

    public string AccountCounterParty { get; set; }
    public string AccountOutgoing { get; set; }
    public string VariableSymbol { get; set; }
}
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Anela.Heblo.Adapters.Shoptet")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+6cd183ef4ac33ad09cbb7ecd6a8b9c35891c45cb")]
[assembly: System.Reflection.AssemblyProductAttribute("Anela.Heblo.Adapters.Shoptet")]
[assembly: System.Reflection.AssemblyTitleAttribute("Anela.Heblo.Adapters.Shoptet")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

﻿using Anela.Heblo.Adapters.Shoptet.Playwright;
using Anela.Heblo.Adapters.Shoptet.Playwright.Scenarios;
using Anela.Heblo.Application.Domain.CashRegister;
using Anela.Heblo.Application.Domain.Catalog.Price;
using Anela.Heblo.Application.Domain.Catalog.Stock;
using Anela.Heblo.Application.Domain.Logistics.Picking;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using System.Text;
using Anela.Heblo.Adapters.Shoptet.IssuedInvoices;
using Anela.Heblo.Adapters.Shoptet.Price;
using Anela.Heblo.Adapters.Shoptet.Stock;
using Anela.Heblo.Domain.Features.CashRegister;
using Anela.Heblo.Domain.Features.Catalog.Price;
using Anela.Heblo.Domain.Features.Catalog.Stock;
using Anela.Heblo.Domain.Features.Invoices;
using Anela.Heblo.Domain.Features.Logistics.Picking;
using Anela.Heblo.Xcc.Audit;
using Microsoft.Extensions.DependencyInjection.Extensions;

namespace Anela.Heblo.Adapters.Shoptet;

public static class ShoptetAdapterServiceCollectionExtensions
{
    public static IServiceCollection AddShoptetAdapter(this IServiceCollection services, IConfiguration configuration)
    {
        // Register code pages to support windows-1250 encoding used by Shoptet CSV exports
        Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);

        // Configure AutoMapper
        services.AddAutoMapper(typeof(ShoptetAdapterServiceCollectionExtensions));

        services.AddHttpClient();
        services.AddSingleton<IIssuedInvoiceParser, XmlIssuedInvoiceParser>();
        services.AddSingleton<IIssuedInvoiceSource, ShoptetPlaywrightInvoiceSource>();

        services.AddSingleton<IssuedInvoiceExportScenario>();

        services.AddSingleton<IPickingListSource, ShoptetPlaywrightExpeditionListSource>();
        services.AddSingleton<PrintPickingListScenario>();

        services.AddSingleton<IEshopStockDomainService, ShoptetPlaywrightStockDomainService>();
        services.AddSingleton<StockUpScenario>();
        services.AddSingleton<StockTakingScenario>();

        services.AddSingleton<ICashRegisterOrdersSource, ShoptetPlaywrightCashRegisterOrdersSource>();
        services.AddSingleton<CashRegisterStatisticsScenario>();


        //services.Configure<DropBoxSourceOptions>(configuration.GetSection("Shoptet"));
        services.Configure<PlaywrightSourceOptions>(configuration.GetSection(PlaywrightSourceOptions.SettingsKey));
        services.AddSingleton(configuration.GetSection(PlaywrightSourceOptions.SettingsKey).Get<PlaywrightSourceOptions>());


        services.AddSingleton<IEshopStockClient, ShoptetStockClient>();
        services.Configure<ShoptetStockClientOptions>(
            configuration.GetSection(ShoptetStockClientOptions.SettingsKey));

        services.AddSingleton<IProductPriceEshopClient, ShoptetPriceClient>();

        services.Configure<ProductPriceOptions>(configuration.GetSection(ProductPriceOptions.ConfigKey));

        services.TryAddSingleton<IDataLoadAuditService, InMemoryDataLoadAuditService>();

        return services;
    }
}
using Anela.Heblo.Adapters.Shoptet.Playwright.Scenarios;
using Anela.Heblo.Application.Domain.CashRegister;
using Anela.Heblo.Domain.Features.CashRegister;

namespace Anela.Heblo.Adapters.Shoptet.Playwright;

public class ShoptetPlaywrightCashRegisterOrdersSource : ICashRegisterOrdersSource
{
    private readonly CashRegisterStatisticsScenario _scenario;

    public ShoptetPlaywrightCashRegisterOrdersSource(CashRegisterStatisticsScenario scenario)
    {
        _scenario = scenario;
    }

    public async Task<List<CashRegisterOrder>> GetAllAsync(CashRegistryRequest query)
    {
        var registers = query.RegistersId.Select(s => new CashRegister() { Id = s }).ToList();
        var result = await _scenario.RunAsync(registers, query.Year, query.Month);

        return result.Orders;
    }
}
namespace Anela.Heblo.Adapters.Shoptet.Playwright;

public class PlaywrightSourceOptions
{
    public const string SettingsKey = "Shoptet.Playwright";
    public string ShopEntryUrl { get; set; }
    public string Login { get; set; }
    public string Password { get; set; }

    public string PdfTmpFolder { get; set; }

    public bool Headless { get; set; } = true;
}
using Anela.Heblo.Adapters.Shoptet.Playwright.Model;
using Anela.Heblo.Adapters.Shoptet.Playwright.Scenarios;
using Anela.Heblo.Application.Domain.Logistics;
using Anela.Heblo.Application.Domain.Logistics.Picking;
using Anela.Heblo.Domain.Features.Logistics;
using Anela.Heblo.Domain.Features.Logistics.Picking;

namespace Anela.Heblo.Adapters.Shoptet.Playwright;

public class ShoptetPlaywrightExpeditionListSource : IPickingListSource
{
    private const string SourceStateId = "-2"; // Vyrizuje se
    //private const string SourceStateId = "55"; // K Expedici
    //private const string SourceStateId = "26"; // Bali se
    //private const string DesiredStateId = "26"; // Bali se
    private const string DesiredStateId = "55"; // K Expedici


    private readonly PrintPickingListScenario _printScenario;

    private const int ZASILKOVNA_DO_RUKY = 21;
    private const int ZASILKOVNA_ZPOINT = 15;
    private const int ZASILKOVNA_DO_RUKY_SK = 385;
    private const int ZASILKOVNA_DO_RUKY_CHLAZENY = 370;
    private const int ZASILKOVNA_ZPOINT_CHLAZENY = 373;
    private const int ZASILKOVNA_DO_RUKY_SK_CHLAZENY = 388;

    private const int ZASILKOVNA_ZPOINT_CHLAZENY_ZDARMA = 481;
    private const int ZASILKOVNA_ZPOINT_ZDARMA = 487;


    private const int PPL_DO_RUKY = 6;
    private const int PPL_PARCELSHOP = 80;
    private const int PPL_EXPORT = 86;
    private const int PPL_DO_RUKY_CHLAZENY = 358;
    private const int PPL_PARCELSHOP_CHLAZENY = 361;
    private const int PPL_EXPORT_CHLAZENY = 379;

    private const int GLS_DO_RUKY = 97;
    private const int GLS_EXPORT = 109;

    private const int OSOBAK = 4;


    private readonly List<Shipping> ShippingList = new()
    {
        new Shipping { Carrier = Carriers.Zasilkovna, Name = "ZASILKOVNA_DO_RUKY", Id = ZASILKOVNA_DO_RUKY },
        new Shipping { Carrier = Carriers.Zasilkovna, Name = "ZASILKOVNA_ZPOINT", Id = ZASILKOVNA_ZPOINT},
        new Shipping { Carrier = Carriers.Zasilkovna, Name = "ZASILKOVNA_DO_RUKY_SK", Id = ZASILKOVNA_DO_RUKY_SK },
        new Shipping { Carrier = Carriers.Zasilkovna, Name = "ZASILKOVNA_DO_RUKY_CHLAZENY", Id = ZASILKOVNA_DO_RUKY_CHLAZENY },
        new Shipping { Carrier = Carriers.Zasilkovna, Name = "ZASILKOVNA_ZPOINT_CHLAZENY", Id = ZASILKOVNA_ZPOINT_CHLAZENY },
        new Shipping { Carrier = Carriers.Zasilkovna, Name = "ZASILKOVNA_DO_RUKY_SK_CHLAZENY", Id = ZASILKOVNA_DO_RUKY_SK_CHLAZENY },
        new Shipping { Carrier = Carriers.Zasilkovna, Name = "ZASILKOVNA_ZPOINT_ZDARMA", Id = ZASILKOVNA_ZPOINT_ZDARMA },
        new Shipping { Carrier = Carriers.Zasilkovna, Name = "ZASILKOVNA_ZPOINT_CHLAZENY_ZDARMA", Id = ZASILKOVNA_ZPOINT_CHLAZENY_ZDARMA },

        new Shipping { Carrier = Carriers.PPL, Name = "PPL_DO_RUKY", Id = PPL_DO_RUKY},
        new Shipping { Carrier = Carriers.PPL, Name = "PPL_PARCELSHOP", Id = PPL_PARCELSHOP},
        new Shipping { Carrier = Carriers.PPL, Name = "PPL_EXPORT", Id = PPL_EXPORT },
        new Shipping { Carrier = Carriers.PPL, Name = "PPL_DO_RUKY_CHLAZENY", Id = PPL_DO_RUKY_CHLAZENY },
        new Shipping { Carrier = Carriers.PPL, Name = "PPL_PARCELSHOP_CHLAZENY", Id = PPL_PARCELSHOP_CHLAZENY },
        new Shipping { Carrier = Carriers.PPL, Name = "PPL_EXPORT_CHLAZENY", Id = PPL_EXPORT_CHLAZENY },

        new Shipping { Carrier = Carriers.GLS, Name = "GLS_DO_RUKY", Id = GLS_DO_RUKY},
        new Shipping { Carrier = Carriers.GLS, Name = "GLS_EXPORT", Id = GLS_EXPORT },

        new Shipping { Carrier = Carriers.Osobak, Name = "OSOBAK", Id = OSOBAK, PageSize = 1}
    };


    public ShoptetPlaywrightExpeditionListSource(PrintPickingListScenario printScenario)
    {
        _printScenario = printScenario;
    }

    public async Task<PrintPickingListResult> CreatePickingList(PrintPickingListRequest request, CancellationToken cancellationToken = default)
    {
        var shippings = ShippingList;

        if (request.Carriers.Any())
            shippings = shippings.Where(w => request.Carriers.Contains(w.Carrier)).ToList();

        var result = await _printScenario.RunAsync(shippings, sourceStateId: request.SourceStateId, desiredStateId: request.ChangeOrderState ? request.DesiredStateId : null, maxPageSize: shippings.Max(m => m.PageSize));

        return result;
    }
}
﻿using Anela.Heblo.Adapters.Shoptet.IssuedInvoices;
using Anela.Heblo.Adapters.Shoptet.Playwright.Scenarios;
using Anela.Heblo.Domain.Features.Invoices;
using Microsoft.Extensions.Logging;

namespace Anela.Heblo.Adapters.Shoptet.Playwright;

public class ShoptetPlaywrightInvoiceSource : IIssuedInvoiceSource
{
    private readonly IIssuedInvoiceParser _invoiceParser;
    private readonly IssuedInvoiceExportScenario _exportScenario;
    private readonly ILogger<ShoptetPlaywrightInvoiceSource> _logger;

    public ShoptetPlaywrightInvoiceSource(
        IIssuedInvoiceParser invoiceParser,
        IssuedInvoiceExportScenario exportScenario,
        ILogger<ShoptetPlaywrightInvoiceSource> logger)
    {
        _invoiceParser = invoiceParser;
        _exportScenario = exportScenario;
        _logger = logger;
    }

    public async Task<List<IssuedInvoiceDetailBatch>> GetAllAsync(IssuedInvoiceSourceQuery query)
    {
        var content = await ScenarioRetryHelper.ExecuteWithRetryAsync(
            async () => await _exportScenario.RunAsync(query),
            _logger,
            "IssuedInvoiceExportScenario",
            maxRetries: 3,
            delayMilliseconds: 2000
        );

        var invoices = await _invoiceParser.ParseAsync(content);
        var invoiceBatch = new IssuedInvoiceDetailBatch()
        {
            Invoices = invoices,
            BatchId = query.RequestId,
        };

        return new List<IssuedInvoiceDetailBatch>() { invoiceBatch };
    }



    public Task CommitAsync(IssuedInvoiceDetailBatch batch, string? commitMessage = default)
    {
        return Task.CompletedTask;
    }

    public Task FailAsync(IssuedInvoiceDetailBatch batch, string? errorMessage = default)
    {
        return Task.CompletedTask;
    }
}
namespace Anela.Heblo.Adapters.Shoptet.Playwright.Model;

internal class CashRegisterStatisticsLine
{
    public string User { get; set; }
    public DateTime Date { get; set; }
    public decimal Amount { get; set; }
    public string TransactionType { get; set; }
    public string OrderNo { get; set; }
}


using Anela.Heblo.Application.Domain.Logistics;
using Anela.Heblo.Domain.Features.Logistics;

namespace Anela.Heblo.Adapters.Shoptet.Playwright.Model;

public class Shipping
{
    public Carriers Carrier { get; set; }
    public int Id { get; set; }
    public string Name { get; set; } = "??";

    public int PageSize { get; set; } = 8;
}
using System.Globalization;
using Anela.Heblo.Adapters.Shoptet.Playwright.Model;
using Anela.Heblo.Application.Domain.CashRegister;
using Anela.Heblo.Domain.Features.CashRegister;
using Anela.Heblo.Domain.Features.Invoices;
using HtmlAgilityPack;
using Microsoft.Extensions.Logging;
using Microsoft.Playwright;

namespace Anela.Heblo.Adapters.Shoptet.Playwright.Scenarios;

public class CashRegisterStatisticsScenario
{
    private readonly PlaywrightSourceOptions _options;
    private readonly ILogger<CashRegisterStatisticsScenario> _logger;

    private const string ExportFileNameHeaderName = "x-export-file-name";

    private TaskCompletionSource<bool> semaphore;

    public CashRegisterStatisticsScenario(
        PlaywrightSourceOptions options,
        ILogger<CashRegisterStatisticsScenario> logger
    )
    {
        _options = options;
        _logger = logger;
    }

    public async Task<CashRegisterStatistics> RunAsync(List<CashRegister> registers, int year, int month)
    {
        // Make sure dir exists
        Directory.CreateDirectory(_options.PdfTmpFolder);

        using var playwright = await Microsoft.Playwright.Playwright.CreateAsync();

        await using var browser = await playwright.Chromium.LaunchAsync(new BrowserTypeLaunchOptions()
        {
            Headless = _options.Headless,
        });
        var page = await browser.NewPageAsync();
        await InitPage(page, browser);

        await page.GotoAsync(_options.ShopEntryUrl);
        await page.WaitForLoadStateAsync();

        await page.ClickAsync("[placeholder='E-mail']");
        await page.FillAsync("[placeholder='E-mail']", _options.Login);
        await page.PressAsync("[placeholder='E-mail']", "Tab");
        await page.FillAsync("[placeholder='Vaše heslo']", _options.Password);
        await page.ClickAsync("role=button >> text=Přihlášení");

        _logger.LogDebug("Login successful");

        var result = new CashRegisterStatistics();
        foreach (var register in registers)
        {
            int found;
            var pageCounter = 0;

            await page.GotoAsync($"{_options.ShopEntryUrl}statistika-pokladny/?f[monthYear]={month}%2F{year}&f[cashDeskId]={register.Id}");

            var html = await page.ContentAsync();

            var orders = ParseOrders(html);
            result.Orders.AddRange(orders.Select(s => new CashRegisterOrder()
            {
                CashRegisterId = register.Id,
                User = s.User,
                Date = s.Date,
                Amount = s.Amount,
                TransactionType = ParseTransactionType(s.TransactionType),
                OrderNo = s.OrderNo
            }));
        }

        return result;
    }

    private BillingMethod ParseTransactionType(string argTransactionType)
    {
        return BillingMethod.Cash;
    }

    private List<CashRegisterStatisticsLine> ParseOrders(string html)
    {
        var doc = new HtmlDocument();
        doc.LoadHtml(html);

        var table = doc.DocumentNode.SelectSingleNode("//*[@id='detail']/div/table");

        var list = new List<CashRegisterStatisticsLine>();

        foreach (var rows in table.SelectNodes("tbody/tr").Skip(1))
        {
            var columns = rows.SelectNodes("td").Select(td => td.InnerText.Trim()).ToArray();

            var data = new CashRegisterStatisticsLine
            {
                User = GetUserName(columns),
                Date = GetDate(columns),
                Amount = GetAmount(columns),
                OrderNo = GetOrderNo(columns),
                TransactionType = GetTransactionType(columns),
            };

            list.Add(data);
        }

        return list;
    }


    private string GetUserName(string[] columns) => columns[0];
    private DateTime GetDate(string[] columns) => DateTime.ParseExact(columns[1], "dd.MM.yyyy HH:mm", CultureInfo.InvariantCulture);
    private decimal GetAmount(string[] columns) => Decimal.Parse(columns[4].Replace(" Kč", "").Replace(" ", ""));
    private string GetOrderNo(string[] columns) => columns[8].Split("\n")[0];
    private string GetTransactionType(string[] columns) => columns[7];

    private async Task InitPage(IPage page, IBrowser browser)
    {
        page.SetDefaultTimeout(300000); // Set timeout
        page.Console += (_, msg) => { Console.WriteLine(msg.Text); };
        // Catch print request running in another thread
    }
}
using Microsoft.Extensions.Logging;
using Microsoft.Playwright;
using System;

namespace Anela.Heblo.Adapters.Shoptet.Playwright.Scenarios;

public static class ScenarioRetryHelper
{
    public static async Task<T> ExecuteWithRetryAsync<T>(
        Func<Task<T>> action,
        ILogger logger,
        string scenarioName,
        int maxRetries = 3,
        int delayMilliseconds = 1000)
    {
        for (int attempt = 1; attempt <= maxRetries; attempt++)
        {
            try
            {
                logger.LogInformation("Executing {ScenarioName}, attempt {Attempt} of {MaxRetries}",
                    scenarioName, attempt, maxRetries);

                return await action();
            }
            catch (PlaywrightException ex) when (attempt < maxRetries && ex.Message.Contains("Target closed", StringComparison.OrdinalIgnoreCase))
            {
                logger.LogWarning(ex, "TargetClosedException in {ScenarioName}, attempt {Attempt} of {MaxRetries}. Retrying...",
                    scenarioName, attempt, maxRetries);

                await Task.Delay(delayMilliseconds * attempt); // Exponential backoff
            }
            catch (TimeoutException ex) when (attempt < maxRetries)
            {
                logger.LogWarning(ex, "TimeoutException in {ScenarioName}, attempt {Attempt} of {MaxRetries}. Retrying...",
                    scenarioName, attempt, maxRetries);

                await Task.Delay(delayMilliseconds * attempt);
            }
            catch (PlaywrightException ex) when (attempt < maxRetries && IsRetriableError(ex))
            {
                logger.LogWarning(ex, "Retriable PlaywrightException in {ScenarioName}, attempt {Attempt} of {MaxRetries}. Retrying...",
                    scenarioName, attempt, maxRetries);

                await Task.Delay(delayMilliseconds * attempt);
            }
        }

        // This shouldn't be reached, but just in case
        throw new InvalidOperationException($"Failed to execute {scenarioName} after {maxRetries} attempts");
    }

    private static bool IsRetriableError(PlaywrightException ex)
    {
        var retriableMessages = new[]
        {
            "Target closed",
            "Target page, context or browser has been closed",
            "Protocol error",
            "Connection closed",
            "WebSocket is not open"
        };

        return retriableMessages.Any(msg => ex.Message.Contains(msg, StringComparison.OrdinalIgnoreCase));
    }
}
using Anela.Heblo.Domain.Features.Invoices;
using Microsoft.Extensions.Logging;
using Microsoft.Playwright;

namespace Anela.Heblo.Adapters.Shoptet.Playwright.Scenarios;

public class IssuedInvoiceExportScenario
{
    private readonly PlaywrightSourceOptions _options;
    private readonly ILogger<ShoptetPlaywrightInvoiceSource> _logger;

    public IssuedInvoiceExportScenario(
        PlaywrightSourceOptions options,
        ILogger<ShoptetPlaywrightInvoiceSource> logger
    )
    {
        _options = options;
        _logger = logger;
    }

    public async Task<string> RunAsync(IssuedInvoiceSourceQuery query)
    {
        var currency = query.Currency == CurrencyCode.EUR.ToString() ? "3" : "2";
        var outputFile = Path.GetTempFileName();
        IPage? page = null;
        IBrowser? browser = null;
        IPlaywright? playwright = null;

        try
        {
            _logger.LogInformation("Starting extracting query {RequestId}", query.RequestId);
            playwright = await Microsoft.Playwright.Playwright.CreateAsync();
            browser = await playwright.Chromium.LaunchAsync(new BrowserTypeLaunchOptions()
            {
                Headless = _options.Headless,
            });
            page = await browser.NewPageAsync();

            // Set more reasonable timeouts
            page.SetDefaultTimeout(60000); // 60 seconds default timeout
            page.SetDefaultNavigationTimeout(30000); // 30 seconds for navigation

            await page.GotoAsync(_options.ShopEntryUrl, new PageGotoOptions
            {
                WaitUntil = WaitUntilState.NetworkIdle,
                Timeout = 30000
            });

            // Wait for login form and fill credentials
            await page.WaitForSelectorAsync("[placeholder='E-mail']", new PageWaitForSelectorOptions { State = WaitForSelectorState.Visible });
            await page.ClickAsync("[placeholder='E-mail']");
            await page.FillAsync("[placeholder='E-mail']", _options.Login);
            await page.PressAsync("[placeholder='E-mail']", "Tab");
            await page.FillAsync("[placeholder='Vaše heslo']", _options.Password);
            await page.ClickAsync("role=button >> text=Přihlášení");

            // Wait for navigation after login
            await page.WaitForLoadStateAsync(LoadState.NetworkIdle, new PageWaitForLoadStateOptions { Timeout = 30000 });
            await page.ClickAsync("text=Objednávky");
            await page.WaitForLoadStateAsync(LoadState.NetworkIdle);
            await page.ClickAsync("text=Daňové doklady");
            await page.WaitForLoadStateAsync(LoadState.NetworkIdle);

            var openMenuElement = await page.WaitForSelectorAsync(".open-menu", new PageWaitForSelectorOptions { State = WaitForSelectorState.Visible });
            await openMenuElement.HoverAsync();
            await Task.Delay(500); // Small delay for menu animation

            await page.ClickAsync("text=Export dokladů");
            await page.WaitForLoadStateAsync(LoadState.NetworkIdle);

            await page.WaitForSelectorAsync("a[data-testid=buttonExport]", new PageWaitForSelectorOptions { State = WaitForSelectorState.Visible, Timeout = 10000 });
            // try
            // {
            //     await page.WaitForSelectorAsync("a.btn.btn-md.btn-action.submit-js[title='Exportovat'][rel='export']",
            //         new PageWaitForSelectorOptions() { Timeout = 2000 });
            // }
            // catch (Exception ex)
            // {
            // }
            if (query.QueryByDate)
            {
                await page.PressAsync("body", "Tab");
                await page.PressAsync("body", "Tab");
                await page.PressAsync("body", "Tab");
                await page.PressAsync("body", "Tab");

                var activeElement1 = await page.EvaluateHandleAsync("document.activeElement");
                await activeElement1.AsElement().FillAsync(query.DateFromString);
                await activeElement1.DisposeAsync();

                await page.PressAsync("body", "Tab");

                var activeElement2 = await page.EvaluateHandleAsync("document.activeElement");
                await activeElement2.AsElement().FillAsync(query.DateToString);
                await activeElement2.DisposeAsync();
            }

            if (query.QueryByInvoice)
            {
                var activeElement3 = await page.EvaluateHandleAsync("document.activeElement");
                await activeElement3.AsElement().FillAsync(query.InvoiceId);
                await activeElement3.DisposeAsync();

                await page.PressAsync("body", "Tab");

                var activeElement4 = await page.EvaluateHandleAsync("document.activeElement");
                await activeElement4.AsElement().FillAsync(query.InvoiceId);
                await activeElement4.DisposeAsync();
            }

            if (currency != "2")
            {
                await page.Locator("#main-modal-form").GetByLabel("MěnaCZKEUR").SelectOptionAsync(currency);
            }

            var downloadEventTask = page.WaitForDownloadAsync(new PageWaitForDownloadOptions { Timeout = 60000 });
            await page.ClickAsync("role=link >> text=Exportovat");
            var downloadEvent = await downloadEventTask;

            await downloadEvent.SaveAsAsync(outputFile);

            var content = await File.ReadAllTextAsync(outputFile);

            _logger.LogInformation("Data for batch {RequestId} extracted - Total of {ContentLength}", query.RequestId,
                content.Length);

            return content;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during invoice export scenario for request {RequestId}", query.RequestId);
            throw;
        }
        finally
        {
            // Cleanup
            try
            {
                if (page != null)
                {
                    await page.CloseAsync();
                }
                if (browser != null)
                {
                    await browser.DisposeAsync();
                }
                playwright?.Dispose();
            }
            catch (Exception cleanupEx)
            {
                _logger.LogWarning(cleanupEx, "Error during cleanup for request {RequestId}", query.RequestId);
            }

            // Delete temp file
            try
            {
                if (File.Exists(outputFile))
                {
                    File.Delete(outputFile);
                }
            }
            catch (Exception fileEx)
            {
                _logger.LogWarning(fileEx, "Failed to delete temp file {OutputFile}", outputFile);
            }
        }
    }
}
using Anela.Heblo.Application.Domain.Catalog.Stock;
using Anela.Heblo.Domain.Features.Catalog.Stock;
using Microsoft.Extensions.Logging;
using Microsoft.Playwright;

namespace Anela.Heblo.Adapters.Shoptet.Playwright.Scenarios;

public class StockUpScenario
{
    private readonly PlaywrightSourceOptions _options;
    private readonly ILogger<StockUpScenario> _logger;

    public StockUpScenario(
        PlaywrightSourceOptions options,
        ILogger<StockUpScenario> logger
    )
    {
        _options = options;
        _logger = logger;
    }

    public async Task<StockUpRecord> RunAsync(StockUpRequest request)
    {
        using var playwright = await Microsoft.Playwright.Playwright.CreateAsync();

        await using var browser = await playwright.Chromium.LaunchAsync(new BrowserTypeLaunchOptions()
        {
            Headless = _options.Headless,
        });
        var page = await browser.NewPageAsync();

        await page.GotoAsync(_options.ShopEntryUrl);
        await page.WaitForLoadStateAsync();

        await page.ClickAsync("[placeholder='E-mail']");
        await page.FillAsync("[placeholder='E-mail']", _options.Login);
        await page.PressAsync("[placeholder='E-mail']", "Tab");
        await page.FillAsync("[placeholder='Vaše heslo']", _options.Password);
        await page.ClickAsync("role=button >> text=Přihlášení");

        _logger.LogDebug("Login successful");

        await page.GotoAsync($"{_options.ShopEntryUrl}/sklad");
        await page.WaitForLoadStateAsync();
        await page.ClickAsync("text=Naskladnění");
        await page.FillAsync("input[name='documentNumber']", request.StockUpId);
        await page.FillAsync("input[name='stockingSearch']", request.Product);
        await page.PressAsync("input[name='stockingSearch']", "Enter");
        await page.WaitForSelectorAsync(".cashdesk-search-result");
        await page.ClickAsync(".cashdesk-products-listing > .product");
        await page.FillAsync("text=Množství", request.Amount.ToString());
        await page.ClickAsync("[data-testid='buttonAddItemsToStock']");

        return new StockUpRecord()
        {
        };
    }
}
using Anela.Heblo.Application.Domain.Catalog.Stock;
using Anela.Heblo.Domain.Features.Catalog.Stock;
using Microsoft.Extensions.Logging;
using Microsoft.Playwright;

namespace Anela.Heblo.Adapters.Shoptet.Playwright.Scenarios;

public class StockTakingScenario
{
    private readonly PlaywrightSourceOptions _options;
    private readonly ILogger<StockTakingScenario> _logger;
    private readonly TimeProvider _timeProvider;

    public StockTakingScenario(
        PlaywrightSourceOptions options,
        ILogger<StockTakingScenario> logger,
        TimeProvider timeProvider
    )
    {
        _options = options;
        _logger = logger;
        _timeProvider = timeProvider;
    }

    public async Task<StockTakingRecord> RunAsync(EshopStockTakingRequest request)
    {
        // Definice selektorů
        var freeSelector = "body > div.pageGrid > div.pageGrid__content > div.section.section-1063 > form > fieldset > div.tableWrapper > table > tbody > tr > td:nth-child(5) > div:nth-child(1) > div > input";
        var reservedSelector = "body > div.pageGrid > div.pageGrid__content > div.section.section-1063 > form > fieldset > div.tableWrapper > table > tbody > tr > td:nth-child(5) > div:nth-child(2) > div > input";

        using var playwright = await Microsoft.Playwright.Playwright.CreateAsync();

        await using var browser = await playwright.Chromium.LaunchAsync(new BrowserTypeLaunchOptions()
        {
            Headless = _options.Headless,
        });
        var page = await browser.NewPageAsync();

        await page.GotoAsync(_options.ShopEntryUrl);
        await page.WaitForLoadStateAsync();

        await page.ClickAsync("[placeholder='E-mail']");
        await page.FillAsync("[placeholder='E-mail']", _options.Login);
        await page.PressAsync("[placeholder='E-mail']", "Tab");
        await page.FillAsync("[placeholder='Vaše heslo']", _options.Password);
        await page.ClickAsync("role=button >> text=Přihlášení");

        _logger.LogDebug("Login successful");

        await page.GotoAsync($"{_options.ShopEntryUrl}/skladove-zasoby/?f[code]={request.ProductCode}");
        await page.WaitForLoadStateAsync();

        // Získání hodnoty z polí
        var actionsCellLocator = page.Locator("td.table__cell--actions").First;
        var originalLocator = actionsCellLocator.Locator("input[name^='originalAmounts']");
        var freeLocator = actionsCellLocator.Locator("input[name^='amounts']");
        var reservedLocator = actionsCellLocator.Locator("input").Last;

        var originalAmount = Convert.ToInt32(await originalLocator.InputValueAsync());
        var freeAmount = Convert.ToInt32(await freeLocator.InputValueAsync());
        var reservedAmount = Convert.ToInt32(await reservedLocator.GetAttributeAsync("placeholder"));

        var setAmount = request.TargetAmount - reservedAmount;
        // Výpočet a vyplnění nového množství
        await freeLocator.FillAsync(setAmount.ToString());

        // Uložení změn
        await page.GetByTestId("buttonSaveAndStay").ClickAsync();
        _logger.LogInformation("InventoryAlign: {ProductCode} -> {TargetAmount} ({FreeAmount} free / {ReservedAmount} reserved -> {SetAmount})", request.ProductCode, request.TargetAmount, freeAmount, reservedAmount, setAmount);

        // Zavření prohlížeče
        await browser.CloseAsync();

        return new StockTakingRecord()
        {
            Date = _timeProvider.GetUtcNow().DateTime,
            Code = request.ProductCode,
            AmountNew = (double)request.TargetAmount, // TODO Convert to decimal
            AmountOld = freeAmount + reservedAmount
        };
    }
}

using Anela.Heblo.Adapters.Shoptet.Playwright.Model;
using Anela.Heblo.Application.Domain.Logistics.Picking;
using Anela.Heblo.Application.Domain.Users;
using Anela.Heblo.Domain.Features.Logistics.Picking;
using Anela.Heblo.Xcc;
using Microsoft.Extensions.Logging;
using Microsoft.Playwright;

namespace Anela.Heblo.Adapters.Shoptet.Playwright.Scenarios;

public class PrintPickingListScenario
{
    private readonly PlaywrightSourceOptions _options;
    private readonly ILogger<PrintPickingListScenario> _logger;
    private readonly TimeProvider _timeProvider;

    private const string ExportFileNameHeaderName = "x-export-file-name";

    private TaskCompletionSource<bool> semaphore;

    public PrintPickingListScenario(
        PlaywrightSourceOptions options,
        ILogger<PrintPickingListScenario> logger,
        TimeProvider timeProvider
    )
    {
        _options = options;
        _logger = logger;
        _timeProvider = timeProvider;
    }

    public async Task<PrintPickingListResult> RunAsync(List<Shipping> shippings, int maxPageSize, int? sourceStateId = null, int? desiredStateId = null)
    {
        // Make sure dir exists
        Directory.CreateDirectory(_options.PdfTmpFolder);

        using var playwright = await Microsoft.Playwright.Playwright.CreateAsync();

        await using var browser = await playwright.Chromium.LaunchAsync(new BrowserTypeLaunchOptions()
        {
            Headless = _options.Headless,
        });
        var page = await browser.NewPageAsync();
        await InitPage(page, browser);

        await page.GotoAsync(_options.ShopEntryUrl);
        await page.WaitForLoadStateAsync();

        await page.ClickAsync("[placeholder='E-mail']");
        await page.FillAsync("[placeholder='E-mail']", _options.Login);
        await page.PressAsync("[placeholder='E-mail']", "Tab");
        await page.FillAsync("[placeholder='Vaše heslo']", _options.Password);
        await page.ClickAsync("role=button >> text=Přihlášení");

        _logger.LogDebug("Login successful");

        var exportList = new List<string>();
        var totalCount = 0;


        foreach (var shipping in shippings)
        {
            int found;
            var pageCounter = 0;
            do
            {
                // Select top x for print
                await page.GotoAsync($"{_options.ShopEntryUrl}prehled-objednavek/{sourceStateId}/?f[shippingId]={shipping.Id}");
                found = await SelectTopX(page, shipping.Id, shipping.PageSize);

                if (found > 0)
                {
                    // Print them to PDF
                    var filename = $"{_timeProvider.GetFilenameTimestamp()}_{shipping.Carrier.ToString()}_{shipping.Id.ToString()}_{pageCounter++.ToString().PadLeft(2, '0')}.pdf";
                    var result = await PrintSelected(page, filename);
                    _logger.LogDebug("Finished print to file {Filename} for shipping={ShippingId}", filename, shipping.Id);

                    if (result && desiredStateId != null)
                    {
                        // Select them again (so far no other way around)
                        found = await SelectTopX(page, shipping.Id, shipping.PageSize);

                        // Change states
                        result = await ChangeStateSelected(page, desiredStateId.Value);
                        _logger.LogDebug("Changing state to {DesiredState} for shipping={ShippingId}", desiredStateId, shipping.Id);
                    }
                    if (!result)
                        throw new Exception();

                    exportList.Add(GetAbsolutePath(filename));
                    totalCount += found;
                }

            } while (found >= maxPageSize);
        }

        return new PrintPickingListResult()
        {
            ExportedFiles = exportList,
            TotalCount = totalCount,
        };
    }

    private async Task InitPage(IPage page, IBrowser browser)
    {
        page.SetDefaultTimeout(300000); // Set timeout
        page.Console += (_, msg) => { Console.WriteLine(msg.Text); };
        // Catch print request running in another thread
        page.Response += async (_, response) =>
        {
            if (response.Request.Url.Contains("?type=expedition&ids="))
            {
                await HandlePrintRequest(response, browser);
            }
        };

        // Disable print dialog
        await page.RouteAsync("**/MassPrint/*", RewritePrintDialog);

        // Auto accept confirm dialog
        page.Dialog += async (_, dialog) =>
        {
            Console.WriteLine($"Dialog message: {dialog.Message}");
            await dialog.AcceptAsync();
        };
    }

    private async Task<int> SelectTopX(IPage page, int shippingId, int pageSize)
    {
        var found = 0;
        // await page.WaitForSelectorAsync("div.pagination__founds strong");
        await page.WaitForSelectorAsync(".pageGrid__footer.footer");


        _logger.LogDebug("Listing orders for shipping {ShippingId}", shippingId);

        for (int i = 0; i < pageSize; i++)
        {
            if (await CheckIfPresent(page, $"input[name=\"orderId[{i}]\"]"))
                found++;
        }

        _logger.LogDebug("Found {OrderCount} for shipping={ShippingId}", found, shippingId);

        return found;
    }


    private async Task<bool> ChangeStateSelected(IPage page, int desiredStateId)
    {
        await page.ClickAsync("text=Funkce");
        await page.ClickAsync(".massAction__submenuHeader:has-text('Stav')");
        await page.ClickAsync($"a[rel='massStatusChange|{desiredStateId}']");

        await page.WaitForSelectorAsync(".systemMessage.systemMessage--success .systemMessage__text");

        return true;
    }

    private async Task<bool> PrintSelected(IPage page, string filename)
    {
        await page.ClickAsync("text=Funkce");
        await page.ClickAsync("text=Tisk");

        await page.SetExtraHTTPHeadersAsync(new Dictionary<string, string>
        {
            { ExportFileNameHeaderName, filename },
        });

        semaphore = new TaskCompletionSource<bool>();

        await page.ClickAsync("text=Expedice");
        await page.WaitForResponseAsync(r => true, new PageWaitForResponseOptions() { Timeout = 30000 });

        await semaphore.Task;

        await page.ReloadAsync();
        return true;
    }


    private async Task<bool> CheckIfPresent(IPage page, string locator)
    {
        var elementHandle = await page.QuerySelectorAsync(locator);
        if (elementHandle != null)
        {
            // Element found, proceed with your actions, for example:
            await elementHandle.CheckAsync();
            return true;
        }

        return false;
    }


    private async Task HandlePrintRequest(IResponse response, IBrowser browser)
    {
        _logger.LogDebug("Printing export page {Url}", response.Request.Url);
        var body = await response.TextAsync();

        var newPage = await browser.NewPageAsync();

        await newPage.SetContentAsync(body);

        var filenameHeader = response.Request.Headers.SingleOrDefault(s => s.Key == ExportFileNameHeaderName);

        await newPage.PdfAsync(new PagePdfOptions() { Path = GetAbsolutePath(filenameHeader.Value) });

        await newPage.CloseAsync();
        _logger.LogDebug("Page {Url} extracted to {FileName}", response.Request.Url, filenameHeader.Value);
        semaphore.SetResult(true);
    }

    private async Task RewritePrintDialog(IRoute route)
    {
        var response = await route.FetchAsync();
        var body = await response.TextAsync();
        var headers = response.Headers;

        if (route.Request.Url.Contains("?type=expedition&ids="))
        {
            body = body.Replace("window.print(); parent.$('body').trigger('printDialogOpened');", "");
            _logger.LogDebug("Rewriting window.print() for {Url}", route.Request.Url);
        }

        await route.FulfillAsync(new()
        {
            // Pass all fields from the response.
            Response = response,
            // Override response body.
            Body = body,
            // Force content type to be html.
            Headers = headers,
        });
    }

    private string GetAbsolutePath(string filename)
    {
        return Path.Combine(_options.PdfTmpFolder, filename);
    }
}
using Anela.Heblo.Adapters.Shoptet.Playwright.Scenarios;
using Anela.Heblo.Application.Domain.Catalog.Stock;
using Anela.Heblo.Application.Domain.Users;
using Anela.Heblo.Domain.Features.Catalog.Stock;
using Anela.Heblo.Domain.Features.Users;

namespace Anela.Heblo.Adapters.Shoptet.Playwright;

public class ShoptetPlaywrightStockDomainService : IEshopStockDomainService
{
    private readonly StockUpScenario _stockUpScenario;
    private readonly StockTakingScenario _inventoryAlignScenario;
    private readonly IStockTakingRepository _stockTakingRepository;
    private readonly ICurrentUserService _currentUser;
    private readonly TimeProvider _timeProvider;

    public ShoptetPlaywrightStockDomainService(
        StockUpScenario stockUpScenario,
        StockTakingScenario inventoryAlignScenario,
        IStockTakingRepository stockTakingRepository,
        ICurrentUserService currentUser,
        TimeProvider timeProvider)
    {
        _stockUpScenario = stockUpScenario;
        _inventoryAlignScenario = inventoryAlignScenario;
        _stockTakingRepository = stockTakingRepository;
        _currentUser = currentUser;
        _timeProvider = timeProvider;
    }

    public async Task StockUpAsync(StockUpRequest stockUpOrder)
    {
        var result = await _stockUpScenario.RunAsync(stockUpOrder);
    }


    public async Task<StockTakingRecord> SubmitStockTakingAsync(EshopStockTakingRequest order)
    {
        try
        {
            StockTakingRecord result;
            if (!order.SoftStockTaking) // No real stock taking, just a record in DB
            {
                result = await _inventoryAlignScenario.RunAsync(order);
            }
            else
            {
                result = new StockTakingRecord()
                {
                    Code = order.ProductCode,
                    AmountNew = (double)order.TargetAmount, // TODO COnvert to decimal
                    AmountOld = (double)order.TargetAmount, // TODO COnvert to decimal
                };
            }
            result.User = _currentUser.GetCurrentUser().Name;
            result.Date = _timeProvider.GetUtcNow().DateTime;
            await _stockTakingRepository.AddAsync(result);
            return result;
        }
        catch (Exception e)
        {
            return new StockTakingRecord
            {
                Date = _timeProvider.GetUtcNow().DateTime,
                Code = order.ProductCode,
                AmountNew = (double)order.TargetAmount, // TODO Convert to decimal
                AmountOld = (double)order.TargetAmount, // TODO Convert to decimal
                Error = e.Message
            };
        }
    }
}
namespace Anela.Heblo.Adapters.Shoptet.Price;

public class ProductPriceOptions
{
    public const string ConfigKey = "ProductPriceOptions";
    public string ProductExportUrl { get; set; } = "http://";
}
using System.Globalization;
using System.Text;
using Anela.Heblo.Domain.Features.Catalog.Price;
using CsvHelper;
using CsvHelper.Configuration;
using Microsoft.Extensions.Options;

namespace Anela.Heblo.Adapters.Shoptet.Price;

public class ShoptetPriceClient : IProductPriceEshopClient
{
    private readonly HttpClient _httpClient;
    private readonly IOptions<ProductPriceOptions> _options;

    public ShoptetPriceClient(HttpClient httpClient, IOptions<ProductPriceOptions> options)
    {
        _httpClient = httpClient;
        _options = options;
    }

    public async Task<IEnumerable<ProductPriceEshop>> GetAllAsync(CancellationToken cancellationToken)
    {
        List<ProductPriceEshop> priceList = new List<ProductPriceEshop>();

        using (HttpResponseMessage response = await _httpClient.GetAsync(_options.Value.ProductExportUrl, cancellationToken))
        using (Stream csvStream = await response.Content.ReadAsStreamAsync(cancellationToken))
        using (StreamReader reader = new StreamReader(csvStream, Encoding.GetEncoding("windows-1250")))
        using (CsvReader csv = new CsvReader(reader, new CsvConfiguration(CultureInfo.InvariantCulture) { Delimiter = ";" }))
        {
            csv.Context.RegisterClassMap<ProductPriceImportMap>();
            priceList = csv.GetRecords<ProductPriceEshop>().ToList();
        }

        // Removed OriginalPrice and OriginalPurchasePrice assignments as these properties don't exist in simplified model

        return priceList;
    }

    public async Task<SetProductPricesResultDto> SetAllAsync(IEnumerable<ProductPriceEshop> destinationData, CancellationToken cancellationToken)
    {
        var csvPath = CreateCsv(destinationData);
        Console.WriteLine(csvPath);

        var result = new SetProductPricesResultDto()
        {
            FilePath = csvPath,
            Data = await File.ReadAllBytesAsync(csvPath, cancellationToken)
        };
        return result;
    }

    private string CreateCsv(IEnumerable<ProductPriceEshop> destinationData)
    {
        // Create a temporary file in the system's temporary folder
        var tempPath = Path.GetTempPath();
        var tempFile = Path.Combine(tempPath, "products.csv");
        using (var stream = File.Create(tempFile))
        using (var writer = new StreamWriter(stream, Encoding.UTF8))
        using (var csv = new CsvWriter(writer, new CsvConfiguration(CultureInfo.InvariantCulture) { Delimiter = ";" }))
        {
            csv.Context.RegisterClassMap<ProductPriceExportMap>();
            csv.WriteHeader<ProductPriceEshop>();
            csv.NextRecord();

            foreach (var product in destinationData)
            {
                csv.WriteRecord(product);
                csv.NextRecord();
            }
        }

        return tempFile;
    }

    private class ProductPriceImportMap : ClassMap<ProductPriceEshop>
    {
        public ProductPriceImportMap()
        {
            // Map ProductCode from first column
            Map(m => m.ProductCode).Index(0);

            // Map prices from columns 3 and 4 (skip PairCode and Name)
            Map(m => m.PriceWithVat).Convert(a =>
            {
                var fieldValue = a.Row.GetField(3);
                if (string.IsNullOrWhiteSpace(fieldValue))
                    return null;
                return decimal.TryParse(fieldValue.Replace(",", "."), NumberStyles.Number, CultureInfo.InvariantCulture, out var result) ? (decimal?)result : null;
            });
            Map(m => m.PurchasePrice).Convert(a =>
            {
                var fieldValue = a.Row.GetField(4);
                if (string.IsNullOrWhiteSpace(fieldValue))
                    return null;
                return decimal.TryParse(fieldValue.Replace(",", "."), NumberStyles.Number, CultureInfo.InvariantCulture, out var result) ? (decimal?)result : null;
            });
        }
    }

    private class ProductPriceExportMap : ClassMap<ProductPriceEshop>
    {
        public ProductPriceExportMap()
        {
            Map(m => m.ProductCode).Index(0);
            Map(m => m.PriceWithVat).Index(1);
            Map(m => m.PurchasePrice).Index(2);
        }
    }
}

using System.Xml;
using System.Xml.Serialization;
using Anela.Heblo.Domain.Features.Invoices;
using AutoMapper;
using Microsoft.Extensions.Logging;

namespace Anela.Heblo.Adapters.Shoptet.IssuedInvoices;

public class XmlIssuedInvoiceParser : IIssuedInvoiceParser
{
    private readonly IMapper _mapper;
    private readonly ILogger<XmlIssuedInvoiceParser> _logger;

    public XmlIssuedInvoiceParser(IMapper mapper, ILogger<XmlIssuedInvoiceParser> logger)
    {
        _mapper = mapper;
        _logger = logger;
    }

    public Task<List<IssuedInvoiceDetail>> ParseAsync(string data)
    {
        XmlSerializer serializer = new XmlSerializer(typeof(DataPack));
        var invoices = new List<IssuedInvoiceDetail>();

        using var reader = new XmlTextReader(new StringReader(data));

        var pack = (DataPack)serializer.Deserialize(reader);
        foreach (var i in pack.DataPackItems)
        {
            if (i.IsValid())
                invoices.Add(_mapper.Map<IssuedInvoiceDetail>(i.Invoice));
            else
                _logger.LogError("Unable to deserialize invoice {InvoicerNumber}", i.Id);
        }

        return Task.FromResult(invoices);
    }
}
﻿using Anela.Heblo.Domain.Features.Invoices;
using AutoMapper;

namespace Anela.Heblo.Adapters.Shoptet.IssuedInvoices
{
    public class IssuedInvoiceMapping : Profile
    {
        public IssuedInvoiceMapping()
        {
            CreateMap<Invoice, IssuedInvoiceDetail>()
                .ForMember(m => m.BillingMethod, u => u.MapFrom((si, ai, sbm) =>
                {
                    if (si.InvoiceHeader?.PaymentType?.PaymentType == "creditcard")
                        return BillingMethod.CreditCard;
                    if (si.InvoiceHeader?.PaymentType?.PaymentType == "cash")
                        return BillingMethod.Cash;

                    if (si.InvoiceDetail.InvoiceItems.Any(a => a.Text == "Převodem"))
                        return BillingMethod.BankTransfer;
                    if (si.InvoiceDetail.InvoiceItems.Any(a => a.Text == "Hotově"))
                        return BillingMethod.Cash;
                    if (si.InvoiceDetail.InvoiceItems.Any(a => a.Text.Contains("kart", StringComparison.InvariantCultureIgnoreCase)))
                        return BillingMethod.Comgate;
                    if (si.InvoiceDetail.InvoiceItems.Any(a => a.Text == "Dobírkou"))
                        return BillingMethod.CoD;

                    return BillingMethod.BankTransfer;
                }))
                .ForMember(m => m.ShippingMethod, u => u.MapFrom((si, ai, sbm) =>
                {
                    if (si.InvoiceDetail.InvoiceItems.Any(a => a.Text == "PPL - ParcelShop"))
                        return ShippingMethod.PPLParcelShop;

                    if (si.InvoiceDetail.InvoiceItems.Any(a => a.Text.Contains("PPL", StringComparison.InvariantCultureIgnoreCase)))
                        return ShippingMethod.PPL;

                    if (si.InvoiceDetail.InvoiceItems.Any(a => a.Text.Contains("Osobn", StringComparison.InvariantCultureIgnoreCase)))
                        return ShippingMethod.PickUp;

                    if (si.InvoiceDetail.InvoiceItems.Any(a => a.Text.Contains("GLS", StringComparison.InvariantCultureIgnoreCase)))
                        return ShippingMethod.GLS;

                    if (si.InvoiceDetail.InvoiceItems.Any(a => a.Text.Contains("zásilk", StringComparison.InvariantCultureIgnoreCase)))
                        return ShippingMethod.Zasilkovna;

                    return ShippingMethod.PickUp;
                }))
                .ForMember(m => m.Customer, u => u.MapFrom(f => f.InvoiceHeader.PartnerIdentity.Address))
                .ForMember(m => m.Items, u => u.MapFrom(f => f.InvoiceDetail.InvoiceItems))
                .ForMember(m => m.BillingAddress, u => u.MapFrom(f => f.InvoiceHeader.PartnerIdentity.Address))
                .ForMember(m => m.DeliveryAddress, u => u.MapFrom(f => f.InvoiceHeader.PartnerIdentity.ShipToAddress))
                .ForMember(m => m.DueDate, u => u.MapFrom(f => f.InvoiceHeader.DateDue))
                .ForMember(m => m.TaxDate, u => u.MapFrom(f => f.InvoiceHeader.DateTax))
                .ForMember(m => m.VarSymbol, u => u.MapFrom(f => f.InvoiceHeader.SymVar))
                .ForMember(m => m.CreationTime, u => u.MapFrom(f => f.InvoiceHeader.Date))
                .ForMember(m => m.Code, u => u.MapFrom(f => f.InvoiceHeader.NumberOrder))
                .AfterMap((i, ii) =>
                {
                    if (ii.DeliveryAddress == null)
                        ii.DeliveryAddress = ii.BillingAddress;

                    ii.VatPayer = !string.IsNullOrEmpty(i.InvoiceHeader.PartnerIdentity.Address.Dic);

                    if (i.InvoiceSummary.ForeignCurrency != null)
                    {
                        ii.Price = new InvoicePrice()
                        {
                            WithVat = i.InvoiceSummary.ForeignCurrency.PriceSum,
                            Vat = ii.Items.Sum(s => s.ItemPrice.Vat),
                            WithoutVat = ii.Items.Sum(s => s.ItemPrice.WithoutVat),
                            CurrencyCode = i.InvoiceSummary.ForeignCurrency.Currency.Ids,
                            ExchangeRate = i.InvoiceSummary.ForeignCurrency.Rate
                        };
                    }
                    else
                    {
                        ii.Price = new InvoicePrice()
                        {
                            WithVat = i.InvoiceSummary.HomeCurrency.PriceHighSum,
                            Vat = ii.Items.Sum(s => s.ItemPrice.Vat),
                            WithoutVat = ii.Items.Sum(s => s.ItemPrice.WithoutVat),
                            CurrencyCode = "CZK",
                            ExchangeRate = 1,
                        };
                    }

                    ii.Items.ForEach(f => f.ItemPrice.CurrencyCode = ii.Price.CurrencyCode);
                })
                ;


            CreateMap<InvoiceItem, IssuedInvoiceDetailItem>()
                .ForMember(m => m.Name, c => c.MapFrom(f => f.Text))
                .ForMember(m => m.Amount, c => c.MapFrom(f => f.Quantity))
                .ForMember(m => m.Code, c => c.MapFrom(f => f.Code))
                .AfterMap(((item, invoiceItem, ctx) =>
                {
                    if (item.ForeignCurrency != null)
                        invoiceItem.ItemPrice = ctx.Mapper.Map<ForeignCurrency, InvoicePrice>(item.ForeignCurrency);
                    else
                        invoiceItem.ItemPrice = ctx.Mapper.Map<HomeCurrency, InvoicePrice>(item.HomeCurrency);


                    invoiceItem.ItemPrice.VatRate = item.RateVAT;
                }))
                ;


            CreateMap<HomeCurrency, InvoicePrice>()
                .AfterMap((hc, p) =>
                    {
                        p.WithVat = hc.PriceVAT + hc.Price;
                        p.WithoutVat = hc.Price;
                        p.Vat = hc.PriceVAT;
                    })
                ;

            CreateMap<ForeignCurrency, InvoicePrice>()
                .AfterMap((hc, p) =>
                {
                    p.WithVat = hc.PriceVAT + hc.Price;
                    p.WithoutVat = hc.Price;
                    p.Vat = hc.PriceVAT;
                })
                ;

            CreateMap<PartnerIdentity, InvoiceCustomer>()
                .ForMember(m => m.Company, c => c.MapFrom(f => f.Address.Company))
                .ForMember(m => m.Name, c => c.MapFrom(f => f.Address.Name))
                .ForMember(m => m.VatId, c => c.MapFrom(f => f.Address.Dic))
                .ForMember(m => m.CompanyId, c => c.MapFrom(f => f.Address.Ico))
                ;

            CreateMap<Address, InvoiceAddress>()
                .ForMember(m => m.Company, c => c.MapFrom(f => f.Company))
                .ForMember(m => m.FullName, c => c.MapFrom(f => f.Name))
                .ForMember(m => m.Street, c => c.MapFrom(f => f.Street))
                .ForMember(m => m.Zip, c => c.MapFrom(f => f.Zip))
                .ForMember(m => m.CountryCode, c => c.MapFrom(f => f.Country.Ids))
                .ForMember(m => m.City, c => c.MapFrom(f => f.City))
                ;

            CreateMap<ShipToAddress, InvoiceAddress>()
                .ForMember(m => m.Company, c => c.MapFrom(f => f.Company))
                .ForMember(m => m.FullName, c => c.MapFrom(f => f.Name))
                .ForMember(m => m.Street, c => c.MapFrom(f => f.Street))
                .ForMember(m => m.Zip, c => c.MapFrom(f => f.Zip))
                .ForMember(m => m.CountryCode, c => c.MapFrom(f => f.Country.Ids))
                .ForMember(m => m.City, c => c.MapFrom(f => f.City))
                ;

            CreateMap<Address, InvoiceCustomer>()
                .ForMember(m => m.Company, c => c.MapFrom(f => f.Company))
                .ForMember(m => m.DisplayName, c => c.MapFrom(f => f.Name))
                .ForMember(m => m.CompanyId, c => c.MapFrom(f => f.Ico))
                .ForMember(m => m.VatId, c => c.MapFrom(f => f.Dic))
                ;
        }
    }
}
using Anela.Heblo.Domain.Features.Invoices;

namespace Anela.Heblo.Adapters.Shoptet.IssuedInvoices;

public interface IIssuedInvoiceParser
{
    Task<List<IssuedInvoiceDetail>> ParseAsync(string readToEndAsync);
}
﻿using System.Xml.Serialization;

namespace Anela.Heblo.Adapters.Shoptet
{
    [XmlRoot(ElementName = "number", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
    public class Number
    {
        [XmlElement(ElementName = "numberRequested", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string NumberRequested { get; set; }
    }

    [XmlRoot(ElementName = "paymentType", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
    public class PaymentTypeClass
    {
        [XmlElement(ElementName = "paymentType", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string PaymentType { get; set; }
    }

    [XmlRoot(ElementName = "carrier", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
    public class Carrier
    {
        [XmlElement(ElementName = "ids", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string Ids { get; set; }
    }

    [XmlRoot(ElementName = "country", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
    public class Country
    {
        [XmlElement(ElementName = "ids", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string Ids { get; set; }
    }

    [XmlRoot(ElementName = "address", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
    public class Address
    {
        [XmlElement(ElementName = "company", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string Company { get; set; }
        [XmlElement(ElementName = "name", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string Name { get; set; }
        [XmlElement(ElementName = "city", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string City { get; set; }
        [XmlElement(ElementName = "street", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string Street { get; set; }
        [XmlElement(ElementName = "zip", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string Zip { get; set; }
        [XmlElement(ElementName = "country", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public Country Country { get; set; }
        [XmlElement(ElementName = "ico", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string Ico { get; set; }
        [XmlElement(ElementName = "dic", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string Dic { get; set; }
    }

    [XmlRoot(ElementName = "partnerIdentity", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
    public class PartnerIdentity
    {
        [XmlElement(ElementName = "address", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public Address Address { get; set; }
        [XmlElement(ElementName = "shipToAddress", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public ShipToAddress ShipToAddress { get; set; }
    }

    [XmlRoot(ElementName = "invoiceHeader", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
    public class InvoiceHeader
    {
        [XmlElement(ElementName = "invoiceType", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public string InvoiceType { get; set; }
        [XmlElement(ElementName = "number", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public Number Number { get; set; }
        [XmlElement(ElementName = "paymentType", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public PaymentTypeClass PaymentType { get; set; }
        [XmlElement(ElementName = "carrier", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public Carrier Carrier { get; set; }
        [XmlElement(ElementName = "numberOrder", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public string NumberOrder { get; set; }
        [XmlElement(ElementName = "symVar", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public string SymVar { get; set; }
        [XmlElement(ElementName = "date", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public string Date { get; set; }
        [XmlElement(ElementName = "dateTax", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public string DateTax { get; set; }
        [XmlElement(ElementName = "dateDue", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public string DateDue { get; set; }
        [XmlElement(ElementName = "partnerIdentity", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public PartnerIdentity PartnerIdentity { get; set; }
    }

    [XmlRoot(ElementName = "homeCurrency", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
    public class HomeCurrency
    {
        [XmlElement(ElementName = "unitPrice", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public decimal UnitPrice { get; set; }
        [XmlElement(ElementName = "price", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public decimal Price { get; set; }
        [XmlElement(ElementName = "priceVAT", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public decimal PriceVAT { get; set; }
        [XmlElement(ElementName = "round", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public Round Round { get; set; }
        [XmlElement(ElementName = "priceHighSum", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public decimal PriceHighSum { get; set; }
        [XmlElement(ElementName = "priceNone", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public decimal PriceNone { get; set; }
    }

    [XmlRoot(ElementName = "foreignCurrency", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
    public class ForeignCurrency
    {
        [XmlElement(ElementName = "unitPrice", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public decimal UnitPrice { get; set; }
        [XmlElement(ElementName = "price", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public decimal Price { get; set; }
        [XmlElement(ElementName = "priceVAT", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public decimal PriceVAT { get; set; }
        [XmlElement(ElementName = "currency", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public Currency Currency { get; set; }
        [XmlElement(ElementName = "rate", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public decimal Rate { get; set; }
        [XmlElement(ElementName = "amount", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string Amount { get; set; }
        [XmlElement(ElementName = "priceSum", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public decimal PriceSum { get; set; }
    }

    [XmlRoot(ElementName = "currency", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
    public class Currency
    {
        [XmlElement(ElementName = "ids", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string Ids { get; set; }
    }

    [XmlRoot(ElementName = "invoiceItem", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
    public class InvoiceItem
    {
        [XmlElement(ElementName = "text", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public string Text { get; set; }
        [XmlElement(ElementName = "quantity", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public string Quantity { get; set; }
        [XmlElement(ElementName = "unit", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public string Unit { get; set; }
        [XmlElement(ElementName = "payVAT", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public string PayVAT { get; set; }
        [XmlElement(ElementName = "rateVAT", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public string RateVAT { get; set; }
        [XmlElement(ElementName = "homeCurrency", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public HomeCurrency HomeCurrency { get; set; }
        [XmlElement(ElementName = "foreignCurrency", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public ForeignCurrency ForeignCurrency { get; set; }
        [XmlElement(ElementName = "code", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public string Code { get; set; }
        [XmlElement(ElementName = "stockItem", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public StockItem2 StockItem2 { get; set; }
        [XmlElement(ElementName = "discountPercentage", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public string DiscountPercentage { get; set; }
    }

    [XmlRoot(ElementName = "invoiceDetail", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
    public class InvoiceDetail
    {
        [XmlElement(ElementName = "invoiceItem", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public List<InvoiceItem> InvoiceItems { get; set; }
    }

    [XmlRoot(ElementName = "round", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
    public class Round
    {
        [XmlElement(ElementName = "priceRound", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string PriceRound { get; set; }
    }

    [XmlRoot(ElementName = "invoiceSummary", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
    public class InvoiceSummary
    {
        [XmlElement(ElementName = "roundingDocument", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public string RoundingDocument { get; set; }
        [XmlElement(ElementName = "homeCurrency", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public HomeCurrency HomeCurrency { get; set; }
        [XmlElement(ElementName = "foreignCurrency", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public ForeignCurrency ForeignCurrency { get; set; }
    }

    [XmlRoot(ElementName = "invoice", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
    public class Invoice
    {
        [XmlElement(ElementName = "invoiceHeader", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public InvoiceHeader? InvoiceHeader { get; set; }
        [XmlElement(ElementName = "invoiceDetail", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public InvoiceDetail? InvoiceDetail { get; set; }
        [XmlElement(ElementName = "invoiceSummary", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public InvoiceSummary? InvoiceSummary { get; set; }
        [XmlAttribute(AttributeName = "version")]
        public string Version { get; set; }
    }

    [XmlRoot(ElementName = "dataPackItem", Namespace = "http://www.stormware.cz/schema/version_2/data.xsd")]
    public class DataPackItem
    {
        [XmlElement(ElementName = "invoice", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
        public Invoice? Invoice { get; set; }
        [XmlAttribute(AttributeName = "id")]
        public string Id { get; set; }
        [XmlAttribute(AttributeName = "version")]
        public string Version { get; set; }

        public bool IsValid()
        {
            return Invoice is { InvoiceHeader: not null, InvoiceDetail: not null, InvoiceSummary: not null };
        }
    }

    [XmlRoot(ElementName = "stockItem", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
    public class StockItem
    {
        [XmlElement(ElementName = "ids", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string Ids { get; set; }
    }

    [XmlRoot(ElementName = "stockItem", Namespace = "http://www.stormware.cz/schema/version_2/invoice.xsd")]
    public class StockItem2
    {
        [XmlElement(ElementName = "stockItem", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public StockItem StockItem { get; set; }
    }

    [XmlRoot(ElementName = "shipToAddress", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
    public class ShipToAddress
    {
        [XmlElement(ElementName = "company", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string Company { get; set; }
        [XmlElement(ElementName = "name", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string Name { get; set; }
        [XmlElement(ElementName = "city", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string City { get; set; }
        [XmlElement(ElementName = "street", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string Street { get; set; }
        [XmlElement(ElementName = "zip", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public string Zip { get; set; }
        [XmlElement(ElementName = "country", Namespace = "http://www.stormware.cz/schema/version_2/type.xsd")]
        public Country Country { get; set; }
    }

    [XmlRoot(ElementName = "dataPack", Namespace = "http://www.stormware.cz/schema/version_2/data.xsd")]
    public class DataPack
    {
        [XmlElement(ElementName = "dataPackItem", Namespace = "http://www.stormware.cz/schema/version_2/data.xsd")]
        public List<DataPackItem> DataPackItems { get; set; }
        [XmlAttribute(AttributeName = "id")]
        public string Id { get; set; }
        [XmlAttribute(AttributeName = "ico")]
        public string Ico { get; set; }
        [XmlAttribute(AttributeName = "application")]
        public string Application { get; set; }
        [XmlAttribute(AttributeName = "version")]
        public string Version { get; set; }
        [XmlAttribute(AttributeName = "note")]
        public string Note { get; set; }
        [XmlAttribute(AttributeName = "dat", Namespace = "http://www.w3.org/2000/xmlns/")]
        public string Dat { get; set; }
        [XmlAttribute(AttributeName = "inv", Namespace = "http://www.w3.org/2000/xmlns/")]
        public string Inv { get; set; }
        [XmlAttribute(AttributeName = "typ", Namespace = "http://www.w3.org/2000/xmlns/")]
        public string Typ { get; set; }
    }
}
using System.Globalization;
using System.Text;
using Anela.Heblo.Domain.Features.Catalog.Stock;
using Anela.Heblo.Xcc.Audit;
using CsvHelper;
using CsvHelper.Configuration;
using Microsoft.Extensions.Options;

namespace Anela.Heblo.Adapters.Shoptet.Stock;

public class ShoptetStockClient : IEshopStockClient
{
    private readonly HttpClient _client;
    private readonly IOptions<ShoptetStockClientOptions> _options;
    private readonly IDataLoadAuditService _auditService;

    public ShoptetStockClient(
        HttpClient client,
        IOptions<ShoptetStockClientOptions> options,
        IDataLoadAuditService auditService)
    {
        _client = client;
        _options = options;
        _auditService = auditService;
    }

    public async Task<List<EshopStock>> ListAsync(CancellationToken cancellationToken)
    {
        var startTime = DateTime.UtcNow;
        var parameters = new Dictionary<string, object>
        {
            ["url"] = _options.Value.Url,
            ["encoding"] = "windows-1250",
            ["delimiter"] = ";"
        };

        try
        {
            List<EshopStock> stockDataList = new List<EshopStock>();

            using (HttpResponseMessage response = await _client.GetAsync(_options.Value.Url, cancellationToken))
            using (Stream csvStream = await response.Content.ReadAsStreamAsync(cancellationToken))
            using (StreamReader reader = new StreamReader(csvStream, Encoding.GetEncoding("windows-1250")))
            using (CsvReader csv = new CsvReader(reader, new CsvConfiguration(CultureInfo.InvariantCulture) { Delimiter = ";" }))
            {
                csv.Context.RegisterClassMap<StockDataMap>();
                stockDataList = csv.GetRecords<EshopStock>().ToList();
            }

            var duration = DateTime.UtcNow - startTime;
            await _auditService.LogDataLoadAsync(
                dataType: "Stock",
                source: "Shoptet E-shop",
                recordCount: stockDataList.Count,
                success: true,
                parameters: parameters,
                duration: duration);

            return stockDataList;
        }
        catch (Exception ex)
        {
            var duration = DateTime.UtcNow - startTime;
            await _auditService.LogDataLoadAsync(
                dataType: "Stock",
                source: "Shoptet E-shop",
                recordCount: 0,
                success: false,
                parameters: parameters,
                errorMessage: ex.Message,
                duration: duration);
            throw;
        }
    }

    private class StockDataMap : ClassMap<EshopStock>
    {
        public StockDataMap()
        {
            Map(m => m.Code).Index(0);
            Map(m => m.PairCode).Index(1);
            Map(m => m.Name).Index(2);
            Map(m => m.Stock).Index(17)
                .TypeConverterOption
                .NullValues(string.Empty)
                .Default(0m);
            Map(m => m.NameSuffix).Index(7);
            Map(m => m.Location).Index(18);
        }
    }
}
namespace Anela.Heblo.Adapters.Shoptet.Stock;

public class ShoptetStockClientOptions
{
    public const string SettingsKey = "StockClient";

    public string Url { get; set; } = "http://";
}

using Anela.Heblo.Adapters.Shoptet.Playwright;
using Anela.Heblo.Adapters.Shoptet.Playwright.Scenarios;
using Anela.Heblo.Application.Domain.Logistics.Picking;
using Anela.Heblo.Domain.Features.Logistics.Picking;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

Console.WriteLine("Hello, World!");

var conf = new ConfigurationBuilder()
    .AddUserSecrets<ShoptetPlaywrightInvoiceSource>()
    .Build();

var log = LoggerFactory.Create(b =>
{
    b.SetMinimumLevel(LogLevel.Debug);
}).CreateLogger<PrintPickingListScenario>();

var options = conf.GetSection("Shoptet.Playwright").Get<PlaywrightSourceOptions>();

//var source = new IssuedInvoiceExportScenario(options, NullLogger<ShoptetPlaywrightSource>.Instance);
//await source.RunAsync(new IssuedInvoiceSourceQuery() { InvoiceId = "123008354"});

foreach (var f in Directory.EnumerateFiles(options.PdfTmpFolder))
    File.Delete(f);

var source = new ShoptetPlaywrightExpeditionListSource(new PrintPickingListScenario(options, log, TimeProvider.System));
await source.CreatePickingList(new PrintPickingListRequest(), CancellationToken.None);
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Anela.Heblo.Adapters.Flexi")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+6cd183ef4ac33ad09cbb7ecd6a8b9c35891c45cb")]
[assembly: System.Reflection.AssemblyProductAttribute("Anela.Heblo.Adapters.Flexi")]
[assembly: System.Reflection.AssemblyTitleAttribute("Anela.Heblo.Adapters.Flexi")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
using Anela.Heblo.Application.Domain.Catalog.ConsumedMaterials;
using Anela.Heblo.Domain.Features.Catalog.ConsumedMaterials;
using AutoMapper;
using Microsoft.Extensions.Logging;
using Rem.FlexiBeeSDK.Client;
using Rem.FlexiBeeSDK.Client.Clients.ReceivedInvoices;
using Rem.FlexiBeeSDK.Client.Clients.UserQueries;
using Rem.FlexiBeeSDK.Client.ResultFilters;

namespace Anela.Heblo.Adapters.Flexi.Materials;

public class FlexiConsumedMaterialsQueryClient : UserQueryClient<ConsumedMaterialsFlexiDto>, IConsumedMaterialsClient
{
    private readonly IMapper _mapper;

    public FlexiConsumedMaterialsQueryClient(FlexiBeeSettings connection, IHttpClientFactory httpClientFactory, IResultHandler resultHandler, ILogger<ReceivedInvoiceClient> logger, IMapper mapper)
        : base(connection, httpClientFactory, resultHandler, logger)
    {
        _mapper = mapper;
    }

    protected override int QueryId => 21;

    public Task<IList<ConsumedMaterialsFlexiDto>> GetAsync(DateTime dateFrom, DateTime dateTo, int limit = 0,
        CancellationToken cancellationToken = default(CancellationToken)) =>
        GetAsync(new Dictionary<string, string>()
        {
            { "DATUM_OD", dateFrom.ToString("yyyy-MM-dd") },
            { "DATUM_DO", dateTo.ToString("yyyy-MM-dd") },
            { LimitParamName, limit.ToString() }
        }, cancellationToken);

    public async Task<IReadOnlyList<ConsumedMaterialRecord>> GetConsumedAsync(DateTime dateFrom, DateTime dateTo, int limit = 0, CancellationToken cancellationToken = default)
    {
        var dtos = await GetAsync(dateFrom, dateTo, limit, cancellationToken);

        return _mapper.Map<IReadOnlyList<ConsumedMaterialRecord>>(dtos);
    }
}
using Newtonsoft.Json;

namespace Anela.Heblo.Adapters.Flexi.Materials;

public class ConsumedMaterialsFlexiDto
{
    [JsonProperty("kod")]
    public string ProductCode { get; set; }

    [JsonProperty("nazev")]
    public string ProductName { get; set; }

    [JsonProperty("mnozmj")]
    public double Amount { get; set; }

    [JsonProperty("vydejkadatum")]
    public string Date { get; set; }
}
using System.Globalization;
using Anela.Heblo.Adapters.Flexi.Common;
using Anela.Heblo.Application.Domain.Catalog.ConsumedMaterials;
using Anela.Heblo.Domain.Features.Catalog.ConsumedMaterials;

namespace Anela.Heblo.Adapters.Flexi.Materials;

public class ConsumedMaterialsFlexiDtoProfile : BaseFlexiProfile
{
    public ConsumedMaterialsFlexiDtoProfile()
    {
        var pragueTimeZone = TimeZoneInfo.FindSystemTimeZoneById("Central Europe Standard Time");

        CreateMap<ConsumedMaterialsFlexiDto, ConsumedMaterialRecord>()
            .ForMember(dest => dest.Date, opt => opt.MapFrom(src =>
                TimeZoneInfo.ConvertTimeToUtc(
                    DateTime.SpecifyKind(DateTime.Parse(src.Date, CultureInfo.InvariantCulture), DateTimeKind.Unspecified),
                    pragueTimeZone)));
        // Other properties map directly, DateTime conversion handled by BaseFlexiProfile
    }
}
using Anela.Heblo.Adapters.Flexi.Common;
using Anela.Heblo.Application.Domain.Catalog.Sales;
using Anela.Heblo.Domain.Features.Catalog.Sales;

namespace Anela.Heblo.Adapters.Flexi.Sales;

public class CatalogSalesFlexiDtoProfile : BaseFlexiProfile
{
    public CatalogSalesFlexiDtoProfile()
    {
        // DateTime conversion is handled by BaseFlexiProfile automatically
        CreateMap<CatalogSalesFlexiDto, CatalogSaleRecord>();
    }
}
using Anela.Heblo.Application.Domain.Catalog.Sales;
using Anela.Heblo.Domain.Features.Catalog.Sales;
using Anela.Heblo.Xcc.Audit;
using AutoMapper;
using Microsoft.Extensions.Logging;
using Rem.FlexiBeeSDK.Client;
using Rem.FlexiBeeSDK.Client.Clients.ReceivedInvoices;
using Rem.FlexiBeeSDK.Client.Clients.UserQueries;
using Rem.FlexiBeeSDK.Client.ResultFilters;

namespace Anela.Heblo.Adapters.Flexi.Sales;

public class FlexiCatalogSalesClient : UserQueryClient<CatalogSalesFlexiDto>, ICatalogSalesClient
{
    private readonly IMapper _mapper;
    private readonly IDataLoadAuditService _auditService;
    private const string DateFromParamName = "DATUM_OD";
    private const string DateToParamName = "DATUM_DO";

    public FlexiCatalogSalesClient(
        FlexiBeeSettings connection,
        IHttpClientFactory httpClientFactory,
        IResultHandler resultHandler,
        IMapper mapper,
        ILogger<ReceivedInvoiceClient> logger,
        IDataLoadAuditService auditService
    )
        : base(connection, httpClientFactory, resultHandler, logger)
    {
        _mapper = mapper;
        _auditService = auditService;
    }

    protected override int QueryId => 37;

    public async Task<IList<CatalogSaleRecord>> GetAsync(DateTime dateFrom, DateTime dateTo, int limit = 0, CancellationToken cancellationToken = default)
    {
        var startTime = DateTime.UtcNow;
        var parameters = new Dictionary<string, object>
        {
            ["dateFrom"] = dateFrom.ToString("yyyy-MM-dd"),
            ["dateTo"] = dateTo.ToString("yyyy-MM-dd"),
            ["limit"] = limit
        };

        try
        {
            var pars = new Dictionary<string, string>();
            pars.Add(DateFromParamName, dateFrom.ToString("yyyy-MM-dd"));
            pars.Add(DateToParamName, dateTo.ToString("yyyy-MM-dd"));
            pars.Add(LimitParamName, limit.ToString());

            var flexiSales = await GetAsync(pars, cancellationToken);
            var salesRecords = _mapper.Map<IList<CatalogSalesFlexiDto>, IList<CatalogSaleRecord>>(flexiSales);

            var duration = DateTime.UtcNow - startTime;
            await _auditService.LogDataLoadAsync(
                dataType: "Catalog Sales",
                source: "Flexi ERP",
                recordCount: salesRecords.Count,
                success: true,
                parameters: parameters,
                duration: duration);

            return salesRecords;
        }
        catch (Exception ex)
        {
            var duration = DateTime.UtcNow - startTime;
            await _auditService.LogDataLoadAsync(
                dataType: "Catalog Sales",
                source: "Flexi ERP",
                recordCount: 0,
                success: false,
                parameters: parameters,
                errorMessage: ex.Message,
                duration: duration);
            throw;
        }
    }
}
using Anela.Heblo.Adapters.Flexi.Common;
using Newtonsoft.Json;

namespace Anela.Heblo.Adapters.Flexi.Sales;

public class CatalogSalesFlexiDto
{
    [JsonProperty("datum")]
    [JsonConverter(typeof(UnspecifiedDateTimeConverter))]
    public DateTime Date { get; set; }

    [JsonProperty("produktkod")]
    public string ProductCode { get; set; }

    [JsonProperty("nazevproduktu")]
    public string ProductName { get; set; }

    [JsonProperty("mnozstvi")]
    public double AmountTotal { get; set; }
    [JsonProperty("mnozstvivo")]
    public double AmountB2B { get; set; }
    [JsonProperty("mnozstvimo")]
    public double AmountB2C { get; set; }

    [JsonProperty("suma")]
    public decimal SumTotal { get; set; }
    [JsonProperty("sumavo")]
    public decimal SumB2B { get; set; }
    [JsonProperty("sumamo")]
    public decimal SumB2C { get; set; }
}
using Anela.Heblo.Application.Domain.Catalog.Lots;
using Anela.Heblo.Domain.Features.Catalog.Lots;

namespace Anela.Heblo.Adapters.Flexi.Lots;

public class FlexiLotsClient : ILotsClient
{
    private readonly Rem.FlexiBeeSDK.Client.Clients.Products.StockToDate.ILotsClient _lotsClient;

    public FlexiLotsClient(Rem.FlexiBeeSDK.Client.Clients.Products.StockToDate.ILotsClient lotsClient)
    {
        _lotsClient = lotsClient;
    }

    public async Task<IReadOnlyList<CatalogLot>> GetAsync(string? productCode = null, int limit = 0, int skip = 0, CancellationToken cancellationToken = default)
    {
        var lots = await _lotsClient.GetAsync(productCode, limit, skip, cancellationToken);
        return lots.Select(s => new CatalogLot()
        {
            ProductCode = s.ProductCode,
            Amount = s.Amount,
            Expiration = s.Expiration,
            Lot = s.Lot
        }).ToList();
    }
}
using AutoMapper;

namespace Anela.Heblo.Adapters.Flexi.Common;

/// <summary>
/// Base AutoMapper profile that sets up common DateTime handling for all Flexi adapters.
/// Converts FlexiBee DateTime values from Prague timezone to UTC for application consistency.
/// </summary>
public abstract class BaseFlexiProfile : Profile
{
    protected BaseFlexiProfile()
    {
        // Global DateTime converter - converts FlexiBee Prague time to UTC
        CreateMap<DateTime, DateTime>().ConvertUsing<DateTimeLocalKindConverter>();
    }
}
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace Anela.Heblo.Adapters.Flexi.Common;

/// <summary>
/// Custom JSON converter that converts FlexiBee DateTime values from local timezone to UTC.
/// FlexiBee returns dates in local timezone, but the application uses UTC internally.
/// The application timezone is configured via TZ environment variable at startup.
/// </summary>
public class UnspecifiedDateTimeConverter : IsoDateTimeConverter
{
    public UnspecifiedDateTimeConverter()
    {
        // IsoDateTimeConverter doesn't have DateTimeZoneHandling property
        // We handle timezone conversion in ReadJson method instead
    }

    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
    {
        if (reader.TokenType == JsonToken.Null)
        {
            if (objectType == typeof(DateTime?))
                return null;

            throw new JsonSerializationException($"Cannot convert null value to {objectType}.");
        }

        DateTime parsedDateTime;

        if (reader.TokenType == JsonToken.Date)
        {
            parsedDateTime = (DateTime)reader.Value;
        }
        else if (reader.TokenType == JsonToken.String)
        {
            var dateString = reader.Value.ToString();
            if (!DateTime.TryParse(dateString, out parsedDateTime))
            {
                throw new JsonSerializationException($"Cannot parse DateTime from string: {dateString}");
            }
        }
        else
        {
            throw new JsonSerializationException($"Unexpected token {reader.TokenType} when parsing DateTime.");
        }

        // Treat the parsed DateTime as local time and convert to UTC
        // TimeZoneInfo.Local automatically uses the TZ environment variable set at startup
        var localDateTime = DateTime.SpecifyKind(parsedDateTime, DateTimeKind.Unspecified);
        var utcDateTime = TimeZoneInfo.ConvertTimeToUtc(localDateTime, TimeZoneInfo.Local);

        return utcDateTime;
    }
}
using AutoMapper;

namespace Anela.Heblo.Adapters.Flexi.Common;

/// <summary>
/// AutoMapper type converter that converts FlexiBee DateTime values from local timezone to UTC.
/// FlexiBee returns dates in local timezone, but the application uses UTC internally.
/// The application timezone is configured via TZ environment variable at startup.
/// </summary>
public class DateTimeLocalKindConverter : ITypeConverter<DateTime, DateTime>
{
    public DateTime Convert(DateTime source, DateTime destination, ResolutionContext context)
    {
        // If source is already UTC, return as-is
        if (source.Kind == DateTimeKind.Utc)
            return source;

        // If source is Unspecified or Local, treat as local timezone and convert to UTC
        // TimeZoneInfo.Local automatically uses the TZ environment variable set at startup
        return TimeZoneInfo.ConvertTimeToUtc(source, TimeZoneInfo.Local);
    }
}
using Newtonsoft.Json;

namespace Anela.Heblo.Adapters.Flexi.SemiProducts;

public class SemiProductFlexiDto
{
    [JsonProperty("kod")]
    public string ProductCode { get; set; }
    [JsonProperty("nazev")]
    public string ProductName { get; set; }
}
using Newtonsoft.Json;

namespace Anela.Heblo.Adapters.Flexi.Price;

public class ProductPriceFlexiDto
{
    [JsonProperty("idcenik")]
    public int ProductId { get; set; }

    [JsonProperty("kod")]
    public string ProductCode { get; set; }

    [JsonProperty("cena")]
    public decimal Price { get; set; }

    [JsonProperty("cenanakup")]
    public decimal PurchasePrice { get; set; }

    [JsonProperty("typszbdphk")]
    public string VatLevel { get; set; }

    [JsonProperty("typzasobyk")]
    public string ProductType { get; set; }

    [JsonProperty("idKusovnik")]
    public int? BoMId { get; set; }

    public decimal Vat
    {
        get
        {
            return VatLevel switch
            {
                "ovobozeno" => 0,
                "snížená" => 15,
                _ => 21
            };
        }
    }

    public bool HasCalculatedPurchasePrice => ProductType == "Výrobek";
    public bool HasBillOfMaterials => BoMId != null;
}
namespace Anela.Heblo.Adapters.Flexi.Price;

public class ProductPriceOptions
{
    public const string ConfigKey = "ProductPriceOptions";
    public string ProductExportUrl { get; set; } = "http://";
}
using Anela.Heblo.Application.Domain.Catalog.Price;
using Anela.Heblo.Domain.Features.Catalog.Price;
using Anela.Heblo.Xcc.Audit;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;
using Rem.FlexiBeeSDK.Client;
using Rem.FlexiBeeSDK.Client.Clients.ReceivedInvoices;
using Rem.FlexiBeeSDK.Client.Clients.UserQueries;
using Rem.FlexiBeeSDK.Client.ResultFilters;

namespace Anela.Heblo.Adapters.Flexi.Price;

public class FlexiProductPriceErpClient : UserQueryClient<ProductPriceFlexiDto>, IProductPriceErpClient
{
    private readonly IMemoryCache _cache;
    private readonly IDataLoadAuditService _auditService;
    private const string CacheKey = "FlexiProductPrices";

    public FlexiProductPriceErpClient(
        FlexiBeeSettings connection,
        IHttpClientFactory httpClientFactory,
        IResultHandler resultHandler,
        IMemoryCache cache,
        ILogger<ReceivedInvoiceClient> logger,
        IDataLoadAuditService auditService
    )
        : base(connection, httpClientFactory, resultHandler, logger)
    {
        _cache = cache;
        _auditService = auditService;
    }

    protected override int QueryId => 41;

    public Task<IList<ProductPriceFlexiDto>> GetAsync(int limit = 0, CancellationToken cancellationToken = default) =>
        GetAsync(new Dictionary<string, string>() { { LimitParamName, limit.ToString() } }, cancellationToken);


    public async Task<IEnumerable<ProductPriceErp>> GetAllAsync(bool forceReload, CancellationToken cancellationToken)
    {
        var startTime = DateTime.UtcNow;
        var parameters = new Dictionary<string, object>
        {
            ["forceReload"] = forceReload,
            ["cacheKey"] = CacheKey
        };

        bool dataLoaded = false;
        if (!_cache.TryGetValue(CacheKey, out IList<ProductPriceFlexiDto>? data))
        {
            try
            {
                data = await GetAsync(0, cancellationToken);
                _cache.Set(CacheKey, data, DateTimeOffset.UtcNow.AddMinutes(5));
                dataLoaded = true;
            }
            catch (Exception ex)
            {
                var duration = DateTime.UtcNow - startTime;
                await _auditService.LogDataLoadAsync(
                    dataType: "Product Prices",
                    source: "Flexi ERP",
                    recordCount: 0,
                    success: false,
                    parameters: parameters,
                    errorMessage: ex.Message,
                    duration: duration);
                throw;
            }
        }

        var prices = data!.Select(s => new ProductPriceErp()
        {
            ProductCode = s.ProductCode,
            PriceWithoutVat = s.Price,
            PriceWithVat = s.Price * ((100 + s.Vat) / 100),
            PurchasePrice = s.PurchasePrice,
            PurchasePriceWithVat = s.PurchasePrice * ((100 + s.Vat) / 100)
        }).ToList();

        if (dataLoaded)
        {
            var duration = DateTime.UtcNow - startTime;
            await _auditService.LogDataLoadAsync(
                dataType: "Product Prices",
                source: "Flexi ERP",
                recordCount: prices.Count(),
                success: true,
                parameters: parameters,
                duration: duration);
        }

        return prices;
    }
}
using Anela.Heblo.Xcc.Domain;

namespace Anela.Heblo.Adapters.Flexi.Price;

public class ProductPrice : Entity<string>
{
    public string ProductCode
    {
        get => Id;
        set => Id = value;
    }
    public decimal Price { get; set; }
    public decimal PurchasePrice { get; set; }
    public decimal VatPerc { get; set; }

    public decimal PriceWithVat => Price * ((100 + VatPerc) / (decimal)100);
    public decimal PurchasePriceWithVat => PurchasePrice * ((100 + VatPerc) / (decimal)100);
    public int? BoMId { get; set; }
}
using Anela.Heblo.Application.Domain.Catalog.PurchaseHistory;
using Anela.Heblo.Domain.Features.Catalog.PurchaseHistory;
using Anela.Heblo.Xcc.Audit;
using AutoMapper;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;
using Rem.FlexiBeeSDK.Client;
using Rem.FlexiBeeSDK.Client.Clients.ReceivedInvoices;
using Rem.FlexiBeeSDK.Client.Clients.UserQueries;
using Rem.FlexiBeeSDK.Client.ResultFilters;

namespace Anela.Heblo.Adapters.Flexi.Purchase;

public class FlexiPurchaseHistoryQueryClient : UserQueryClient<PurchaseHistoryFlexiDto>, IPurchaseHistoryClient
{
    private readonly IMemoryCache _cache;
    private readonly IMapper _mapper;
    private readonly IDataLoadAuditService _auditService;

    public FlexiPurchaseHistoryQueryClient(
        FlexiBeeSettings connection,
        IHttpClientFactory httpClientFactory,
        IResultHandler resultHandler,
        ILogger<ReceivedInvoiceClient> logger,
        IMemoryCache cache,
        IMapper mapper,
        IDataLoadAuditService auditService)
        : base(connection, httpClientFactory, resultHandler, logger)
    {
        _cache = cache;
        _mapper = mapper;
        _auditService = auditService;
    }

    protected override int QueryId => 19;

    public Task<IList<PurchaseHistoryFlexiDto>> GetAsync(string? productCode, DateTime dateFrom, DateTime dateTo, int limit = 0,
        CancellationToken cancellationToken = default)
    {
        var query = new Dictionary<string, string>()
        {
            { "DATUM_OD", dateFrom.ToString("yyyy-MM-dd") },
            { "DATUM_DO", dateTo.ToString("yyyy-MM-dd") },
            { LimitParamName, limit.ToString() }
        };

        if (productCode != null)
        {
            query.Add("PRODUCT", productCode);
        }

        return GetAsync(query, cancellationToken);
    }

    public async Task<IReadOnlyList<CatalogPurchaseRecord>> GetHistoryAsync(string? productCode, DateTime dateFrom, DateTime dateTo, int limit = 0, CancellationToken cancellationToken = default)
    {
        var startTime = DateTime.UtcNow;
        var parameters = new Dictionary<string, object>
        {
            ["productCode"] = productCode ?? "all",
            ["dateFrom"] = dateFrom.ToString("yyyy-MM-dd"),
            ["dateTo"] = dateTo.ToString("yyyy-MM-dd"),
            ["limit"] = limit
        };

        if (!_cache.TryGetValue(GetKey(dateFrom, dateTo, limit), out IList<PurchaseHistoryFlexiDto>? purchaseHistory))
        {
            try
            {
                purchaseHistory = await GetAsync(null, dateFrom, dateTo, limit, cancellationToken);
                _cache.Set(GetKey(dateFrom, dateTo, limit), purchaseHistory, DateTimeOffset.Now.AddHours(1));

                var duration = DateTime.UtcNow - startTime;
                await _auditService.LogDataLoadAsync(
                    dataType: "Purchase History",
                    source: "Flexi ERP",
                    recordCount: purchaseHistory.Count,
                    success: true,
                    parameters: parameters,
                    duration: duration);
            }
            catch (Exception ex)
            {
                var duration = DateTime.UtcNow - startTime;
                await _auditService.LogDataLoadAsync(
                    dataType: "Purchase History",
                    source: "Flexi ERP",
                    recordCount: 0,
                    success: false,
                    parameters: parameters,
                    errorMessage: ex.Message,
                    duration: duration);
                throw;
            }
        }

        return _mapper.Map<IReadOnlyList<CatalogPurchaseRecord>>(purchaseHistory!.Where(w => productCode == null || w.ProductCode == productCode).ToList());
    }

    private string GetKey(DateTime dateFrom, DateTime dateTo, int limit) =>
        $"PurchaseHistory_{dateFrom:yyyy-MM-dd}_{dateTo:yyyy-MM-dd}_{limit}";
}
using Anela.Heblo.Adapters.Flexi.Common;
using Anela.Heblo.Application.Domain.Catalog.PurchaseHistory;
using Anela.Heblo.Domain.Features.Catalog.PurchaseHistory;

namespace Anela.Heblo.Adapters.Flexi.Purchase;

public class PurchaseHistoryFlexiDtoProfile : BaseFlexiProfile
{
    public PurchaseHistoryFlexiDtoProfile()
    {
        CreateMap<PurchaseHistoryFlexiDto, CatalogPurchaseRecord>()
            .ForMember(dest => dest.SupplierName, opt => opt.MapFrom(src => src.CompanyName))
            .ForMember(dest => dest.SupplierId, opt => opt.MapFrom(src => src.CompanyId))
            .ForMember(dest => dest.PricePerPiece, opt => opt.MapFrom(src => src.Price))
            .ForMember(dest => dest.PriceTotal, opt => opt.MapFrom(src => src.Price * (decimal)src.Amount))
            .ForMember(dest => dest.DocumentNumber, opt => opt.MapFrom(src => src.PurchaseDocumentNo));
        // DateTime conversion handled automatically by BaseFlexiProfile
    }
}
using Anela.Heblo.Adapters.Flexi.Common;
using Newtonsoft.Json;

namespace Anela.Heblo.Adapters.Flexi.Purchase;

public class PurchaseHistoryFlexiDto
{
    [JsonProperty("Nazev")]
    public string ProductName { get; set; }

    [JsonProperty("Kod")]
    public string ProductCode { get; set; }

    [JsonProperty("Datum")]
    [JsonConverter(typeof(UnspecifiedDateTimeConverter))]
    public DateTime Date { get; set; }

    [JsonProperty("CisloDokladu")]
    public string PurchaseDocumentNo { get; set; }

    [JsonProperty("Mnozstvi")]
    public double Amount { get; set; }

    [JsonProperty("Sklad")]
    public int WarehouseId { get; set; }

    [JsonProperty("CenaMj")]
    public decimal Price { get; set; }

    [JsonProperty("Firma")]
    public string CompanyName { get; set; }

    [JsonProperty("FirmaId")]
    public int? CompanyId { get; set; }
}
﻿using Anela.Heblo.Adapters.Flexi.Lots;
using Anela.Heblo.Adapters.Flexi.Manufacture;
using Anela.Heblo.Adapters.Flexi.Materials;
using Anela.Heblo.Adapters.Flexi.Price;
using Anela.Heblo.Adapters.Flexi.ProductAttributes;
using Anela.Heblo.Adapters.Flexi.Purchase;
using Anela.Heblo.Adapters.Flexi.Sales;
using Anela.Heblo.Adapters.Flexi.Stock;
using Anela.Heblo.Application.Domain.Catalog.Attributes;
using Anela.Heblo.Application.Domain.Catalog.PurchaseHistory;
using Anela.Heblo.Application.Domain.Catalog.Sales;
using Anela.Heblo.Application.Domain.Catalog.Stock;
using Anela.Heblo.Application.Domain.Catalog.ConsumedMaterials;
using Anela.Heblo.Application.Domain.Catalog.Price;
using Anela.Heblo.Application.Domain.Logistics.Transport;
using Anela.Heblo.Application.Domain.Manufacture;
using Anela.Heblo.Domain.Features.Catalog.Attributes;
using Anela.Heblo.Domain.Features.Catalog.ConsumedMaterials;
using Anela.Heblo.Domain.Features.Catalog.Price;
using Anela.Heblo.Domain.Features.Catalog.PurchaseHistory;
using Anela.Heblo.Domain.Features.Catalog.Sales;
using Anela.Heblo.Domain.Features.Catalog.Stock;
using Anela.Heblo.Domain.Features.Manufacture.Domain;
using Anela.Heblo.Xcc.Audit;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Rem.FlexiBeeSDK.Client.Clients.Products.StockTaking;
using Rem.FlexiBeeSDK.Client.Clients.Products.StockToDate;
using Rem.FlexiBeeSDK.Client.DI;

namespace Anela.Heblo.Adapters.Flexi;

public static class FlexiAdapterServiceCollectionExtensions
{
    public static IServiceCollection AddFlexiAdapter(this IServiceCollection services, IConfiguration configuration)
    {

        services.AddFlexiBee(configuration);

        // Configure AutoMapper
        services.AddAutoMapper(typeof(FlexiAdapterServiceCollectionExtensions));

        // Add memory cache for FlexiProductPriceErpClient
        services.AddMemoryCache();

        services.AddHttpClient();

        // Add TimeProvider for FlexiStockClient
        services.AddSingleton(TimeProvider.System);

        services.AddSingleton<IErpStockDomainService, FlexiStockTakingDomainService>();

        services.AddSingleton<ICatalogAttributesClient, FlexiProductAttributesQueryClient>();
        services.AddSingleton<ICatalogSalesClient, FlexiCatalogSalesClient>();
        services.AddSingleton<IConsumedMaterialsClient, FlexiConsumedMaterialsQueryClient>();
        services.AddSingleton<IErpStockClient, FlexiStockClient>();
        services.AddSingleton<IProductPriceErpClient, FlexiProductPriceErpClient>();
        services.AddSingleton<IPurchaseHistoryClient, FlexiPurchaseHistoryQueryClient>();
        services.AddSingleton<IManufactureRepository, FlexiManufactureRepository>();
        services.AddSingleton<ILotsClient, LotsClient>();
        services.AddSingleton<Anela.Heblo.Application.Domain.Catalog.Lots.ILotsClient, FlexiLotsClient>();
        services.AddSingleton<ISeasonalDataParser, SeasonalDataParser>();
        services.AddSingleton<IStockTakingClient, StockTakingClient>();
        services.AddSingleton<IStockTakingItemsClient, StockTakingItemsClient>();

        services.TryAddSingleton<IDataLoadAuditService, InMemoryDataLoadAuditService>();

        return services;
    }
}
namespace Anela.Heblo.Adapters.Flexi.ProductAttributes;

public interface ISeasonalDataParser
{
    int[] GetSeasonalMonths(string? value);
}
using Newtonsoft.Json;

namespace Anela.Heblo.Adapters.Flexi.ProductAttributes;

public class ProductAttributesFlexiDto
{
    public const string ProductType_Product = "VYROBEK";
    public const string ProductType_Material = "MATERIÁL";

    [JsonProperty("cenikid")]
    public int ProductId { get; set; }

    [JsonProperty("cenikkod")]
    public string ProductCode { get; set; }

    [JsonProperty("atributid")]
    public int AttributeId { get; set; }

    [JsonProperty("atributkod")]
    public string AttributeCode { get; set; }

    [JsonProperty("hodnota")]
    public string Value { get; set; }

    [JsonProperty("SkupinaZboziId")]
    public int ProductTypeId { get; set; }

    [JsonProperty("SkupinaZbozi")]
    public string ProductType { get; set; }
}
using Anela.Heblo.Application.Domain.Catalog;
using Anela.Heblo.Application.Domain.Catalog.Attributes;
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Domain.Features.Catalog.Attributes;
using Microsoft.Extensions.Logging;
using Rem.FlexiBeeSDK.Client;
using Rem.FlexiBeeSDK.Client.Clients.ReceivedInvoices;
using Rem.FlexiBeeSDK.Client.Clients.UserQueries;
using Rem.FlexiBeeSDK.Client.ResultFilters;

namespace Anela.Heblo.Adapters.Flexi.ProductAttributes;

public class FlexiProductAttributesQueryClient : UserQueryClient<ProductAttributesFlexiDto>, ICatalogAttributesClient
{
    private readonly ISeasonalDataParser _seasonalDataParser;
    private const int OverstockAttributeId = 80;
    private const int StockMinAttributeId = 81;
    private const int BatchSizeAttributeId = 82;
    private const int SeasonalAttributeId = 84;
    private const int MmqAttributeId = 85;

    public FlexiProductAttributesQueryClient(
        FlexiBeeSettings connection,
        IHttpClientFactory httpClientFactory,
        IResultHandler resultHandler,
        ISeasonalDataParser seasonalDataParser,
        ILogger<ReceivedInvoiceClient> logger
    )
        : base(connection, httpClientFactory, resultHandler, logger)
    {
        _seasonalDataParser = seasonalDataParser;
    }

    protected override int QueryId => 38;

    public Task<IList<ProductAttributesFlexiDto>> GetAsync(int limit = 0, CancellationToken cancellationToken = default) =>
        GetAsync(new Dictionary<string, string>() { { LimitParamName, limit.ToString() } }, cancellationToken);


    public async Task<IList<CatalogAttributes>> GetAttributesAsync(int limit = 0, CancellationToken cancellationToken = default)
    {
        var data = (await GetAsync(limit, cancellationToken));

        return data.GroupBy(g => new { g.ProductId, g.ProductCode, g.ProductType }, (key, values) => new CatalogAttributes()
        {
            ProductId = key.ProductId,
            ProductCode = key.ProductCode,
            ProductType = ParseProductType(key.ProductType),
            OptimalStockDays = StrToIntDef(values.FirstOrDefault(w => w.AttributeId == OverstockAttributeId)?.Value, 0),
            StockMin = StrToIntDef(values.FirstOrDefault(w => w.AttributeId == StockMinAttributeId)?.Value, 0),
            BatchSize = StrToIntDef(values.FirstOrDefault(w => w.AttributeId == BatchSizeAttributeId)?.Value, 0),
            MinimalManufactureQuantity = StrToIntDef(values.FirstOrDefault(w => w.AttributeId == MmqAttributeId)?.Value, 0),
            SeasonMonthsArray = _seasonalDataParser.GetSeasonalMonths(values.FirstOrDefault(w => w.AttributeId == SeasonalAttributeId)?.Value),
        }).ToList();
    }

    private static int StrToIntDef(string? s, int @default)
    {
        int number;
        if (int.TryParse(s, out number))
            return number;
        return @default;
    }




    private static ProductType ParseProductType(string productType)
    {
        return productType switch
        {
            ProductAttributesFlexiDto.ProductType_Product => ProductType.Product,
            ProductAttributesFlexiDto.ProductType_Material => ProductType.Material,

            _ => ProductType.UNDEFINED,
        };
    }
}
namespace Anela.Heblo.Adapters.Flexi.ProductAttributes;

public class SeasonalDataParser : ISeasonalDataParser
{
    public int[] GetSeasonalMonths(string? s)
    {
        if (string.IsNullOrEmpty(s))
            return Array.Empty<int>();

        var months = new List<int>();

        var sections = s.Split(',');
        foreach (var section in sections)
        {
            months.AddRange(ParseSection(section));
        }

        return months.Distinct().OrderBy(o => o).ToArray();
    }

    private IEnumerable<int> ParseSection(string s)
    {
        if (int.TryParse(s, out var single))
        {
            if (single is < 1 or > 12)
                return Array.Empty<int>();
            return new[] { single };
        }

        var range = s.Split('-');
        if (range.Length != 2)
            return Array.Empty<int>();

        if (!int.TryParse(range[0], out var first) || !int.TryParse(range[1], out var second))
            return Array.Empty<int>();

        if (first < 1 || first > 12 || second < 1 || second > 12)
            return Array.Empty<int>();

        if (first > second)
        {
            var retVal = new List<int>();
            retVal.AddRange(Enumerable.Range(first, 12 - first + 1));
            retVal.AddRange(Enumerable.Range(1, second));
            return retVal;
        }
        else
        {
            return Enumerable.Range(first, second - first + 1);
        }
    }
}
using Anela.Heblo.Application.Domain.Catalog.Stock;
using Anela.Heblo.Application.Domain.Users;
using Anela.Heblo.Domain.Features.Catalog.Stock;
using Anela.Heblo.Domain.Features.Users;
using Rem.FlexiBeeSDK.Client.Clients.Products.StockTaking;
using Rem.FlexiBeeSDK.Model.Products.StockTaking;

namespace Anela.Heblo.Adapters.Flexi.Stock;


public class FlexiStockTakingDomainService : IErpStockDomainService
{
    private readonly IStockTakingRepository _stockTakingRepository;
    private readonly IStockTakingClient _stockTakingClient;
    private readonly IStockTakingItemsClient _stockTakingItemsClient;
    private readonly ICurrentUserService _currentUser;
    private readonly TimeProvider _timeProvider;

    private const int MaterialWarehouseId = 5;
    private const string OwnerName = "Heblo";
    private const string MaterialStockTakingType = "Material";
    private const int SubmitDocumentTypeId = 60;

    public FlexiStockTakingDomainService(
        IStockTakingRepository stockTakingRepository,
        IStockTakingClient stockTakingClient,
        IStockTakingItemsClient stockTakingItemsClient,
        ICurrentUserService currentUser,
        TimeProvider timeProvider)
    {
        _stockTakingRepository = stockTakingRepository;
        _stockTakingClient = stockTakingClient;
        _stockTakingItemsClient = stockTakingItemsClient;
        _currentUser = currentUser;
        _timeProvider = timeProvider;
    }


    public async Task<StockTakingRecord> SubmitStockTakingAsync(ErpStockTakingRequest order)
    {
        try
        {
            StockTakingRecord result;
            if (!order.SoftStockTaking) // No real stock taking, just a record in DB
            {
                var headerRequest = new StockTakingHeaderRequest
                {
                    WarehouseId = MaterialWarehouseId,
                    Date = _timeProvider.GetUtcNow().DateTime,
                    Executer = _currentUser.GetCurrentUser().Name,
                    Owner = OwnerName,
                    Type = $"{MaterialStockTakingType}-{order.ProductCode}",
                };
                var header = await _stockTakingClient.CreateHeaderAsync(headerRequest);

                var newItems = order.StockTakingItems.Select(item => new AddStockTakingItemRequest
                {
                    ProductCode = order.ProductCode,
                    Amount = item.Amount,
                    Lot = item.LotCode ?? "",
                    Expiration = item.Expiration?.ToString("yyyy-MM-dd") ?? "",
                }).ToList();

                await _stockTakingItemsClient.AddStockTakingsAsync(header.Id, MaterialWarehouseId, newItems);

                if (order.RemoveMissingLots)
                {
                    var currentItems = await _stockTakingItemsClient.GetStockTakingsAsync(header.Id);
                    var productIds = currentItems.Select(i => i.ProductId).ToList();
                    await _stockTakingClient.AddMissingLotsAsync(header.Id, productIds);
                }

                var itemsBefore = await _stockTakingItemsClient.GetStockTakingsAsync(header.Id);
                if (!order.DryRun)
                {
                    await _stockTakingClient.SubmitAsync(header.Id, SubmitDocumentTypeId);
                }


                header = await _stockTakingClient.GetHeaderAsync(header.Id);
                var itemsAfter = await _stockTakingItemsClient.GetStockTakingsAsync(header.Id);

                result = new StockTakingRecord()
                {
                    Code = order.ProductCode,
                    AmountNew = itemsAfter.Sum(s => s.AmountFound),
                    AmountOld = itemsBefore.Sum(s => s.AmountErp),
                };
            }
            else
            {
                result = new StockTakingRecord()
                {
                    Code = order.ProductCode,
                    AmountNew = (double)order.StockTakingItems.Sum(s => s.Amount), // TODO COnvert to decimal
                    AmountOld = (double)order.StockTakingItems.Sum(s => s.Amount), // TODO COnvert to decimal
                };
            }
            result.User = _currentUser.GetCurrentUser().Name;
            result.Date = _timeProvider.GetUtcNow().DateTime;
            result.Type = StockTakingType.Erp;
            await _stockTakingRepository.AddAsync(result);
            return result;
        }
        catch (Exception e)
        {
            return new StockTakingRecord
            {
                Date = _timeProvider.GetUtcNow().DateTime,
                Code = order.ProductCode,
                AmountNew = (double)order.StockTakingItems.Sum(s => s.Amount), // TODO COnvert to decimal
                Error = e.Message
            };
        }
    }
}
using Anela.Heblo.Application.Domain.Catalog;
using Anela.Heblo.Application.Domain.Catalog.Stock;
using Anela.Heblo.Domain.Features.Catalog;
using Anela.Heblo.Domain.Features.Catalog.Stock;
using Anela.Heblo.Xcc.Audit;
using Rem.FlexiBeeSDK.Client.Clients.Products.StockToDate;

namespace Anela.Heblo.Adapters.Flexi.Stock;

public class FlexiStockClient : IErpStockClient
{
    private const int MaterialWarehouseId = 5;
    private const int SemiProductsWarehouseId = 20;
    private const int ProductsWarehouseId = 4;

    private readonly IStockToDateClient _stockClient;
    private readonly TimeProvider _timeProvider;
    private readonly IDataLoadAuditService _auditService;

    public FlexiStockClient(IStockToDateClient stockClient, TimeProvider timeProvider, IDataLoadAuditService auditService)
    {
        _stockClient = stockClient;
        _timeProvider = timeProvider;
        _auditService = auditService;
    }

    public async Task<IReadOnlyList<ErpStock>> ListAsync(CancellationToken cancellationToken)
    {
        var materialStockTask = ListByWarehouse(MaterialWarehouseId, ProductType.Material, cancellationToken);
        var semiProductsStockTask = ListByWarehouse(SemiProductsWarehouseId, ProductType.SemiProduct, cancellationToken);
        var productsStockTask = ListByWarehouse(ProductsWarehouseId, new[] { ProductType.Product, ProductType.Goods }, cancellationToken);

        await Task.WhenAll(materialStockTask, semiProductsStockTask, productsStockTask);

        return materialStockTask.Result
            .Union(semiProductsStockTask.Result)
            .Union(productsStockTask.Result)
            .ToList();
    }


    private Task<IReadOnlyList<ErpStock>> ListByWarehouse(int warehouseId, ProductType productType,
        CancellationToken cancellationToken)
    {
        return ListByWarehouse(warehouseId, new[] { productType }, cancellationToken);
    }

    private async Task<IReadOnlyList<ErpStock>> ListByWarehouse(int warehouseId, ProductType[] productTypes, CancellationToken cancellationToken)
    {
        var startTime = DateTime.UtcNow;
        var parameters = new Dictionary<string, object>
        {
            ["warehouseId"] = warehouseId,
            ["productTypes"] = string.Join(", ", productTypes),
            ["date"] = _timeProvider.GetUtcNow().Date
        };

        try
        {
            var stockToDate = await _stockClient
                .GetAsync(_timeProvider.GetUtcNow().Date, warehouseId: warehouseId, cancellationToken: cancellationToken);

            var productTypeIds = productTypes.Select(i => (int?)i).ToList();
            var stock = stockToDate
                .Where(w => productTypeIds.Contains(w.ProductTypeId))
                .Select(s => new ErpStock
                {
                    ProductCode = s.ProductCode,
                    ProductName = s.ProductName,
                    ProductTypeId = s.ProductTypeId,
                    ProductId = s.ProductId,
                    Stock = (decimal)s.OnStock,
                    MOQ = s.MoqName,
                    HasLots = s.HasLots,
                    HasExpiration = s.HasExpiration,
                    Volume = s.Volume,
                    Weight = s.Weight
                }).ToList();

            var duration = DateTime.UtcNow - startTime;
            await _auditService.LogDataLoadAsync(
                dataType: "Stock",
                source: "Flexi ERP",
                recordCount: stock.Count,
                success: true,
                parameters: parameters,
                duration: duration);

            return stock;
        }
        catch (Exception ex)
        {
            var duration = DateTime.UtcNow - startTime;
            await _auditService.LogDataLoadAsync(
                dataType: "Stock",
                source: "Flexi ERP",
                recordCount: 0,
                success: false,
                parameters: parameters,
                errorMessage: ex.Message,
                duration: duration);
            throw;
        }
    }
}
namespace Anela.Heblo.Adapters.Flexi.Manufacture;

public static class FlexiExtensions
{
    public static string RemoveCodePrefix(this string code)
    {
        if (code == null) return null;

        // First trim the string
        var trimmed = code.Trim();

        // Only remove first occurrence of "code:" if it's at the beginning
        if (trimmed.StartsWith("code:"))
        {
            return trimmed.Substring(5).Trim();
        }

        return trimmed;
    }
}
using Anela.Heblo.Application.Domain.Manufacture;
using Anela.Heblo.Domain.Features.Manufacture.Domain;
using Rem.FlexiBeeSDK.Client.Clients.Products.BoM;

namespace Anela.Heblo.Adapters.Flexi.Manufacture;

public class FlexiManufactureRepository : IManufactureRepository
{
    private readonly IBoMClient _bomClient;

    public FlexiManufactureRepository(IBoMClient bomClient)
    {
        _bomClient = bomClient;
    }

    public async Task<ManufactureTemplate> GetManufactureTemplateAsync(string id, CancellationToken cancellationToken = default)
    {
        var bom = await _bomClient.GetAsync(id, cancellationToken);

        var header = bom.SingleOrDefault(s => s.Level == 1) ?? throw new ApplicationException(message: $"No BoM header for product {id} found");
        var ingredients = bom.Where(w => w.Level != 1);

        return new ManufactureTemplate()
        {
            TemplateId = header.Id,
            ProductCode = header.IngredientCode.RemoveCodePrefix(),
            ProductName = header.IngredientFullName,
            Amount = header.Amount,
            Ingredients = ingredients.Select(s =>
            {
                return new Ingredient()
                {
                    TemplateId = s.Id,
                    ProductCode = s.IngredientCode.RemoveCodePrefix(),
                    ProductName = s.IngredientFullName,
                    Amount = s.Amount,
                };
            }).ToList(),
        };
    }

    public async Task<List<ManufactureTemplate>> FindByIngredientAsync(string ingredientCode, CancellationToken cancellationToken)
    {
        var templates = await _bomClient.GetByIngredientAsync(ingredientCode, cancellationToken);

        return templates
                .Select(s => new ManufactureTemplate()
                {
                    ProductCode = s.ParentCode.RemoveCodePrefix(),
                    ProductName = s.ParentFullName,
                    Amount = s.Amount,
                    TemplateId = s.Id
                })
        .Where(w => w.ProductCode != ingredientCode)
        .ToList();
    }
}
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
// <auto-generated/>
global using global::Microsoft.AspNetCore.Builder;
global using global::Microsoft.AspNetCore.Hosting;
global using global::Microsoft.AspNetCore.Http;
global using global::Microsoft.AspNetCore.Routing;
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Hosting;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Net.Http.Json;
global using global::System.Threading;
global using global::System.Threading.Tasks;
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Microsoft.Identity.Web")]
[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("NSwag.AspNetCore")]
[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("NSwag.Generation.AspNetCore")]
[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Swashbuckle.AspNetCore.SwaggerGen")]

// Generated by the MSBuild WriteCodeFragment class.

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: Microsoft.Extensions.Configuration.UserSecrets.UserSecretsIdAttribute("f4e6382a-aefd-47ef-9cd7-7e12daac7e45")]
[assembly: System.Reflection.AssemblyCompanyAttribute("Anela.Heblo.API")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+6cd183ef4ac33ad09cbb7ecd6a8b9c35891c45cb")]
[assembly: System.Reflection.AssemblyProductAttribute("Anela.Heblo.API")]
[assembly: System.Reflection.AssemblyTitleAttribute("Anela.Heblo.API")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

// <auto-generated/>
global using global::Microsoft.AspNetCore.Builder;
global using global::Microsoft.AspNetCore.Hosting;
global using global::Microsoft.AspNetCore.Http;
global using global::Microsoft.AspNetCore.Routing;
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Hosting;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Net.Http.Json;
global using global::System.Threading;
global using global::System.Threading.Tasks;
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Microsoft.Identity.Web")]
[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("NSwag.AspNetCore")]
[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("NSwag.Generation.AspNetCore")]
[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Swashbuckle.AspNetCore.SwaggerGen")]

// Generated by the MSBuild WriteCodeFragment class.

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: Microsoft.Extensions.Configuration.UserSecrets.UserSecretsIdAttribute("f4e6382a-aefd-47ef-9cd7-7e12daac7e45")]
[assembly: System.Reflection.AssemblyCompanyAttribute("Anela.Heblo.API")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+9f8b5e0449b1e02989c00ecb8a19f29a2282d2c4")]
[assembly: System.Reflection.AssemblyProductAttribute("Anela.Heblo.API")]
[assembly: System.Reflection.AssemblyTitleAttribute("Anela.Heblo.API")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]
namespace Anela.Heblo.API.Extensions;

public static class TimeZoneExtensions
{
    public static void ConfigureApplicationTimeZone(this IConfiguration configuration)
    {
        // Get timezone ID from configuration or environment variable
        var timeZoneId = Environment.GetEnvironmentVariable("TIMEZONE")
                        ?? configuration["Application:TimeZone"]
                        ?? "Central Europe Standard Time";

        // Set system timezone environment variable for consistent behavior
        var systemTimeZoneId = GetSystemTimeZoneId(timeZoneId);
        Environment.SetEnvironmentVariable("TZ", systemTimeZoneId);
        TimeZoneInfo.ClearCachedData(); // Clear any cached timezone data to force reload
    }

    private static string GetSystemTimeZoneId(string windowsTimeZoneId)
    {
        // Map Windows timezone IDs to IANA timezone IDs for cross-platform compatibility
        return windowsTimeZoneId switch
        {
            "Central Europe Standard Time" => "Europe/Prague",
            "Central European Standard Time" => "Europe/Prague",
            _ => "Europe/Prague" // Default fallback
        };
    }
}
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using HealthChecks.UI.Client;
using Anela.Heblo.Application.Features.Configuration.Domain;
using Anela.Heblo.Domain.Features.Configuration;

namespace Anela.Heblo.API.Extensions;

public static class ApplicationBuilderExtensions
{
    public static WebApplication ConfigureApplicationPipeline(this WebApplication app)
    {
        // Configure the HTTP request pipeline
        if (app.Environment.IsDevelopment())
        {
            app.UseSwagger();
            app.UseSwaggerUI(options =>
            {
                // Only configure OAuth2 for Swagger UI if mock auth is disabled
                var useMockAuth = app.Configuration.GetValue<bool>("UseMockAuth", false);

                if (!useMockAuth)
                {
                    // Configure OAuth2 for Swagger UI
                    var azureAdConfig = app.Configuration.GetSection("AzureAd");
                    var clientId = azureAdConfig["ClientId"];
                    var scopes = azureAdConfig["Scopes"];

                    if (!string.IsNullOrEmpty(clientId))
                    {
                        // OAuth2 configuration for Swagger UI
                        options.OAuthClientId(clientId);
                        options.OAuthUsePkce();
                        options.OAuthScopeSeparator(" ");
                        options.OAuthAppName("Anela Heblo API");

                        // Additional OAuth2 settings for better UX
                        options.OAuthUseBasicAuthenticationWithAccessCodeGrant();

                        // Pre-fill scopes if available
                        if (!string.IsNullOrEmpty(scopes))
                        {
                            var scopeArray = scopes.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                            options.OAuthScopes(scopeArray);
                        }
                        else
                        {
                            // Fallback to API scope
                            options.OAuthScopes($"api://{clientId}/access_as_user");
                        }
                    }
                }

                // Enable additional Swagger UI features (always)
                options.EnableDeepLinking();
                options.DisplayRequestDuration();
            });
            app.UseOpenApi();
        }

        app.UseHttpsRedirection();

        // Built-in HTTP request logging
        app.UseHttpLogging();

        // Use CORS
        app.UseCors(ConfigurationConstants.CORS_POLICY_NAME);

        app.UseAuthentication();
        app.UseAuthorization();

        // Serve static files from wwwroot
        app.UseStaticFiles();

        // If not in development, also use SPA static files
        if (!app.Environment.IsDevelopment())
        {
            app.UseSpaStaticFiles();
        }

        app.MapControllers();

        app.ConfigureHealthCheckEndpoints();

        app.ConfigureSpaFallback();

        return app;
    }

    public static WebApplication ConfigureHealthCheckEndpoints(this WebApplication app)
    {
        // Map health check endpoints
        app.MapHealthChecks("/health");
        app.MapHealthChecks("/health/ready", new HealthCheckOptions
        {
            Predicate = check => check.Tags.Contains(ConfigurationConstants.DB_TAG),
            ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
        });
        app.MapHealthChecks("/health/live", new HealthCheckOptions
        {
            Predicate = _ => false,  // Only app liveness, no dependencies
            ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
        });

        return app;
    }

    public static WebApplication ConfigureSpaFallback(this WebApplication app)
    {
        // SPA fallback - must be after MapControllers
        if (!app.Environment.IsDevelopment())
        {
            app.UseSpa(spa =>
            {
                spa.Options.SourcePath = "wwwroot";
                spa.Options.DefaultPageStaticFileOptions = new StaticFileOptions
                {
                    OnPrepareResponse = context =>
                    {
                        // Prevent caching of index.html
                        context.Context.Response.Headers.Append("Cache-Control", "no-cache, no-store, must-revalidate");
                        context.Context.Response.Headers.Append("Pragma", "no-cache");
                        context.Context.Response.Headers.Append("Expires", "0");
                    }
                };
            });
        }

        return app;
    }
}
using Microsoft.ApplicationInsights.AspNetCore.Extensions;
using Microsoft.ApplicationInsights.Extensibility;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using HealthChecks.UI.Client;
using Anela.Heblo.Application.Features.Configuration.Domain;
using Anela.Heblo.Xcc.Telemetry;
using Anela.Heblo.Application.Domain.Users;
using Anela.Heblo.API.Infrastructure.Telemetry;
using Anela.Heblo.Application.Features.Users;
using Anela.Heblo.Domain.Features.Configuration;
using Anela.Heblo.Domain.Features.Users;
using Microsoft.OpenApi.Models;

namespace Anela.Heblo.API.Extensions;

public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddApplicationInsightsServices(this IServiceCollection services, IConfiguration configuration, IWebHostEnvironment environment)
    {
        var appInsightsConnectionString = configuration[ConfigurationConstants.APPLICATION_INSIGHTS_CONNECTION_STRING]
                                        ?? configuration[ConfigurationConstants.APPINSIGHTS_INSTRUMENTATION_KEY]
                                        ?? configuration[ConfigurationConstants.APPLICATIONINSIGHTS_CONNECTION_STRING];

        if (!string.IsNullOrEmpty(appInsightsConnectionString))
        {
            services.AddApplicationInsightsTelemetry(new ApplicationInsightsServiceOptions
            {
                ConnectionString = appInsightsConnectionString,
                EnableAdaptiveSampling = true,
                EnableQuickPulseMetricStream = true,
                EnableDependencyTrackingTelemetryModule = true,
                EnablePerformanceCounterCollectionModule = true,
                EnableRequestTrackingTelemetryModule = true,
                EnableEventCounterCollectionModule = true,
                EnableAppServicesHeartbeatTelemetryModule = true,
                DeveloperMode = environment.IsDevelopment()
            });

            // Configure Cloud Role for environment identification
            services.Configure<TelemetryConfiguration>(telemetryConfig =>
            {
                var cloudRole = configuration["ApplicationInsights:CloudRole"] ?? "Heblo-API";
                var cloudRoleInstance = configuration["ApplicationInsights:CloudRoleInstance"] ?? environment.EnvironmentName;

                telemetryConfig.TelemetryInitializers.Add(new CloudRoleInitializer(cloudRole, cloudRoleInstance));
            });

            services.AddSingleton<ITelemetryService, TelemetryService>();
        }
        else
        {
            services.AddSingleton<ITelemetryService, NoOpTelemetryService>();
        }

        return services;
    }

    public static IServiceCollection AddCorsServices(this IServiceCollection services, IConfiguration configuration)
    {
        var allowedOrigins = configuration.GetSection(ConfigurationConstants.CORS_ALLOWED_ORIGINS).Get<string[]>() ?? Array.Empty<string>();

        services.AddCors(options =>
        {
            options.AddPolicy(ConfigurationConstants.CORS_POLICY_NAME, policy =>
            {
                policy.WithOrigins(allowedOrigins)
                      .AllowAnyHeader()
                      .AllowAnyMethod()
                      .AllowCredentials();
            });
        });

        return services;
    }

    public static IServiceCollection AddHealthCheckServices(this IServiceCollection services, IConfiguration configuration)
    {
        var healthChecksBuilder = services.AddHealthChecks();

        // Add database health check if connection string exists
        var dbConnectionString = configuration.GetConnectionString(ConfigurationConstants.DEFAULT_CONNECTION);
        if (!string.IsNullOrEmpty(dbConnectionString))
        {
            healthChecksBuilder.AddNpgSql(dbConnectionString,
                name: ConfigurationConstants.DATABASE_HEALTH_CHECK,
                tags: new[] { ConfigurationConstants.DB_TAG, ConfigurationConstants.POSTGRESQL_TAG });
        }

        return services;
    }

    public static IServiceCollection AddCrossCuttingServices(this IServiceCollection services)
    {
        // Register HttpContextAccessor for user service
        services.AddHttpContextAccessor();

        // Register TimeProvider
        services.AddSingleton(TimeProvider.System);

        // Register Current User Service
        services.AddSingleton<ICurrentUserService, CurrentUserService>();

        // Built-in HTTP request logging
        services.AddHttpLogging(logging =>
        {
            logging.LoggingFields = Microsoft.AspNetCore.HttpLogging.HttpLoggingFields.All;
            logging.RequestHeaders.Add("User-Agent");
            logging.RequestHeaders.Add("Authorization");
            logging.ResponseHeaders.Add("Content-Type");
            logging.MediaTypeOptions.AddText("application/json");
            logging.RequestBodyLogLimit = 4096;
            logging.ResponseBodyLogLimit = 4096;
        });

        // Note: Application services are now registered in vertical slice modules
        // This method is kept for backward compatibility and other cross-cutting concerns

        return services;
    }

    public static IServiceCollection AddSpaServices(this IServiceCollection services)
    {
        services.AddSpaStaticFiles(configuration =>
        {
            configuration.RootPath = "wwwroot";
        });

        return services;
    }

    public static IServiceCollection AddSwaggerServices(this IServiceCollection services, IConfiguration configuration)
    {
        services.AddEndpointsApiExplorer();
        services.AddSwaggerGen(options =>
        {
            options.SwaggerDoc("v1", new OpenApiInfo
            {
                Title = "Anela Heblo API",
                Version = "v1",
                Description = "API for Anela Heblo cosmetics company workspace application"
            });

            // Only add authentication to Swagger if mock auth is disabled
            var useMockAuth = configuration.GetValue<bool>("UseMockAuth", false);

            if (!useMockAuth)
            {
                // Add Microsoft Entra ID OAuth2 authentication
                var azureAdConfig = configuration.GetSection("AzureAd");
                var tenantId = azureAdConfig["TenantId"];
                var clientId = azureAdConfig["ClientId"];
                var configuredScopes = azureAdConfig["Scopes"];

                if (!string.IsNullOrEmpty(tenantId) && !string.IsNullOrEmpty(clientId))
                {
                    // Build scopes dictionary
                    var scopes = new Dictionary<string, string>();

                    if (!string.IsNullOrEmpty(configuredScopes))
                    {
                        // Use configured scopes from appsettings
                        foreach (var scope in configuredScopes.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                        {
                            var description = scope switch
                            {
                                "openid" => "OpenID Connect sign-in",
                                "profile" => "Access user profile information",
                                "User.Read" => "Read user profile",
                                _ when scope.StartsWith("api://") => "Access the API as the signed-in user",
                                _ => $"Access {scope}"
                            };
                            scopes[scope] = description;
                        }
                    }
                    else
                    {
                        // Fallback to API scope
                        scopes[$"api://{clientId}/access_as_user"] = "Access the API as the signed-in user";
                    }

                    options.AddSecurityDefinition("OAuth2", new OpenApiSecurityScheme
                    {
                        Type = SecuritySchemeType.OAuth2,
                        Description = "Authenticate using Microsoft Entra ID (Azure AD)",
                        Flows = new OpenApiOAuthFlows
                        {
                            AuthorizationCode = new OpenApiOAuthFlow
                            {
                                AuthorizationUrl = new Uri($"https://login.microsoftonline.com/{tenantId}/oauth2/v2.0/authorize"),
                                TokenUrl = new Uri($"https://login.microsoftonline.com/{tenantId}/oauth2/v2.0/token"),
                                Scopes = scopes
                            }
                        }
                    });

                    // Security requirement - OAuth2 only
                    // Determine required scopes for OAuth2 security requirement
                    var requiredScopes = new List<string>();
                    if (!string.IsNullOrEmpty(configuredScopes))
                    {
                        requiredScopes.AddRange(configuredScopes.Split(' ', StringSplitOptions.RemoveEmptyEntries));
                    }
                    else
                    {
                        requiredScopes.Add($"api://{clientId}/access_as_user");
                    }

                    options.AddSecurityRequirement(new OpenApiSecurityRequirement
                    {
                        {
                            new OpenApiSecurityScheme
                            {
                                Reference = new OpenApiReference
                                {
                                    Type = ReferenceType.SecurityScheme,
                                    Id = "OAuth2"
                                }
                            },
                            requiredScopes.ToArray()
                        }
                    });
                }
            }
        });

        return services;
    }
}
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.Identity.Web;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Anela.Heblo.Application.Features.Configuration.Domain;
using Microsoft.IdentityModel.Tokens;
using System.Security;
using Anela.Heblo.API.Infrastructure.Authentication;
using Anela.Heblo.Domain.Features.Configuration;

namespace Anela.Heblo.API.Extensions;

public static class AuthenticationExtensions
{
    public static IServiceCollection ConfigureAuthentication(this IServiceCollection services, WebApplicationBuilder builder, ILogger logger)
    {
        // Mock authentication is ONLY controlled by UseMockAuth configuration variable
        // Environment name does NOT influence authentication mode (per updated specification)
        var useMockAuth = builder.Configuration.GetValue<bool>(ConfigurationConstants.USE_MOCK_AUTH, defaultValue: false);
        var bypassJwtValidation = builder.Configuration.GetValue<bool>(ConfigurationConstants.BYPASS_JWT_VALIDATION, defaultValue: false);

        // Log authentication mode for debugging
        logger.LogInformation("Authentication Configuration - Environment: {Environment}, UseMockAuth: {UseMockAuth}, BypassJwtValidation: {BypassJwtValidation}",
            builder.Environment.EnvironmentName, useMockAuth, bypassJwtValidation);

        // Determine authentication strategy
        if (bypassJwtValidation || useMockAuth)
        {
            logger.LogInformation("Configuring Mock Authentication");
            ConfigureMockAuthentication(services);
        }
        else
        {
            logger.LogInformation("Configuring Microsoft Identity Authentication");
            ConfigureRealAuthentication(services, builder);
        }

        return services;
    }

    private static void ConfigureMockAuthentication(IServiceCollection services)
    {
        // Mock authentication - can be used in any environment when UseMockAuth=true
        services.AddAuthentication(ConfigurationConstants.MOCK_AUTH_SCHEME)
            .AddScheme<MockAuthenticationSchemeOptions, MockAuthenticationHandler>(ConfigurationConstants.MOCK_AUTH_SCHEME, _ => { });
        services.AddAuthorization();

        // Register a null GraphServiceClient for mock authentication
        // services.AddSingleton<Microsoft.Graph.GraphServiceClient?>(provider => null);
    }

    private static void ConfigureRealAuthentication(IServiceCollection services, WebApplicationBuilder builder)
    {
        // Real Microsoft Identity authentication
        // Use standard Microsoft Identity Web API authentication (recommended)
        // This includes proper JWT validation, signing keys, issuer and audience validation
        services.AddMicrosoftIdentityWebApiAuthentication(builder.Configuration, "AzureAd")
            .EnableTokenAcquisitionToCallDownstreamApi()
            // .AddMicrosoftGraph(builder.Configuration.GetSection("DownstreamApi"))
            .AddInMemoryTokenCaches();
    }

}
using Anela.Heblo.Application.Features.Configuration.Domain;
using Anela.Heblo.Domain.Features.Configuration;

namespace Anela.Heblo.API.Extensions;

public static class LoggingExtensions
{
    public static ILoggingBuilder ConfigureApplicationLogging(this ILoggingBuilder logging, IConfiguration configuration, IWebHostEnvironment environment)
    {
        // Clear providers and add console logging for container stdout
        logging.ClearProviders();
        logging.AddConsole();

        // Configure logging levels from configuration
        logging.AddConfiguration(configuration.GetSection("Logging"));

        // Add Application Insights logging if configured
        var appInsightsConnectionString = configuration[ConfigurationConstants.APPLICATION_INSIGHTS_CONNECTION_STRING]
                                        ?? configuration[ConfigurationConstants.APPINSIGHTS_INSTRUMENTATION_KEY]
                                        ?? configuration[ConfigurationConstants.APPLICATIONINSIGHTS_CONNECTION_STRING];

        if (!string.IsNullOrEmpty(appInsightsConnectionString))
        {
            logging.AddApplicationInsights(
                configureTelemetryConfiguration: (config) => config.ConnectionString = appInsightsConnectionString,
                configureApplicationInsightsLoggerOptions: (options) => { }
            );
        }

        // Add structured logging for better Application Insights experience  
        if (environment.IsProduction())
        {
            logging.AddFilter("Microsoft.AspNetCore", LogLevel.Warning);
            logging.AddFilter("Microsoft.EntityFrameworkCore", LogLevel.Warning);
            logging.AddFilter("Microsoft.AspNetCore.Hosting.Diagnostics", LogLevel.Information); // Keep startup logs
            logging.AddFilter("Microsoft.AspNetCore.HttpLogging", LogLevel.Information); // Built-in request logging
        }
        else
        {
            // Development: Show more detailed logs
            logging.AddFilter("Microsoft.AspNetCore.Hosting.Diagnostics", LogLevel.Information);
            logging.AddFilter("Microsoft.AspNetCore.HttpLogging", LogLevel.Information); // Built-in request logging
            logging.AddFilter("Anela.Heblo", LogLevel.Debug);
        }

        return logging;
    }
}
using Microsoft.ApplicationInsights.Channel;
using Microsoft.ApplicationInsights.Extensibility;

namespace Anela.Heblo.API.Infrastructure.Telemetry;

public class CloudRoleInitializer : ITelemetryInitializer
{
    private readonly string _cloudRoleName;
    private readonly string _cloudRoleInstance;

    public CloudRoleInitializer(string cloudRoleName, string cloudRoleInstance)
    {
        _cloudRoleName = cloudRoleName;
        _cloudRoleInstance = cloudRoleInstance;
    }

    public void Initialize(ITelemetry telemetry)
    {
        telemetry.Context.Cloud.RoleName = _cloudRoleName;
        telemetry.Context.Cloud.RoleInstance = _cloudRoleInstance;
    }
}
using System.Security.Claims;
using System.Text.Encodings.Web;
using Microsoft.AspNetCore.Authentication;
using Microsoft.Extensions.Options;

namespace Anela.Heblo.API.Infrastructure.Authentication;

public class MockAuthenticationSchemeOptions : AuthenticationSchemeOptions
{
}

public class MockAuthenticationHandler : AuthenticationHandler<MockAuthenticationSchemeOptions>
{
    public MockAuthenticationHandler(IOptionsMonitor<MockAuthenticationSchemeOptions> options,
        ILoggerFactory logger, UrlEncoder encoder, ISystemClock clock)
        : base(options, logger, encoder, clock)
    {
    }

    protected override Task<AuthenticateResult> HandleAuthenticateAsync()
    {
        var claims = new[]
        {
            new Claim(ClaimTypes.NameIdentifier, "mock-user-id"),
            new Claim(ClaimTypes.Name, "Mock User"),
            new Claim(ClaimTypes.Email, "mock@anela-heblo.com"),
            new Claim("preferred_username", "mock@anela-heblo.com"),
            new Claim("name", "Mock User"),
            new Claim("given_name", "Mock"),
            new Claim("family_name", "User"),
            // Add Entra ID specific claims
            new Claim("oid", "00000000-0000-0000-0000-000000000000"), // Object ID
            new Claim("tid", "11111111-1111-1111-1111-111111111111"), // Tenant ID
            new Claim("roles", "User"), // Add roles as needed
            new Claim("scp", "access_as_user") // Scopes
        };

        var identity = new ClaimsIdentity(claims, "Mock");
        var principal = new ClaimsPrincipal(identity);
        var ticket = new AuthenticationTicket(principal, "Mock");

        return Task.FromResult(AuthenticateResult.Success(ticket));
    }
}
using Anela.Heblo.Application.Features.Purchase.Model;
using MediatR;
using Microsoft.AspNetCore.Mvc;

namespace Anela.Heblo.API.Controllers;

[ApiController]
[Route("api/purchase-orders")]
public class PurchaseOrdersController : ControllerBase
{
    private readonly IMediator _mediator;

    public PurchaseOrdersController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpGet]
    public async Task<ActionResult<GetPurchaseOrdersResponse>> GetPurchaseOrders(
        [FromQuery] string? searchTerm = null,
        [FromQuery] string? status = null,
        [FromQuery] DateTime? fromDate = null,
        [FromQuery] DateTime? toDate = null,
        [FromQuery] Guid? supplierId = null,
        [FromQuery] int pageNumber = 1,
        [FromQuery] int pageSize = 20,
        [FromQuery] string sortBy = "OrderDate",
        [FromQuery] bool sortDescending = true,
        CancellationToken cancellationToken = default)
    {
        var request = new GetPurchaseOrdersRequest(
            searchTerm, status, fromDate, toDate, supplierId,
            pageNumber, pageSize, sortBy, sortDescending);

        var response = await _mediator.Send(request, cancellationToken);
        return Ok(response);
    }

    [HttpPost]
    public async Task<ActionResult<CreatePurchaseOrderResponse>> CreatePurchaseOrder(
        [FromBody] CreatePurchaseOrderRequest request,
        CancellationToken cancellationToken)
    {
        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        var response = await _mediator.Send(request, cancellationToken);
        return CreatedAtAction(nameof(GetPurchaseOrderById), new { id = response.Id }, response);
    }

    [HttpGet("{id:guid}")]
    public async Task<ActionResult<GetPurchaseOrderByIdResponse>> GetPurchaseOrderById(
        [FromRoute] Guid id,
        CancellationToken cancellationToken)
    {
        var request = new GetPurchaseOrderByIdRequest(id);
        var response = await _mediator.Send(request, cancellationToken);

        if (response == null)
        {
            return NotFound($"Purchase order with ID {id} not found");
        }

        return Ok(response);
    }

    [HttpPut("{id:guid}")]
    public async Task<ActionResult<UpdatePurchaseOrderResponse>> UpdatePurchaseOrder(
        [FromRoute] Guid id,
        [FromBody] UpdatePurchaseOrderRequest request,
        CancellationToken cancellationToken)
    {
        if (id != request.Id)
        {
            return BadRequest("Route ID does not match request ID");
        }

        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        try
        {
            var response = await _mediator.Send(request, cancellationToken);

            if (response == null)
            {
                return NotFound($"Purchase order with ID {id} not found");
            }

            return Ok(response);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(ex.Message);
        }
    }

    [HttpPut("{id:guid}/status")]
    public async Task<ActionResult<UpdatePurchaseOrderStatusResponse>> UpdatePurchaseOrderStatus(
        [FromRoute] Guid id,
        [FromBody] UpdatePurchaseOrderStatusRequest request,
        CancellationToken cancellationToken)
    {
        if (id != request.Id)
        {
            return BadRequest("Route ID does not match request ID");
        }

        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        try
        {
            var response = await _mediator.Send(request, cancellationToken);

            if (response == null)
            {
                return NotFound($"Purchase order with ID {id} not found");
            }

            return Ok(response);
        }
        catch (ArgumentException ex)
        {
            return BadRequest(ex.Message);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(ex.Message);
        }
    }

    [HttpGet("{id:guid}/history")]
    public async Task<ActionResult<List<PurchaseOrderHistoryDto>>> GetPurchaseOrderHistory(
        [FromRoute] Guid id,
        CancellationToken cancellationToken)
    {
        var request = new GetPurchaseOrderByIdRequest(id);
        var response = await _mediator.Send(request, cancellationToken);

        if (response == null)
        {
            return NotFound($"Purchase order with ID {id} not found");
        }

        return Ok(response.History);
    }
}
using Microsoft.AspNetCore.Mvc;
using MediatR;
using Anela.Heblo.Application.Features.Catalog.Model;
using Microsoft.AspNetCore.Authorization;

namespace Anela.Heblo.API.Controllers;

[Authorize]
[ApiController]
[Route("api/[controller]")]
public class CatalogController : ControllerBase
{
    private readonly IMediator _mediator;
    private readonly ILogger<CatalogController> _logger;

    public CatalogController(IMediator mediator, ILogger<CatalogController> logger)
    {
        _mediator = mediator;
        _logger = logger;
    }

    [HttpGet]
    public async Task<ActionResult<GetCatalogListResponse>> GetCatalogList([FromQuery] GetCatalogListRequest request)
    {
        _logger.LogInformation("Getting catalog list with page {PageNumber}, size {PageSize}, product name {ProductName}",
            request.PageNumber, request.PageSize, request.ProductName);

        try
        {
            var response = await _mediator.Send(request);
            _logger.LogInformation("Successfully retrieved catalog list with {Count} items, total {TotalCount}",
                response.Items.Count, response.TotalCount);
            return Ok(response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get catalog list");
            throw;
        }
    }

    [HttpGet("{productCode}")]
    public async Task<ActionResult<GetCatalogDetailResponse>> GetCatalogDetail(string productCode)
    {
        _logger.LogInformation("Getting catalog detail for product code {ProductCode}", productCode);

        try
        {
            var request = new GetCatalogDetailRequest { ProductCode = productCode };
            var response = await _mediator.Send(request);
            _logger.LogInformation("Successfully retrieved catalog detail for product {ProductCode}", productCode);
            return Ok(response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get catalog detail for product {ProductCode}", productCode);
            throw;
        }
    }

    [HttpPost("refresh/transport")]
    public async Task<IActionResult> RefreshTransportData()
    {
        await _mediator.Send(new RefreshTransportDataRequest());
        return NoContent();
    }

    [HttpPost("refresh/reserve")]
    public async Task<IActionResult> RefreshReserveData()
    {
        await _mediator.Send(new RefreshReserveDataRequest());
        return NoContent();
    }

    [HttpPost("refresh/sales")]
    public async Task<IActionResult> RefreshSalesData()
    {
        await _mediator.Send(new RefreshSalesDataRequest());
        return NoContent();
    }

    [HttpPost("refresh/attributes")]
    public async Task<IActionResult> RefreshAttributesData()
    {
        await _mediator.Send(new RefreshAttributesDataRequest());
        return NoContent();
    }

    [HttpPost("refresh/erp-stock")]
    public async Task<IActionResult> RefreshErpStockData()
    {
        await _mediator.Send(new RefreshErpStockDataRequest());
        return NoContent();
    }

    [HttpPost("refresh/eshop-stock")]
    public async Task<IActionResult> RefreshEshopStockData()
    {
        await _mediator.Send(new RefreshEshopStockDataRequest());
        return NoContent();
    }

    [HttpPost("refresh/purchase-history")]
    public async Task<IActionResult> RefreshPurchaseHistoryData()
    {
        await _mediator.Send(new RefreshPurchaseHistoryDataRequest());
        return NoContent();
    }

    [HttpPost("refresh/consumed-history")]
    public async Task<IActionResult> RefreshConsumedHistoryData()
    {
        await _mediator.Send(new RefreshConsumedHistoryDataRequest());
        return NoContent();
    }

    [HttpPost("refresh/stock-taking")]
    public async Task<IActionResult> RefreshStockTakingData()
    {
        await _mediator.Send(new RefreshStockTakingDataRequest());
        return NoContent();
    }

    [HttpPost("refresh/lots")]
    public async Task<IActionResult> RefreshLotsData()
    {
        await _mediator.Send(new RefreshLotsDataRequest());
        return NoContent();
    }

}
using Anela.Heblo.Application.Features.Weather.Model;
using MediatR;
using Microsoft.AspNetCore.Mvc;

namespace Anela.Heblo.API.Controllers;

[ApiController]
[Route("api/[controller]")]
public class WeatherController : ControllerBase
{
    private readonly IMediator _mediator;

    public WeatherController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpGet("forecast")]
    public async Task<IEnumerable<GetWeatherForecastResponse>> GetWeatherForecast(CancellationToken cancellationToken)
    {
        var request = new GetWeatherForecastRequest();
        return await _mediator.Send(request, cancellationToken);
    }
}
using Microsoft.AspNetCore.Mvc;
using Microsoft.ApplicationInsights;
using Microsoft.ApplicationInsights.DataContracts;

namespace Anela.Heblo.API.Controllers;

[ApiController]
[Route("api/[controller]")]
public class DiagnosticsController : ControllerBase
{
    private readonly ILogger<DiagnosticsController> _logger;
    private readonly TelemetryClient _telemetryClient;

    public DiagnosticsController(ILogger<DiagnosticsController> logger, TelemetryClient telemetryClient)
    {
        _logger = logger;
        _telemetryClient = telemetryClient;
    }

    [HttpGet("test-logging")]
    public IActionResult TestLogging()
    {
        _logger.LogInformation("Test Information log from Diagnostics endpoint");
        _logger.LogWarning("Test Warning log from Diagnostics endpoint");
        _logger.LogError("Test Error log from Diagnostics endpoint");

        // Custom telemetry events
        _telemetryClient.TrackEvent("DiagnosticsTestEvent", new Dictionary<string, string>
        {
            ["TestType"] = "Logging",
            ["Timestamp"] = DateTimeOffset.UtcNow.ToString("O"),
            ["Environment"] = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "Unknown"
        });

        // Custom metric
        _telemetryClient.TrackMetric("TestMetric", 42.0, new Dictionary<string, string>
        {
            ["MetricType"] = "DiagnosticTest"
        });

        return Ok(new
        {
            Message = "Logging test completed",
            Timestamp = DateTimeOffset.UtcNow,
            Environment = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT"),
            ApplicationInsightsConfigured = !string.IsNullOrEmpty(_telemetryClient.InstrumentationKey)
        });
    }

    [HttpGet("test-exception")]
    public IActionResult TestException()
    {
        try
        {
            throw new InvalidOperationException("This is a test exception for Application Insights");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Test exception occurred in Diagnostics endpoint");

            // Track exception in Application Insights
            _telemetryClient.TrackException(ex, new Dictionary<string, string>
            {
                ["TestType"] = "Exception",
                ["Endpoint"] = "DiagnosticsController.TestException"
            });

            return StatusCode(500, new
            {
                Message = "Test exception thrown and logged",
                ExceptionType = ex.GetType().Name,
                ExceptionMessage = ex.Message
            });
        }
    }

    [HttpGet("health")]
    public IActionResult Health()
    {
        _logger.LogInformation("Health check endpoint called");

        return Ok(new
        {
            Status = "Healthy",
            Timestamp = DateTimeOffset.UtcNow,
            Version = "1.0.0",
            Environment = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT"),
            MachineName = Environment.MachineName
        });
    }

    [HttpGet("appinsights-config")]
    public IActionResult GetApplicationInsightsConfig()
    {
        var connectionString = Environment.GetEnvironmentVariable("APPLICATIONINSIGHTS_CONNECTION_STRING")
                            ?? Environment.GetEnvironmentVariable("APPINSIGHTS_INSTRUMENTATIONKEY");

        var hasConnectionString = !string.IsNullOrEmpty(connectionString);
        var hasInstrumentationKey = !string.IsNullOrEmpty(_telemetryClient.InstrumentationKey);

        _logger.LogInformation("Application Insights configuration check - HasConnectionString: {HasConnectionString}, HasInstrumentationKey: {HasInstrumentationKey}",
            hasConnectionString, hasInstrumentationKey);

        return Ok(new
        {
            HasConnectionString = hasConnectionString,
            HasInstrumentationKey = hasInstrumentationKey,
            InstrumentationKey = hasInstrumentationKey ? _telemetryClient.InstrumentationKey : "Not configured",
            Environment = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT"),
            ConnectionStringSource = connectionString?.Substring(0, Math.Min(50, connectionString.Length)) + "...",
            CloudRole = _telemetryClient.Context.Cloud.RoleName,
            CloudRoleInstance = _telemetryClient.Context.Cloud.RoleInstance
        });
    }
}
using Anela.Heblo.Application.Features.Configuration.Model;
using MediatR;
using Microsoft.AspNetCore.Mvc;

namespace Anela.Heblo.API.Controllers;

[ApiController]
[Route("api/[controller]")]
public class ConfigurationController : ControllerBase
{
    private readonly IMediator _mediator;

    public ConfigurationController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpGet]
    public async Task<GetConfigurationResponse> GetConfiguration(CancellationToken cancellationToken)
    {
        var request = new GetConfigurationRequest();
        return await _mediator.Send(request, cancellationToken);
    }
}
using Anela.Heblo.Application.Features.Audit.Model;
using MediatR;
using Microsoft.AspNetCore.Mvc;

namespace Anela.Heblo.API.Controllers;

[ApiController]
[Route("api/[controller]")]
public class AuditController : ControllerBase
{
    private readonly IMediator _mediator;
    private readonly ILogger<AuditController> _logger;

    public AuditController(IMediator mediator, ILogger<AuditController> logger)
    {
        _mediator = mediator ?? throw new ArgumentNullException(nameof(mediator));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    [HttpGet("data-loads")]
    public async Task<IActionResult> GetDataLoadAuditLogs(
        [FromQuery] int? limit = 100,
        [FromQuery] DateTime? fromDate = null,
        [FromQuery] DateTime? toDate = null)
    {
        try
        {
            var request = new GetAuditLogsRequest
            {
                Limit = limit,
                FromDate = fromDate,
                ToDate = toDate
            };

            var response = await _mediator.Send(request);

            return Ok(response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving data load audit logs");
            return StatusCode(500, new
            {
                Message = "Error retrieving audit logs",
                Error = ex.Message
            });
        }
    }

    [HttpGet("summary")]
    public async Task<IActionResult> GetAuditSummary([FromQuery] DateTime? fromDate = null, [FromQuery] DateTime? toDate = null)
    {
        try
        {
            var request = new GetAuditSummaryRequest
            {
                FromDate = fromDate,
                ToDate = toDate
            };

            var response = await _mediator.Send(request);

            return Ok(response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving audit summary");
            return StatusCode(500, new
            {
                Message = "Error retrieving audit summary",
                Error = ex.Message
            });
        }
    }
}
using Anela.Heblo.Adapters.Comgate;
using Anela.Heblo.Adapters.Flexi;
using Anela.Heblo.Adapters.Shoptet;
using Anela.Heblo.API.Extensions;
using Anela.Heblo.Application;
using Anela.Heblo.Persistence;
using Anela.Heblo.Xcc;

namespace Anela.Heblo.API;

public class Program
{
    public static void Main(string[] args)
    {
        var builder = WebApplication.CreateBuilder(args);

        // Configure application timezone based on configuration
        builder.Configuration.ConfigureApplicationTimeZone();

        // Configure logging
        builder.Logging.ConfigureApplicationLogging(builder.Configuration, builder.Environment);

        // Create a temporary logger for startup configuration
        using var loggerFactory = LoggerFactory.Create(logging => logging.AddConsole());
        var logger = loggerFactory.CreateLogger<Program>();

        // Configure services
        builder.Services.ConfigureAuthentication(builder, logger);
        builder.Services.AddApplicationInsightsServices(builder.Configuration, builder.Environment);
        builder.Services.AddCorsServices(builder.Configuration);
        builder.Services.AddHealthCheckServices(builder.Configuration);

        // Add new architecture services
        builder.Services.AddPersistenceServices(builder.Configuration);
        builder.Services.AddApplicationServices(); // Vertical slice modules from Application layer
        builder.Services.AddXccServices(); // Cross-cutting concerns (audit, telemetry, etc.)
        builder.Services.AddCrossCuttingServices(); // Cross-cutting services from API layer
        builder.Services.AddSpaServices();

        // Adapters
        builder.Services.AddFlexiAdapter(builder.Configuration);
        builder.Services.AddShoptetAdapter(builder.Configuration);
        builder.Services.AddComgateAdapter(builder.Configuration);

        // Controllers and API documentation
        builder.Services.AddControllers();
        builder.Services.AddSwaggerServices(builder.Configuration);
        builder.Services.AddOpenApiDocument();

        var app = builder.Build();

        // Configure pipeline
        app.ConfigureApplicationPipeline();

        app.Run();
    }

}
