name: üöÄ Deploy to Production

on:
  push:
    branches: [main]
    tags: ['v*']
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests (emergency deployment)'
        required: false
        default: false
        type: boolean

# Cancel previous production deployments
concurrency:
  group: production-deployment
  cancel-in-progress: true

permissions:
  contents: write
  packages: write

env:
  REGISTRY: docker.io
  IMAGE_NAME: heblo
  AZURE_WEBAPP_NAME: heblo

jobs:
  # Generate Version
  version:
    name: üîñ Generate Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîñ Install GitVersion
        uses: gittools/actions/gitversion/setup@v3.0.0
        with:
          versionSpec: '6.0.x'

      - name: üîñ Determine version with GitVersion
        id: gitversion
        uses: gittools/actions/gitversion/execute@v3.0.0
        with:
          useConfigFile: true

      - name: üîñ Set version outputs
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # If triggered by tag, use the tag as version
            VERSION=${GITHUB_REF#refs/tags/}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=$VERSION" >> $GITHUB_OUTPUT
            echo "üìå Using tag version: $VERSION"
          else
            # Use GitVersion generated version (clean version without pre-release suffixes)
            VERSION="v${{ steps.gitversion.outputs.majorMinorPatch }}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=$VERSION" >> $GITHUB_OUTPUT
            echo "üî¢ GitVersion generated: $VERSION"
            echo "üî¢ Full version info: ${{ steps.gitversion.outputs.fullSemVer }}"
            echo "üî¢ Informational version: ${{ steps.gitversion.outputs.informationalVersion }}"
          fi

  # Build and Push Docker Image
  build-and-push:
    name: üê≥ Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: [version]
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üìù Generate Changelog
        run: |
          chmod +x ./scripts/generate-changelog.sh
          ./scripts/generate-changelog.sh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITVERSION_SEMVER: ${{ needs.version.outputs.version }}
          
      - name: üåê Translate Changelog to Czech
        run: |
          echo "üìã Translating changelog to Czech..."
          
          # Check if OPENAI_API_KEY is set
          if [ -z "${{ secrets.OPENAI_API_KEY }}" ]; then
            echo "‚ùå OPENAI_API_KEY secret is not set!"
            exit 1
          fi
          
          # Read and prepare the source file
          echo "üìã Preparing source JSON..."
          SOURCE_JSON=$(cat frontend/public/changelog.json)
          echo "üìã Source JSON size: ${#SOURCE_JSON} characters"
          
          # Create the request payload using jq to properly escape JSON
          REQUEST_PAYLOAD=$(jq -n \
            --arg source_json "$SOURCE_JSON" \
            '{
              "model": "gpt-4o-mini",
              "messages": [
                {"role": "system", "content": "You are a professional translator specializing in technical documentation. Translate from English to Czech while preserving technical terms and JSON structure. Return only valid JSON without markdown formatting or code blocks."},
                {"role": "user", "content": "P≈ôelo≈æ v≈°echny hodnoty v JSONu z angliƒçtiny do ƒçe≈°tiny. Zachovej strukturu JSON a technick√© term√≠ny (fix, feature, commit, docs etc). N√°vratov√° hodnota mus√≠ b√Ωt pouze validn√≠ JSON bez jak√©hokoliv markdown form√°tov√°n√≠ nebo code block≈Ø."},
                {"role": "user", "content": $source_json}
              ]
            }')
          
          echo "üìã Request payload size: ${#REQUEST_PAYLOAD} characters"
          
          # Make the API call
          echo "üìã Calling OpenAI API..."
          RESPONSE=$(curl -s -w "\n%{http_code}" https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.OPENAI_API_KEY }}" \
            -d "$REQUEST_PAYLOAD")
          
          # Extract HTTP status code and response body
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | head -n -1)
          
          echo "üìã HTTP Status: $HTTP_CODE"
          echo "üìã Response size: ${#RESPONSE_BODY} characters"
          
          # Check HTTP status
          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "‚ùå OpenAI API call failed with status $HTTP_CODE"
            echo "Response:"
            echo "$RESPONSE_BODY"
            exit 1
          fi
          
          # Check if response is valid JSON
          if ! echo "$RESPONSE_BODY" | jq empty; then
            echo "‚ùå OpenAI API returned invalid JSON"
            echo "Response:"
            echo "$RESPONSE_BODY"
            exit 1
          fi
          
          # Extract the translated content
          TRANSLATED_CONTENT=$(echo "$RESPONSE_BODY" | jq -r '.choices[0].message.content')
          
          if [ "$TRANSLATED_CONTENT" = "null" ] || [ -z "$TRANSLATED_CONTENT" ]; then
            echo "‚ùå No translation content in API response"
            echo "API Response:"
            echo "$RESPONSE_BODY"
            exit 1
          fi
          
          echo "üìã Raw translated content size: ${#TRANSLATED_CONTENT} characters"
          
          # Extract JSON from markdown code blocks if present
          if echo "$TRANSLATED_CONTENT" | grep -q '```json'; then
            echo "üìã Extracting JSON from markdown code block..."
            TRANSLATED_JSON=$(echo "$TRANSLATED_CONTENT" | sed -n '/```json/,/```/p' | sed '1d;$d')
          else
            echo "üìã Using direct content as JSON..."
            TRANSLATED_JSON="$TRANSLATED_CONTENT"
          fi
          
          if [ -z "$TRANSLATED_JSON" ]; then
            echo "‚ùå No JSON content found in translation"
            echo "Full content:"
            echo "$TRANSLATED_CONTENT"
            exit 1
          fi
          
          echo "üìã Extracted JSON size: ${#TRANSLATED_JSON} characters"
          
          # Save the translated content
          echo "$TRANSLATED_JSON" > frontend/public/changelog.cs.json
          
          # Validate the translated JSON
          if ! jq empty frontend/public/changelog.cs.json; then
            echo "‚ùå Translated changelog.cs.json is not valid JSON!"
            echo "Translated content:"
            cat frontend/public/changelog.cs.json
            exit 1
          fi
          
          echo "‚úÖ Czech translation generated successfully!"
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          

      - name: üìã Validate Generated Changelogs
        run: |
          # Validate English JSON format
          if ! jq empty frontend/public/changelog.json; then
            echo "‚ùå Generated changelog.json is not valid JSON!"
            exit 1
          fi
          echo "‚úÖ English changelog JSON is valid"
          
          # Validate Czech JSON format
          if ! jq empty frontend/public/changelog.cs.json; then
            echo "‚ùå Generated changelog.cs.json is not valid JSON!"
            exit 1
          fi
          echo "‚úÖ Czech changelog JSON is valid"
          
          # Check files exist and have content
          if [ ! -s frontend/public/changelog.json ]; then
            echo "‚ùå English changelog file is empty or doesn't exist!"
            exit 1
          fi
          echo "‚úÖ English changelog file has content ($(wc -c < frontend/public/changelog.json) bytes)"
          
          if [ ! -s frontend/public/changelog.cs.json ]; then
            echo "‚ùå Czech changelog file is empty or doesn't exist!"
            exit 1
          fi
          echo "‚úÖ Czech changelog file has content ($(wc -c < frontend/public/changelog.cs.json) bytes)"

      - name: üì§ Upload Changelog Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: changelog-production
          path: |
            frontend/public/changelog.json
            frontend/public/changelog.cs.json
          retention-days: 90

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: üìù Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=tag
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ needs.version.outputs.version }}
            type=sha,prefix=sha-

      - name: üèóÔ∏è Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            REACT_APP_API_URL=https://heblo.anela.cz
            REACT_APP_USE_MOCK_AUTH=false
            REACT_APP_AZURE_CLIENT_ID=${{ secrets.REACT_APP_AZURE_CLIENT_ID }}
            REACT_APP_AZURE_AUTHORITY=${{ secrets.REACT_APP_AZURE_AUTHORITY }}
            REACT_APP_AZURE_BACKEND_CLIENT_ID=${{ secrets.REACT_APP_AZURE_BACKEND_CLIENT_ID }}
            REACT_APP_AZURE_TENANT_ID=${{ secrets.REACT_APP_AZURE_TENANT_ID }}

      - name: üîñ Create Git Tag
        if: github.ref == 'refs/heads/main' && !startsWith(github.ref, 'refs/tags/')
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag ${{ needs.version.outputs.tag }}
          git push origin ${{ needs.version.outputs.tag }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
  # Deploy to Azure Web App
  deploy-azure:
    name: üöÄ Deploy to Azure
    runs-on: ubuntu-latest
    needs: [build-and-push, version]
    outputs:
      webapp-hostname: ${{ steps.deploy.outputs.hostname }}
    environment:
      name: production
      url: https://heblo.anela.cz
    steps:
      - name: üîê Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS_PROD }}

      - name: üöÄ Deploy to Azure Web App
        id: deploy
        run: |
          # Get the actual web app name (Azure might have generated a different name)
          ACTUAL_WEBAPP_NAME=$(az webapp list \
            --resource-group rgHeblo \
            --query "[?contains(name, 'heblo') && !contains(name, 'test')].name" \
            --output tsv | head -1)
          
          if [ -z "$ACTUAL_WEBAPP_NAME" ]; then
            echo "‚ùå No production web app found in resource group rgHeblo"
            echo "Available web apps:"
            az webapp list --resource-group rgHeblo --query "[].name" -o table
            exit 1
          fi
          
          echo "üéØ Found production web app: $ACTUAL_WEBAPP_NAME"
          
          # Deploy container to the web app
          echo "üê≥ Setting Docker container..."
          
          # Build Docker image name with specific version
          DOCKER_IMAGE="remiiik/heblo:${{ needs.version.outputs.version }}"
          
          # Try to use build output first, fallback to versioned image
          BUILD_OUTPUT_IMAGE=$(echo "${{ needs.build-and-push.outputs.image-tag }}" | grep -E "remiiik/heblo:v[0-9]+\.[0-9]+\.[0-9]+" | head -1)
          if [ -n "$BUILD_OUTPUT_IMAGE" ]; then
            DOCKER_IMAGE="$BUILD_OUTPUT_IMAGE"
            echo "üìç Using build output image: $DOCKER_IMAGE"
          else
            echo "‚ö†Ô∏è Build output empty, using versioned image: $DOCKER_IMAGE"
          fi
          
          # Validate Docker image is set
          if [ -z "$DOCKER_IMAGE" ]; then
            echo "‚ùå Error: Docker image is empty!"
            echo "Build output: '${{ needs.build-and-push.outputs.image-tag }}'"
            echo "Version: '${{ needs.version.outputs.version }}'"
            exit 1
          fi
          
          # Configure container deployment using modern approach
          echo "üîß Configuring Web App for Container deployment..."
          echo "üè∑Ô∏è Image: $DOCKER_IMAGE"
          
          # Set the container image directly via config
          az webapp config set \
            --name $ACTUAL_WEBAPP_NAME \
            --resource-group rgHeblo \
            --linux-fx-version "DOCKER|$DOCKER_IMAGE" \
            --output none
          
          # Configure container registry settings
          az webapp config container set \
            --name $ACTUAL_WEBAPP_NAME \
            --resource-group rgHeblo \
            --container-image-name "$DOCKER_IMAGE" \
            --container-registry-url https://index.docker.io/v1/ \
            --output none
          
          # Restart web app to ensure container configuration is applied
          echo "üîÑ Restarting web app to apply container configuration..."
          az webapp restart \
            --name $ACTUAL_WEBAPP_NAME \
            --resource-group rgHeblo \
            --output none
          
          # Wait for restart to complete
          echo "‚è±Ô∏è Waiting for restart to complete..."
          sleep 15
          
          # Verify container configuration
          echo "üîç Verifying container configuration..."
          WEBAPP_CONFIG=$(az webapp config show \
            --name $ACTUAL_WEBAPP_NAME \
            --resource-group rgHeblo \
            --query '{linuxFxVersion: linuxFxVersion}' \
            --output json)
          
          LINUX_FX_VERSION=$(echo $WEBAPP_CONFIG | jq -r '.linuxFxVersion')
          echo "üìã Container Configuration: $LINUX_FX_VERSION"
          
          if [[ "$LINUX_FX_VERSION" == DOCKER* ]]; then
            echo "‚úÖ Container mode successfully configured"
          else
            echo "‚ùå Error: Container mode not properly set"
            echo "Expected: DOCKER|$DOCKER_IMAGE"
            echo "Actual: $LINUX_FX_VERSION"
            exit 1
          fi
            
          echo "‚úÖ Container deployment completed"
          
          # Get hostname for output
          WEBAPP_HOSTNAME=$(az webapp show \
            --name $ACTUAL_WEBAPP_NAME \
            --resource-group rgHeblo \
            --query "defaultHostName" \
            --output tsv)
          
          # Store for later steps
          echo "ACTUAL_WEBAPP_NAME=$ACTUAL_WEBAPP_NAME" >> $GITHUB_ENV
          echo "hostname=$WEBAPP_HOSTNAME" >> $GITHUB_OUTPUT

      - name: üîß Configure App Settings
        run: |
          # Get the actual hostname for the web app
          WEBAPP_HOSTNAME=$(az webapp show \
            --name $ACTUAL_WEBAPP_NAME \
            --resource-group rgHeblo \
            --query "defaultHostName" -o tsv)
          
          echo "üåê Web app hostname: $WEBAPP_HOSTNAME"
          
          # Get Application Insights instrumentation key
          AI_INSTRUMENTATION_KEY=$(az monitor app-insights component show \
            --app aiHeblo \
            --resource-group rgHeblo \
            --query instrumentationKey -o tsv 2>/dev/null || echo "")
          
          # Configure only deployment-specific settings, preserve Azure AD configuration
          echo "üîß Configuring deployment-specific app settings..."
          echo "‚ÑπÔ∏è Azure AD settings are managed manually in Azure Portal"
          
          # Configure minimal deployment settings - Azure AD settings preserved
          az webapp config appsettings set \
            --resource-group rgHeblo \
            --name $ACTUAL_WEBAPP_NAME \
            --settings \
              ASPNETCORE_ENVIRONMENT=Production \
              REACT_APP_API_URL=https://heblo.anela.cz \
              REACT_APP_USE_MOCK_AUTH=false \
              WEBSITES_PORT=8080 \
              WEBSITES_ENABLE_APP_SERVICE_STORAGE=false \
              DOCKER_REGISTRY_SERVER_URL=https://index.docker.io \
              SCM_DO_BUILD_DURING_DEPLOYMENT=false \
              APP_VERSION=${{ needs.version.outputs.version }} \
              ${AI_INSTRUMENTATION_KEY:+APPINSIGHTS_INSTRUMENTATIONKEY=$AI_INSTRUMENTATION_KEY} \
              ${AI_INSTRUMENTATION_KEY:+APPLICATIONINSIGHTS_CONNECTION_STRING=InstrumentationKey=$AI_INSTRUMENTATION_KEY}
          
          echo "‚úÖ Deployment settings configured"
          echo "‚ö†Ô∏è Ensure Azure AD settings are manually configured in Azure Portal:"
          echo "   - AzureAd__TenantId"
          echo "   - AzureAd__ClientId" 
          echo "   - AzureAd__Instance"
          echo "   - AzureAd__Domain"
          echo "   - AzureAd__Scopes"
          echo "   - AzureAd__CallbackPath"
          echo "   - REACT_APP_AZURE_CLIENT_ID"
          echo "   - REACT_APP_AZURE_AUTHORITY"
          
          # Store hostname for smoke tests
          echo "WEBAPP_HOSTNAME=$WEBAPP_HOSTNAME" >> $GITHUB_ENV

      - name: üìä Configure App Service Logging
        run: |
          echo "üîß Configuring App Service diagnostic settings for container logs..."
          
          # Get Application Insights resource details
          AI_RESOURCE_ID=$(az monitor app-insights component show \
            --app aiHeblo \
            --resource-group rgHeblo \
            --query id -o tsv 2>/dev/null || echo "")
          
          if [ -n "$AI_RESOURCE_ID" ]; then
            echo "üìä Found Application Insights resource: $AI_RESOURCE_ID"
            
            # Configure diagnostic settings to send container logs to Application Insights
            az monitor diagnostic-settings create \
              --resource $ACTUAL_WEBAPP_NAME \
              --resource-group rgHeblo \
              --resource-type Microsoft.Web/sites \
              --name "ContainerLogsToAppInsights" \
              --workspace $AI_RESOURCE_ID \
              --logs '[
                {
                  "category": "AppServiceConsoleLogs",
                  "enabled": true
                },
                {
                  "category": "AppServiceAppLogs", 
                  "enabled": true
                },
                {
                  "category": "AppServiceHTTPLogs",
                  "enabled": true
                },
                {
                  "category": "AppServicePlatformLogs",
                  "enabled": true
                }
              ]' \
              --output none || echo "‚ö†Ô∏è Diagnostic settings may already exist"
            
            echo "‚úÖ Diagnostic settings configured"
          else
            echo "‚ö†Ô∏è Application Insights not found - skipping diagnostic settings"
          fi
          
          # Enable container logging in App Service
          az webapp log config \
            --name $ACTUAL_WEBAPP_NAME \
            --resource-group rgHeblo \
            --docker-container-logging filesystem \
            --output none
          
          echo "‚úÖ Container logging enabled"

  # Smoke Tests
  smoke-tests:
    name: üí® Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy-azure]
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üí® Run smoke tests
        run: |
          echo "üß™ Running production smoke tests..."
          
          BASE_URL="https://${{ needs.deploy-azure.outputs.webapp-hostname }}"
          
          # Test 1: Health check
          echo "üè• Testing health endpoint..."
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $BASE_URL/health/live)
          if [ "$HEALTH_STATUS" != "200" ]; then
            echo "‚ùå Health check failed: $HEALTH_STATUS"
            exit 1
          fi
          echo "‚úÖ Health check passed"
          
          # Test 2: Main page loads
          echo "üåê Testing main page..."
          MAIN_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $BASE_URL/)
          if [ "$MAIN_STATUS" != "200" ]; then
            echo "‚ùå Main page failed: $MAIN_STATUS"
            exit 1
          fi
          echo "‚úÖ Main page loads"
          
          # Test 3: API endpoint responds (may require auth)
          echo "üîå Testing API endpoint..."
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $BASE_URL/WeatherForecast)
          if [ "$API_STATUS" != "200" ] && [ "$API_STATUS" != "401" ]; then
            echo "‚ùå API endpoint failed: $API_STATUS"
            exit 1
          fi
          echo "‚úÖ API endpoint responds (status: $API_STATUS)"
          
          echo "üéâ All smoke tests passed!"

  # Create GitHub Release
  create-release:
    name: üì¶ Create GitHub Release
    runs-on: ubuntu-latest
    needs: [smoke-tests, version, build-and-push]
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üìù Generate changelog
        id: changelog
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            PREVIOUS_TAG=$(git describe --tags --abbrev=0 ${{ needs.version.outputs.tag }}^)
          else
            PREVIOUS_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          fi
          
          if [ -n "$PREVIOUS_TAG" ]; then
            echo "## Changes since $PREVIOUS_TAG" > CHANGELOG.md
            git log $PREVIOUS_TAG..HEAD --pretty=format:"- %s (%h)" >> CHANGELOG.md
          else
            echo "## Initial Release" > CHANGELOG.md
            echo "- First production deployment" >> CHANGELOG.md
          fi
          
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          cat CHANGELOG.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: üì¶ Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.version.outputs.tag }}
          release_name: Release ${{ needs.version.outputs.version }}
          body: |
            ${{ steps.changelog.outputs.changelog }}
            
            ## Deployment Info
            - **Environment:** Production
            - **URL:** https://${{ needs.deploy-azure.outputs.webapp-hostname }}
            - **Docker Image:** `${{ needs.build-and-push.outputs.image-tag }}`
            - **Deployed at:** ${{ github.event.head_commit.timestamp }}
          draft: false
          prerelease: false

  # Notification
  notify:
    name: üì¢ Deployment Notification
    runs-on: ubuntu-latest
    needs: [deploy-azure, smoke-tests, create-release, version]
    if: always()
    steps:
      - name: üì¢ Production Deployment Summary
        run: |
          echo "## üöÄ Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** \`${{ needs.version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** Production" >> $GITHUB_STEP_SUMMARY
          echo "**URL:** https://${{ needs.deploy-azure.outputs.webapp-hostname }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.smoke-tests.result }}" = "success" ]; then
            echo "‚úÖ **Status:** Deployment successful" >> $GITHUB_STEP_SUMMARY
            echo "üéâ **Production is live!**" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Status:** Deployment failed" >> $GITHUB_STEP_SUMMARY
            echo "üö® **Production deployment needs attention!**" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Release:** [View on GitHub](https://github.com/${{ github.repository }}/releases/tag/${{ needs.version.outputs.tag }})" >> $GITHUB_STEP_SUMMARY

      - name: üì± Send Teams Notification
        if: always()
        env:
          TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
        run: |
          # Skip if webhook URL is not configured
          if [ -z "$TEAMS_WEBHOOK_URL" ]; then
            echo "‚ö†Ô∏è Teams webhook not configured, skipping notification"
            exit 0
          fi
          
          # Determine status color and emoji
          if [ "${{ needs.smoke-tests.result }}" = "success" ]; then
            COLOR="00FF00"
            STATUS_EMOJI="‚úÖ"
            STATUS_TEXT="Deployment Successful"
          else
            COLOR="FF0000"
            STATUS_EMOJI="‚ùå"
            STATUS_TEXT="Deployment Failed"
          fi
          
          # Create Teams message payload
          PAYLOAD=$(cat <<EOF
          {
            "@type": "MessageCard",
            "@context": "http://schema.org/extensions",
            "themeColor": "$COLOR",
            "summary": "Heblo Production Deployment - $STATUS_TEXT",
            "sections": [{
              "activityTitle": "$STATUS_EMOJI Heblo Production Deployment",
              "activitySubtitle": "$STATUS_TEXT",
              "activityImage": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png",
              "facts": [
                {
                  "name": "Version",
                  "value": "${{ needs.version.outputs.version }}"
                },
                {
                  "name": "Environment",
                  "value": "Production"
                },
                {
                  "name": "Commit",
                  "value": "\`${GITHUB_SHA:0:7}\`"
                },
                {
                  "name": "Author",
                  "value": "${{ github.actor }}"
                },
                {
                  "name": "Branch",
                  "value": "${{ github.ref_name }}"
                }
              ],
              "markdown": true
            }],
            "potentialAction": [
              {
                "@type": "OpenUri",
                "name": "View Application",
                "targets": [
                  {
                    "os": "default",
                    "uri": "https://${{ needs.deploy-azure.outputs.webapp-hostname }}"
                  }
                ]
              },
              {
                "@type": "OpenUri",
                "name": "View Release",
                "targets": [
                  {
                    "os": "default",
                    "uri": "https://github.com/${{ github.repository }}/releases/tag/${{ needs.version.outputs.tag }}"
                  }
                ]
              },
              {
                "@type": "OpenUri",
                "name": "View Workflow",
                "targets": [
                  {
                    "os": "default",
                    "uri": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                ]
              }
            ]
          }
          EOF
          )
          
          # Send notification to Teams
          echo "üì® Sending Teams notification..."
          RESPONSE=$(curl -X POST "$TEAMS_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" \
            -s -w "\n%{http_code}")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Teams notification sent successfully"
          else
            echo "‚ö†Ô∏è Failed to send Teams notification (HTTP $HTTP_CODE)"
            echo "Response: $RESPONSE"
            # Don't fail the workflow if Teams notification fails
            exit 0
          fi